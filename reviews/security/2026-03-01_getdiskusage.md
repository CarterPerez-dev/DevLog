# GetDiskUsage

**Type:** Security Review
**Repository:** Yoshi-Audit
**File:** internal/docker/client.go
**Language:** go
**Lines:** 167-254
**Complexity:** 16.0

---

## Source Code

```go
func (c *Client) GetDiskUsage() ([]ImageInfo, []ContainerInfo, []VolumeInfo, BuildCacheInfo, error) {
	ctx := context.Background()
	du, err := c.cli.DiskUsage(ctx, types.DiskUsageOptions{})
	if err != nil {
		return nil, nil, nil, BuildCacheInfo{}, err
	}

	var images []ImageInfo
	for _, s := range du.Images {
		if s == nil {
			continue
		}
		repo := "<none>"
		tag := "<none>"
		if len(s.RepoTags) > 0 {
			parts := strings.SplitN(s.RepoTags[0], ":", 2)
			repo = parts[0]
			if len(parts) > 1 {
				tag = parts[1]
			}
		}
		dangling := repo == "<none>" && s.Containers == 0
		images = append(images, ImageInfo{
			ID:         s.ID,
			Repository: repo,
			Tag:        tag,
			Size:       s.Size,
			SharedSize: s.SharedSize,
			UniqueSize: s.Size - s.SharedSize,
			Containers: s.Containers,
			Created:    time.Unix(s.Created, 0),
			Dangling:   dangling,
		})
	}

	var containers []ContainerInfo
	for _, s := range du.Containers {
		if s == nil {
			continue
		}
		name := ""
		if len(s.Names) > 0 {
			name = strings.TrimPrefix(s.Names[0], "/")
		}
		containers = append(containers, ContainerInfo{
			ID:      s.ID,
			Name:    name,
			Image:   s.Image,
			Status:  s.Status,
			State:   s.State,
			Size:    s.SizeRw,
			Created: time.Unix(s.Created, 0),
			Running: s.State == "running",
		})
	}

	var volumes []VolumeInfo
	for _, v := range du.Volumes {
		if v == nil {
			continue
		}
		var size int64
		var links int
		if v.UsageData != nil {
			size = v.UsageData.Size
			links = int(v.UsageData.RefCount)
		}
		var created time.Time
		if v.CreatedAt != "" {
			created, _ = time.Parse(time.RFC3339, v.CreatedAt)
		}
		volumes = append(volumes, VolumeInfo{
			Name:    v.Name,
			Size:    size,
			Links:   links,
			Created: created,
		})
	}

	var cacheSize int64
	for _, bc := range du.BuildCache {
		if bc != nil {
			cacheSize += bc.Size
		}
	}

	return images, containers, volumes, BuildCacheInfo{TotalSize: cacheSize}, nil
}
```

---

## Security Review

### Security Review for `GetDiskUsage` Function

#### Vulnerabilities Found:

1. **Info: Input Validation Gaps**
   - **Line 9-16:** The function processes `RepoTags`, but does not validate or sanitize the input, which could lead to potential issues if the input is manipulated.
   - **Severity: Info**

2. **Info: Error Handling**
   - **Line 7:** The error handling for `c.cli.DiskUsage` is minimal and returns the error directly without any additional context or logging.
   - **Severity: Info**

#### Attack Vectors:
- An attacker could manipulate input data to cause unexpected behavior or errors in the application.

#### Recommended Fixes:

1. **Input Validation:**
   - Validate and sanitize `RepoTags` before processing them.
     ```go
     if len(s.RepoTags) > 0 {
         parts := strings.SplitN(strings.TrimSpace(s.RepoTags[0]), ":", 2)
         repo = parts[0]
         if len(parts) > 1 {
             tag = parts[1]
         }
     }
     ```

2. **Enhanced Error Handling:**
   - Log or return more detailed error messages to help with debugging.
     ```go
     if err != nil {
         return nil, nil, nil, BuildCacheInfo{}, fmt.Errorf("failed to get disk usage: %w", err)
     }
     ```

#### Overall Security Posture:
The current implementation has minimal security concerns but can be improved by validating inputs and enhancing error handling. Ensuring that input data is properly sanitized and errors are logged will help maintain a secure posture.

**Fixes Suggested:**
- Implement basic validation for `RepoTags`.
- Improve error logging to provide more context in case of failures.

---

*Generated by CodeWorm on 2026-03-01 21:01*
