# lifespan

**Type:** Security Review
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/factory.py
**Language:** python
**Lines:** 31-117
**Complexity:** 5.0

---

## Source Code

```python
async def lifespan(app: FastAPI) -> AsyncIterator[None]:
    """
    Manage application startup and shutdown lifecycle.
    """
    app.state.startup_time = time.monotonic()
    app.state.pipeline_running = False

    engine = create_async_engine(settings.database_url)
    app.state.db_engine = engine
    app.state.session_factory = async_sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )

    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)
    logger.info("Database tables verified")

    await redis_manager.connect()

    geoip = GeoIPService(settings.geoip_db_path)

    redis_client = redis_manager.client
    assert redis_client is not None

    dispatcher = AlertDispatcher(
        redis_client=redis_client,
        session_factory=app.state.session_factory,
    )

    inference_engine = _load_inference_engine()
    app.state.models_loaded = (
        inference_engine is not None
        and inference_engine.is_loaded
    )
    app.state.detection_mode = (
        "hybrid"
        if app.state.models_loaded
        else "rules"
    )

    pipeline = Pipeline(
        redis_client=redis_client,  # type: ignore[arg-type]
        rule_engine=RuleEngine(),
        geoip=geoip,
        on_result=dispatcher.dispatch,
        inference_engine=inference_engine,
        ensemble_weights={
            "ae": settings.ensemble_weight_ae,
            "rf": settings.ensemble_weight_rf,
            "if": settings.ensemble_weight_if,
        },
        raw_queue_size=settings.raw_queue_size,
        parsed_queue_size=settings.parsed_queue_size,
        feature_queue_size=settings.feature_queue_size,
        alert_queue_size=settings.alert_queue_size,
    )
    await pipeline.start()

    tailer = None
    log_dir = Path(settings.nginx_log_path).resolve().parent
    if log_dir.is_dir():
        loop = asyncio.get_running_loop()
        tailer = LogTailer(settings.nginx_log_path, pipeline.raw_queue, loop)
        tailer.start()
    else:
        logger.warning("Log directory %s not found — tailer disabled", log_dir)

    app.state.pipeline = pipeline
    app.state.tailer = tailer
    app.state.geoip = geoip
    app.state.pipeline_running = True

    logger.info("AngelusVigil started — pipeline active")

    yield

    app.state.pipeline_running = False
    if tailer is not None:
        tailer.stop()
    await pipeline.stop()
    geoip.close()
    await redis_manager.disconnect()
    await engine.dispose()

    logger.info("AngelusVigil shut down cleanly")
```

---

## Security Review

### Security Review for `lifespan` Function

**Vulnerabilities Found:**

1. **Info - Hardcoded Secrets or Credentials**: The code does not contain hardcoded secrets, but it assumes the presence of `settings` which might include sensitive information.
   - **Fix**: Ensure all configuration settings are securely managed and not exposed in source control.

2. **Info - Input Validation Gaps**: There is no explicit input validation for paths like `settings.nginx_log_path`.
   - **Fix**: Implement path validation to prevent directory traversal attacks.

3. **Info - Error Handling**: The error handling does not provide detailed information, which could leak system details.
   - **Fix**: Log errors with minimal detail and use structured logging.

4. **Info - Race Conditions and TOCTOU Bugs**: The `LogTailer` setup might be susceptible to race conditions if the log directory changes between checks.
   - **Fix**: Ensure consistent state management for file operations.

**Attack Vectors:**

- Directory traversal via `settings.nginx_log_path`.
- Information leakage through error logs.

**Recommended Fixes:**

1. Validate and sanitize all paths used in the application.
2. Use structured logging with minimal detail to prevent information leaks.
3. Implement proper race condition handling for file operations.
4. Securely manage configuration settings, avoiding exposure of sensitive data.

**Overall Security Posture:**

The code is generally secure but requires attention to input validation and error handling. Ensuring consistent state management and secure configuration practices will further enhance the security posture.

---

*Generated by CodeWorm on 2026-02-27 22:36*
