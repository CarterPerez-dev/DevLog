# CycleService.get_calendar_month

**Type:** Security Review
**Repository:** ios-test
**File:** fastapi/app/cycle/service.py
**Language:** python
**Lines:** 174-265
**Complexity:** 18.0

---

## Source Code

```python
async def get_calendar_month(
        self,
        user_id: UUID,
        year: int,
        month: int,
    ) -> CalendarMonth:
        """
        Get calendar data for a specific month
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        first_day = date(year, month, 1)
        if month == 12:
            last_day = date(year + 1, 1, 1) - timedelta(days = 1)
        else:
            last_day = date(year, month + 1, 1) - timedelta(days = 1)

        period_logs = await PeriodLogRepository.get_by_partner_id(
            self.session,
            partner.id,
            limit = 12,
        )

        daily_logs = await DailyLogRepository.get_date_range(
            self.session,
            partner.id,
            first_day,
            last_day,
        )
        daily_log_map = {log.log_date: log for log in daily_logs}

        period_dates: set[date] = set()
        predicted_dates: set[date] = set()

        for log in period_logs:
            period_length = partner.average_period_length
            if log.end_date:
                period_length = (log.end_date - log.start_date).days + 1

            for i in range(period_length):
                d = log.start_date + timedelta(days = i)
                if log.is_predicted:
                    predicted_dates.add(d)
                else:
                    period_dates.add(d)

        if partner.last_period_start:
            predicted_start = partner.last_period_start + timedelta(
                days = partner.average_cycle_length
            )
            while predicted_start <= last_day:
                if predicted_start >= first_day:
                    for i in range(partner.average_period_length):
                        d = predicted_start + timedelta(days = i)
                        if first_day <= d <= last_day and d not in period_dates:
                            predicted_dates.add(d)
                predicted_start += timedelta(days = partner.average_cycle_length)

        days: list[CalendarDay] = []
        current_date = first_day

        while current_date <= last_day:
            cycle_day = None
            phase = CyclePhase.UNKNOWN

            if partner.last_period_start:
                days_since = (current_date - partner.last_period_start).days + 1
                if days_since > 0:
                    cycle_day = ((days_since - 1) % partner.average_cycle_length) + 1
                    phase = self._get_phase(cycle_day, partner.average_cycle_length)

            daily_log = daily_log_map.get(current_date)

            days.append(CalendarDay(
                date = current_date,
                cycle_day = cycle_day,
                phase = phase,
                is_period = current_date in period_dates,
                is_predicted_period = current_date in predicted_dates,
                has_daily_log = daily_log is not None,
            
```

---

## Security Review

### Security Review for `CycleService.get_calendar_month`

#### Vulnerabilities and Severity:

1. **Input Validation Gaps** - **Medium**
   - The function accepts `year` and `month` as integers without any validation to ensure they are within valid date ranges.
   - **Attack Vector**: An attacker could input invalid dates, potentially leading to errors or unexpected behavior.

2. **Hardcoded Secrets or Credentials** - **Low**
   - No hardcoded secrets or credentials found in the provided code snippet.

3. **Error Handling** - **Info**
   - The error handling is basic and does not provide detailed information that could be exploited.
   - **Attack Vector**: Detailed error messages might reveal internal implementation details.

4. **Overall Security Posture**:
   - The function is generally secure but lacks input validation for date parameters, which could lead to issues if misused.

#### Recommended Fixes:

1. **Input Validation**:
   ```python
   if not 1 <= month <= 12 or not 1900 <= year <= datetime.now().year:
       raise ValueError("Invalid date range")
   ```

2. **Enhanced Error Handling**:
   - Use generic error messages to avoid leaking internal details.
   ```python
   except Exception as e:
       logger.error(f"Error fetching calendar month: {e}")
       raise HTTPException(status_code=500, detail="Internal Server Error")
   ```

By addressing these points, the function's security posture can be significantly improved.

---

*Generated by CodeWorm on 2026-02-21 14:34*
