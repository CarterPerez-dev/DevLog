# decryptMessage

**Type:** Security Review
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/crypto/double-ratchet.ts
**Language:** typescript
**Lines:** 225-289
**Complexity:** 9.0

---

## Source Code

```typescript
async function decryptMessage(
  state: DoubleRatchetState,
  message: EncryptedMessage,
  associatedData?: Uint8Array
): Promise<Uint8Array> {
  const peerPublicKey = base64ToBytes(message.header.dh_public_key)

  const skippedKeyId = createSkippedKeyId(
    peerPublicKey,
    message.header.message_number
  )
  const skippedKey = state.skipped_message_keys.get(skippedKeyId)

  if (skippedKey !== undefined) {
    state.skipped_message_keys.delete(skippedKeyId)

    const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
    const aad =
      associatedData !== undefined
        ? concatBytes(associatedData, headerBytes)
        : headerBytes

    return await aesGcmDecrypt(skippedKey, message.ciphertext, message.nonce, aad)
  }

  const isDifferentRatchetKey =
    state.dh_peer_public_key === null ||
    bytesToBase64(state.dh_peer_public_key) !== message.header.dh_public_key

  if (isDifferentRatchetKey) {
    if (state.receiving_chain_key !== null && state.dh_peer_public_key !== null) {
      await skipMessageKeys(state, message.header.previous_chain_length)
    }

    await performDHRatchet(state, peerPublicKey)
  }

  await skipMessageKeys(state, message.header.message_number)

  if (state.receiving_chain_key === null) {
    throw new Error('Receiving chain key not initialized after ratchet')
  }

  const { messageKey, nextChainKey } = await deriveMessageKey(
    state.receiving_chain_key
  )

  const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
  const aad =
    associatedData !== undefined
      ? concatBytes(associatedData, headerBytes)
      : headerBytes

  const plaintext = await aesGcmDecrypt(
    messageKey,
    message.ciphertext,
    message.nonce,
    aad
  )

  state.receiving_chain_key = nextChainKey
  state.receiving_message_number++

  return plaintext
}
```

---

## Security Review

### Security Review for `decryptMessage` Function

#### Vulnerabilities and Severity:

1. **Info - Input Validation Gaps:**
   - Lines 7-8: The `peerPublicKey` is derived from a base64 string, but no validation or sanitization is applied to ensure it's a valid public key.
   - Line 20: `message.header.previous_chain_length` and `message.header.message_number` are used directly without validation.

2. **Info - Insecure Deserialization:**
   - Lines 18-23: The `message.header` is serialized into JSON, which could potentially lead to deserialization issues if the header contains malicious data.
   - Line 46: Similar issue with `message.header`.

#### Attack Vectors:
- An attacker could manipulate the `peerPublicKey`, `previous_chain_length`, or `message_number` to cause unexpected behavior or security breaches.

#### Recommended Fixes:

1. **Input Validation:**
   ```typescript
   if (!isBase64(peerPublicKey)) {
     throw new Error('Invalid public key');
   }
   ```

2. **Sanitize and Validate Header Fields:**
   ```typescript
   const header = JSON.parse(new TextDecoder().decode(headerBytes));
   if (typeof header.previous_chain_length !== 'number' || typeof header.message_number !== 'number') {
     throw new Error('Invalid message header');
   }
   ```

3. **Secure Deserialization:**
   - Ensure the `message.header` and other fields are validated before use.

#### Overall Security Posture:
The function is relatively secure but could benefit from additional input validation to prevent potential attacks. Proper handling of public keys, headers, and deserialization can significantly enhance security posture.

---

*Generated by CodeWorm on 2026-02-18 21:47*
