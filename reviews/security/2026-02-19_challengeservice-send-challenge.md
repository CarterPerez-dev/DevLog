# ChallengeService.send_challenge

**Type:** Security Review
**Repository:** CertGames-Core
**File:** backend/api/domains/social/services/challenge_ops.py
**Language:** python
**Lines:** 30-141
**Complexity:** 9.0

---

## Source Code

```python
def send_challenge(
        challenger_id: str | ObjectId,
        challenged_id: str | ObjectId,
        test_category: str,
        test_id: int | None,
        question_count: int,
        mode: str
    ) -> Challenge:
        """
        Create a new challenge
        If test_id is None, randomly select a test from the category
        Validates test exists in database before creating challenge
        """
        challenger_id = ObjectId(challenger_id) if isinstance(
            challenger_id,
            str
        ) else challenger_id
        challenged_id = ObjectId(challenged_id) if isinstance(
            challenged_id,
            str
        ) else challenged_id

        if test_id is None:
            available_tests = list(
                Test.objects(category = test_category).only('testId')
            )

            if not available_tests:
                raise NotFoundError(
                    "Test",
                    f"No tests found for category '{test_category}'"
                )

            random_test = random.choice(available_tests)
            test_id = random_test.testId
        else:
            test = Test.objects(
                testId = test_id,
                category = test_category
            ).first()

            if not test:
                raise NotFoundError(
                    "Test",
                    f"Test {test_id} not found in category '{test_category}'"
                )

        existing_challenge = Challenge.objects(
            testCategory = test_category,
            testId = test_id,
            status__in = [
                ChallengeStatus.PENDING.value,
                ChallengeStatus.ACCEPTED.value,
                ChallengeStatus.IN_PROGRESS.value
            ]
        ).filter(
            __raw__ = {
                "$or": [
                    {
                        "challengerUserId": challenger_id,
                        "challengedUserId": challenged_id
                    },
                    {
                        "challengerUserId": challenged_id,
                        "challengedUserId": challenger_id
                    }
                ]
            }
        ).first()

        if existing_challenge:
            raise BusinessRuleError(
                f"You already have an active challenge for {test_category} Test #{test_id} with this user. Complete or cancel it first.",
                error_code = "DUPLICATE_CHALLENGE"
            )

        challenge = Challenge(
            challengerUserId = challenger_id,
            challengedUserId = challenged_id,
            testCategory = test_category,
            testId = test_id,
            questionCount = question_count,
            mode = mode,
            status = ChallengeStatus.PENDING.value,
            createdAt = datetime.now(UTC)
        )
        challenge.save()

        challenger = User.objects(
            id = challenger_id
        ).only("username",
               "level",
               "c
```

---

## Security Review

### Security Review

#### Vulnerabilities Found:

1. **Input Validation Gaps** (Line 8, Line 9, Line 15): The function does not validate the `test_category`, `test_id`, and `mode` parameters for potential injection or malformed input.
   - **Severity**: Medium
   - **Attack Vector**: Malicious users could exploit these inputs to inject SQL commands or manipulate data.

2. **Hardcoded Secrets** (Line 41): The function uses a hardcoded reference to the `ChallengeStatus` enum values and `datetime.now(UTC)`.
   - **Severity**: Low
   - **Recommendation**: Use constants or configuration files for such values instead of hardcoding them.

3. **Error Handling Leaks Information** (Line 29, Line 40): The error messages provide details about the database structure.
   - **Severity**: Medium
   - **Attack Vector**: An attacker could use these error messages to infer schema information.
   - **Recommendation**: Use generic error messages for all exceptions.

#### Recommended Fixes:

1. Validate and sanitize `test_category`, `test_id`, and `mode` inputs before using them in queries or operations.
2. Replace hardcoded values with constants or configuration settings.
3. Implement more robust error handling to avoid leaking sensitive information.

#### Overall Security Posture:

The code has a moderate security posture, with some critical areas that could be exploited if not properly secured. Addressing the input validation and error handling issues will significantly improve the overall security of this function.

---

*Generated by CodeWorm on 2026-02-19 17:32*
