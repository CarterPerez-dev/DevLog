# InterestScorer._calculate_pattern_bonus

**Type:** Security Review
**Repository:** CodeWorm
**File:** codeworm/analysis/scoring.py
**Language:** python
**Lines:** 208-240
**Complexity:** 11.0

---

## Source Code

```python
def _calculate_pattern_bonus(
        self,
        decorators: list[str] | None,
        is_async: bool,
        source: str,
    ) -> float:
        """
        Calculate bonus points for interesting code patterns
        """
        bonus = 0.0

        if is_async:
            bonus += self.PATTERN_BONUSES["async"]

        if decorators:
            bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]

            decorator_text = " ".join(decorators).lower()
            if "property" in decorator_text:
                bonus += self.PATTERN_BONUSES["property"]
            if "classmethod" in decorator_text or "staticmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["class_method"]
            if "abstractmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["abstract"]
            if "dataclass" in decorator_text:
                bonus += self.PATTERN_BONUSES["dataclass"]

        if "yield" in source:
            bonus += self.PATTERN_BONUSES["generator"]
        if "__enter__" in source or "__exit__" in source:
            bonus += self.PATTERN_BONUSES["context_manager"]

        return bonus
```

---

## Security Review

### Security Review for `InterestScorer._calculate_pattern_bonus`

#### 1. Vulnerabilities and Severity

- **Info: Input Validation Gaps**
  - The function processes the `source` string directly, which could be a potential vector for injection if `source` is derived from untrusted sources.

#### 2. Attack Vectors
- An attacker could inject malicious code patterns into the `source` parameter to manipulate bonus points unfairly.

#### 3. Recommended Fixes

```python
def _calculate_pattern_bonus(
        self,
        decorators: list[str] | None,
        is_async: bool,
        source: str,
) -> float:
    """
    Calculate bonus points for interesting code patterns
    """
    bonus = 0.0

    if is_async:
        bonus += self.PATTERN_BONUSES["async"]

    if decorators:
        decorator_text = " ".join(decorators).lower()
        # Validate and sanitize input before processing
        if all(d in VALID_DECORATORS for d in decorators):
            bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]
            if "property" in decorator_text:
                bonus += self.PATTERN_BONUSES["property"]
            if "classmethod" in decorator_text or "staticmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["class_method"]
            if "abstractmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["abstract"]
            if "dataclass" in decorator_text:
                bonus += self.PATTERN_BONUSES["dataclass"]

    # Validate and sanitize source before processing
    if all(p not in source for p in MALICIOUS_PATTERNS):
        if "yield" in source:
            bonus += self.PATTERN_BONUSES["generator"]
        if "__enter__" in source or "__exit__" in source:
            bonus += self.PATTERN_BONUSES["context_manager"]

    return bonus

# Define valid decorators and malicious patterns
VALID_DECORATORS = {"property", "classmethod", "staticmethod", "abstractmethod", "dataclass"}
MALICIOUS_PATTERNS = {"async", "yield", "__enter__", "__exit__"}
```

#### 4. Overall Security Posture
The overall security posture can be improved by validating and sanitizing inputs to prevent injection attacks. This ensures that the function behaves as expected even when processing potentially malicious input.

---

*Generated by CodeWorm on 2026-02-21 16:12*
