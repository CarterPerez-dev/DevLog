# get_threats

**Type:** Security Review
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/services/threat_service.py
**Language:** python
**Lines:** 51-99
**Complexity:** 6.0

---

## Source Code

```python
async def get_threats(
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0,
    severity: str | None = None,
    source_ip: str | None = None,
    since: datetime | None = None,
    until: datetime | None = None,
) -> ThreatListResponse:
    """
    Query threat events with optional filters, returning a paginated response.
    """
    query = select(ThreatEvent)
    count_query = select(func.count()).select_from(ThreatEvent)

    if severity:
        query = query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
        count_query = count_query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
    if source_ip:
        query = query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]
        count_query = count_query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]
    if since:
        query = query.where(ThreatEvent.created_at
                            >= since)  # type: ignore[arg-type]
        count_query = count_query.where(ThreatEvent.created_at
                                        >= since)  # type: ignore[arg-type]
    if until:
        query = query.where(ThreatEvent.created_at
                            <= until)  # type: ignore[arg-type]
        count_query = count_query.where(ThreatEvent.created_at
                                        <= until)  # type: ignore[arg-type]

    query = query.order_by(
        ThreatEvent.created_at.desc())  # type: ignore[attr-defined]
    query = query.offset(offset).limit(limit)

    total = (await session.execute(count_query)).scalar_one()
    rows = (await session.execute(query)).scalars().all()

    return ThreatListResponse(
        total=total,
        limit=limit,
        offset=offset,
        items=[_to_response(row) for row in rows],
    )
```

---

## Security Review

### Security Review for `get_threats` Function

#### Vulnerabilities Found:

1. **SQL Injection** - **Severity: Info**
   - The code uses SQLAlchemy's ORM, which is safe from SQL injection as long as the input parameters are properly validated and sanitized.
   
2. **Input Validation Gaps** - **Severity: Low**
   - The function accepts `datetime` objects directly without validation, which could lead to incorrect filtering if invalid dates are provided.

3. **Overall Security Posture**:
   - The code is generally secure but can benefit from additional input validation and error handling improvements.

#### Attack Vectors:

- Malicious users might provide invalid or unexpected date values, leading to incorrect query results.
  
#### Recommended Fixes:

1. **Input Validation**:
   ```python
   if since and not isinstance(since, datetime):
       raise ValueError("since must be a valid datetime object")
   if until and not isinstance(until, datetime):
       raise ValueError("until must be a valid datetime object")
   ```

2. **Error Handling**:
   - Add try-except blocks to handle potential database errors gracefully.
     ```python
     try:
         total = (await session.execute(count_query)).scalar_one()
         rows = (await session.execute(query)).scalars().all()
     except Exception as e:
         raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
     ```

3. **Logging**:
   - Log any unexpected errors to help with debugging.
     ```python
     logger.error(f"Error executing query: {e}")
     ```

By addressing these points, the function's security posture can be significantly improved.

---

*Generated by CodeWorm on 2026-02-28 11:57*
