# authenticate_websocket

**Type:** Security Review
**Repository:** vuemantics
**File:** backend/auth/dependencies.py
**Language:** python
**Lines:** 41-125
**Complexity:** 13.0

---

## Source Code

```python
async def authenticate_websocket(websocket: WebSocket) -> str | None:
    """
    Authenticate WebSocket connection via first message pattern

    Returns:
        User ID if authentication successful, None otherwise
    """
    origin = websocket.headers.get("origin", "")
    if origin and origin not in config.settings.cors_origins:
        logger.warning(f"WebSocket from unauthorized origin: {origin}")
        return None

    await websocket.accept()

    try:
        auth_data = await asyncio.wait_for(
            websocket.receive_json(),
            timeout = config.WEBSOCKET_AUTH_TIMEOUT
        )
    except TimeoutError:
        await websocket.send_json(
            AuthError(message = "Authentication timeout").model_dump()
        )
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_AUTH_TIMEOUT,
            reason = "Authentication timeout"
        )
        return None
    except WebSocketDisconnect:
        logger.debug(
            "WebSocket disconnected before auth (likely React StrictMode)"
        )
        return None
    except Exception as e:
        logger.error(f"Error receiving auth message: {e}")
        with contextlib.suppress(RuntimeError):
            await websocket.close(
                code = config.WEBSOCKET_CLOSE_INVALID_MESSAGE,
                reason = "Invalid message format"
            )
        return None

    if auth_data.get("type") != "auth" or not auth_data.get("token"):
        await websocket.send_json(
            AuthError(message = "Authentication required").model_dump()
        )
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_AUTH_REQUIRED,
            reason = "Authentication required"
        )
        return None

    try:
        payload = decode_token(
            auth_data["token"],
            expected_type = TokenType.ACCESS
        )

        user_id_raw = payload.get("sub")
        if not user_id_raw:
            raise AuthenticationError("Missing user ID in token")

        user_id: str = str(user_id_raw)
        user = await User.find_by_id(UUID(user_id))
        if not user or not user.is_active:
            raise AuthenticationError("User not found or inactive")

        token_version = payload.get("token_version", 0)
        if token_version != user.token_version:
            raise AuthenticationError("Token has been invalidated")

        await websocket.send_json(
            AuthSuccess(user_id = user_id).model_dump()
        )

        return user_id

    except AuthenticationError as e:
        logger.warning(f"WebSocket auth failed: {e}")
        await websocket.send_json(AuthError(message = str(e)).model_dump())
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_INVALID_TOKEN,
            reason = "Invalid token"
        )
        return None
```

---

## Security Review

### Security Review for `authenticate_websocket`

**Vulnerabilities:**

1. **Info - Input Validation Gaps:** The function does not validate the structure or content of the `auth_data` JSON, which could lead to unexpected behavior if the data is malformed.
   - **Fix:** Add explicit validation using Pydantic models or a library like `jsonschema`.

2. **Low - Hardcoded Secrets or Credentials:** No hardcoded secrets are found in the snippet provided.

3. **Info - Error Handling Leaks Information:** The error message "Authentication required" and "Invalid token" could provide clues about the state of the system.
   - **Fix:** Use generic error messages that do not reveal sensitive information.

4. **Info - Insecure Deserialization:** The `decode_token` function is called with user-provided data, which could be a risk if the token format is not properly validated.
   - **Fix:** Ensure the token format and validation logic are robust to prevent deserialization attacks.

**Attack Vectors:**

- Malformed JSON or unexpected token formats could lead to errors that reveal system state.
- Weak error handling could provide attackers with clues about authentication failures.

**Recommended Fixes:**

1. Implement detailed input validation for `auth_data`.
2. Use generic error messages in response to exceptions.
3. Ensure the `decode_token` function is secure and robust against malformed inputs.

**Overall Security Posture:**
The code shows good practices such as checking WebSocket origins and handling timeouts, but could benefit from more rigorous input validation and better error handling. Addressing these issues will enhance the overall security posture of the application.

---

*Generated by CodeWorm on 2026-02-21 13:42*
