# InsightsRepository.aggregate_by_length_range

**Type:** Security Review
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/analytics/facets/insights/repository.py
**Language:** python
**Lines:** 303-347
**Complexity:** 6.0

---

## Source Code

```python
async def aggregate_by_length_range(
        cls, session: AsyncSession
    ) -> dict[str, dict]:
        """Aggregate performance by video length ranges"""
        videos = await cls.get_all_videos(session)

        range_stats = defaultdict(lambda: {
            "videos": [],
            "total_views": 0,
            "total_engagement": 0,
            "total_watch_percentage": 0,
        })

        for video in videos:
            seconds = cls.convert_length_to_seconds(video.length)
            range_label = cls.get_length_range_label(seconds)
            engagement_rate = cls.calculate_engagement_rate(video)

            range_stats[range_label]["videos"].append(video)
            range_stats[range_label]["total_views"] += video.views
            range_stats[range_label]["total_engagement"] += engagement_rate
            range_stats[range_label]["total_watch_percentage"] += video.watched_full_video_percentage

        # Calculate averages and add min/max seconds
        result = {}
        for range_label, stats in range_stats.items():
            count = len(stats["videos"])
            # Extract min/max from range label (e.g., "1:00-1:30" -> 60, 90)
            if range_label == "3:00+":
                min_sec, max_sec = 180, 999
            else:
                parts = range_label.split("-")
                min_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[0].split(":"))))
                max_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[1].split(":"))))

            result[range_label] = {
                "min_seconds": min_sec,
                "max_seconds": max_sec,
                "video_count": count,
                "avg_views": stats["total_views"] / count,
                "avg_engagement_rate": stats["total_engagement"] / count,
                "avg_watch_percentage": stats["total_watch_percentage"] / count,
            }

        return result
```

---

## Security Review

### Security Review

**Vulnerabilities Found:**

1. **Info - Input Validation Gaps**: The code does not validate the input `video.length` or `video.views`. Ensure that these inputs are properly validated to prevent potential issues.
2. **Info - Error Handling**: There is no explicit error handling for database operations, which could leak information if an exception occurs.

**Attack Vectors:**

- If `video.length` or `video.views` contain unexpected values, it might lead to incorrect aggregation results.
- Lack of error handling can expose internal details about the application's operation in case of exceptions.

**Recommended Fixes:**

1. **Input Validation**: Add validation checks for `video.length` and `video.views`:
   ```python
   if not video.length or not video.views:
       raise ValueError("Invalid input")
   ```

2. **Error Handling**: Implement proper error handling around database operations using a context manager:
   ```python
   try:
       videos = await cls.get_all_videos(session)
   except Exception as e:
       logger.error(f"Failed to fetch videos: {e}")
       return {}
   ```

**Overall Security Posture:**

The code is free of critical and high-severity issues. However, adding input validation and error handling will improve the overall security posture by preventing unexpected behavior and reducing potential information leaks.

---

*Generated by CodeWorm on 2026-02-21 09:28*
