# FetchDockerData

**Type:** Security Review
**Repository:** Yoshi-Audit
**File:** internal/ui/dockertab/dockertab.go
**Language:** go
**Lines:** 84-182
**Complexity:** 17.0

---

## Source Code

```go
func FetchDockerData(cfg config.Config) tea.Msg {
	cli, err := docker.NewClient()
	if err != nil {
		return DockerDataMsg{Err: err}
	}
	defer cli.Close()

	images, containers, volumes, cache, err := cli.GetDiskUsage()
	if err != nil {
		return DockerDataMsg{Err: err}
	}

	pe := docker.NewProtectionEngine(cfg.ProtectionPatterns)

	var imgItems []DockerItem
	for _, img := range images {
		cat := docker.CategorizeImage(img, cfg.ProtectionPatterns)
		name := img.Repository
		if img.Tag != "<none>" {
			name = img.Repository + ":" + img.Tag
		}
		extra := ""
		if img.Dangling {
			extra = "dangling"
		}
		if img.Containers > 0 {
			extra = fmt.Sprintf("%d containers", img.Containers)
		}
		state := Unselected
		fullName := img.Repository
		if img.Tag != "<none>" {
			fullName = img.Repository + ":" + img.Tag
		}
		if pe.IsProtected(fullName) || pe.IsProtected(img.Repository) {
			state = Protected
		}
		imgItems = append(imgItems, DockerItem{
			ID:       img.ID,
			Name:     name,
			Size:     img.Size,
			Age:      formatAge(img.Created),
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	var ctrItems []DockerItem
	for _, ctr := range containers {
		cat := docker.CategorizeContainer(ctr, cfg.ProtectionPatterns)
		state := Unselected
		if pe.IsProtected(ctr.Name) || pe.IsProtected(ctr.Image) {
			state = Protected
		}
		extra := ctr.State
		if ctr.Running {
			extra = "running"
		}
		ctrItems = append(ctrItems, DockerItem{
			ID:       ctr.ID,
			Name:     ctr.Name,
			Size:     ctr.Size,
			Age:      formatAge(ctr.Created),
			Status:   ctr.Status,
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	var volItems []DockerItem
	for _, vol := range volumes {
		cat := docker.CategorizeVolume(vol, cfg.ProtectionPatterns)
		state := Unselected
		if pe.IsProtected(vol.Name) {
			state = Protected
		}
		extra := ""
		if vol.Links > 0 {
			extra = fmt.Sprintf("%d links", vol.Links)
		}
		volItems = append(volItems, DockerItem{
			ID:       vol.Name,
			Name:     vol.Name,
			Size:     vol.Size,
			Age:      formatAge(vol.Created),
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	return DockerDataMsg{
		Images:     imgItems,
		Containers: ctrItems,
		Volumes:    volItems,
		BuildCache: cache.TotalSize,
	}
}
```

---

## Security Review

### Security Review for `FetchDockerData` Function

#### Vulnerabilities and Recommendations:

1. **Info - No Injection or Deserialization Issues:**
   The code does not appear to handle user input directly, so SQL, command, XSS, or insecure deserialization issues are unlikely.

2. **Info - Input Validation Gaps:**
   There is no explicit validation of the `cfg.ProtectionPatterns` input. Ensure it is properly validated and sanitized if external sources provide this configuration.

3. **Info - Error Handling:**
   The error handling is basic but does not leak sensitive information or provide detailed error messages that could be exploited.

4. **Info - Race Conditions and TOCTOU Bugs:**
   There are no obvious race conditions or TOCTOU bugs in the code snippet provided.

5. **Info - Hardcoded Secrets or Credentials:**
   No hardcoded secrets or credentials appear to be present in this function.

6. **Medium - Authentication and Authorization Issues:**
   The `cfg.ProtectionPatterns` should be securely managed, as it could contain sensitive information. Ensure proper authorization checks are in place when accessing this configuration.

#### Attack Vectors:
- If `cfg.ProtectionPatterns` is misconfigured or contains sensitive data, an attacker could exploit it.
- Lack of input validation on external inputs (e.g., `cfg.ProtectionPatterns`) could lead to unexpected behavior.

#### Recommended Fixes:

1. **Validate and Sanitize `cfg.ProtectionPatterns`:**
   ```go
   if err := validateProtectionPatterns(cfg.ProtectionPatterns); err != nil {
       return DockerDataMsg{Err: err}
   }
   ```

2. **Secure Configuration Management:**
   Ensure that sensitive configurations are stored securely, possibly using environment variables or a secure vault.

3. **Enhance Error Handling:**
   ```go
   if err := cli.GetDiskUsage(); err != nil {
       return DockerDataMsg{Err: fmt.Errorf("failed to get disk usage: %w", err)}
   }
   ```

Overall, the security posture is good but could be enhanced by addressing potential misconfigurations and ensuring robust input validation.

---

*Generated by CodeWorm on 2026-03-01 20:49*
