# get_languages

**Type:** Security Review
**Repository:** CodeWorm
**File:** dashboard/backend/api.py
**Language:** python
**Lines:** 240-273
**Complexity:** 4.0

---

## Source Code

```python
async def get_languages() -> list[LanguageBreakdown]:
    db = _get_db_path()
    if not db.exists():
        return []

    with _get_conn() as conn:
        total = conn.execute("SELECT COUNT(*) FROM documented_snippets"
                             ).fetchone()[0]

        if total == 0:
            return []

        rows = conn.execute(
            "SELECT "
            "CASE "
            "  WHEN source_file LIKE '%.py' THEN 'python' "
            "  WHEN source_file LIKE '%.ts' THEN 'typescript' "
            "  WHEN source_file LIKE '%.tsx' THEN 'tsx' "
            "  WHEN source_file LIKE '%.js' THEN 'javascript' "
            "  WHEN source_file LIKE '%.go' THEN 'go' "
            "  WHEN source_file LIKE '%.rs' THEN 'rust' "
            "  ELSE 'other' "
            "END AS lang, COUNT(*) AS cnt "
            "FROM documented_snippets GROUP BY lang ORDER BY cnt DESC"
        ).fetchall()

    return [
        LanguageBreakdown(
            language = row["lang"],
            count = row["cnt"],
            percentage = round(row["cnt"] / total * 100,
                               1),
        ) for row in rows
    ]
```

---

## Security Review

### Security Review for `get_languages` Function

#### Vulnerabilities Found:

1. **SQL Injection** - **Severity: Low**
   - The SQL query uses string concatenation to determine the language, which could be exploited with malicious input.
   - **Line 9**: `WHEN source_file LIKE '%.py' THEN 'python'`.

2. **Input Validation Gaps** - **Severity: Medium**
   - The function does not validate or sanitize user inputs before using them in SQL queries.

3. **Hardcoded Secrets or Credentials** - **Severity: Info**
   - No hardcoded secrets are found, but the `_get_db_path()` and `_get_conn()` functions should be reviewed for potential issues.

4. **Error Handling** - **Severity: Low**
   - The function does not handle database connection errors or query exceptions, which could leak information about the application's internal state.

#### Attack Vectors:

- An attacker could inject malicious SQL code through file names to alter query behavior.
- Improper error handling might reveal sensitive information if a database error occurs.

#### Recommended Fixes:

1. **Use Parameterized Queries** - Replace string concatenation with parameterized queries to prevent SQL injection.
   ```python
   rows = conn.execute(
       "SELECT "
       "CASE "
       "  WHEN source_file LIKE ? THEN 'python' "
       "  WHEN source_file LIKE ? THEN 'typescript' "
       "  WHEN source_file LIKE ? THEN 'tsx' "
       "  WHEN source_file LIKE ? THEN 'javascript' "
       "  WHEN source_file LIKE ? THEN 'go' "
       "  WHEN source_file LIKE ? THEN 'rust' "
       "  ELSE 'other' "
       "END AS lang, COUNT(*) AS cnt "
       "FROM documented_snippets GROUP BY lang ORDER BY cnt DESC",
       ('%.py', '%.ts', '%.tsx', '%.js', '%.go', '%.rs')
   ).fetchall()
   ```

2. **Implement Proper Error Handling** - Use try-except blocks to catch and handle database errors gracefully.
   ```python
   try:
       # Database operations
   except Exception as e:
       logging.error(f"Database error: {e}")
       return []
   ```

3. **Review `_get_db_path()` and `_get_conn()`** - Ensure these functions are secure and do not expose sensitive information.

#### Overall Security Posture:

The current code has some security gaps, particularly with SQL injection and input validation. Addressing these issues will significantly improve the overall security posture of the application.

---

*Generated by CodeWorm on 2026-03-01 17:35*
