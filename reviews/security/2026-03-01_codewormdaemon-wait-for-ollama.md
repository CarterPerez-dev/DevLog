# CodeWormDaemon._wait_for_ollama

**Type:** Security Review
**Repository:** CodeWorm
**File:** codeworm/daemon.py
**Language:** python
**Lines:** 201-241
**Complexity:** 8.0

---

## Source Code

```python
async def _wait_for_ollama(self) -> bool:
        """
        Wait for Ollama to become available with exponential backoff
        Returns True when available, False if daemon is shutting down
        """
        client = await self._init_llm()

        while self.running:
            if await client.health_check():
                if self.stats.consecutive_ollama_failures > 0:
                    self.logger.info(
                        "ollama_recovered",
                        after_failures = self.stats.consecutive_ollama_failures,
                    )
                self.stats.record_ollama_recovery()
                return True

            wait_seconds = self.stats.get_ollama_wait_seconds()
            self.stats.record_ollama_failure()

            self.logger.warning(
                "ollama_unavailable_waiting",
                url = self.settings.ollama.base_url,
                retry_in_seconds = wait_seconds,
                consecutive_failures = self.stats.consecutive_ollama_failures,
            )

            if (self.notifier and self.stats.consecutive_ollama_failures
                    == self.settings.telegram.alert_after_failures):
                await self.notifier.send_alert(
                    f"Ollama unavailable — {self.stats.consecutive_ollama_failures} consecutive failures",
                    details =
                    f"Retrying every {wait_seconds}s. Daemon is paused until Ollama recovers.",
                )

            for _ in range(wait_seconds):
                if not self.running:
                    return False
                await asyncio.sleep(1)

        return False
```

---

## Security Review

### Security Review for `CodeWormDaemon._wait_for_ollama`

#### Vulnerabilities and Severity

1. **Info:**
   - **Severity:** Info
   - **Description:** The function does not contain direct injection vulnerabilities, but it relies on external settings (`self.settings.telegram.alert_after_failures`), which should be validated.
   
2. **Info:**
   - **Severity:** Info
   - **Description:** There are no hardcoded secrets or credentials visible in the snippet.

3. **Info:**
   - **Severity:** Info
   - **Description:** The function does not involve deserialization, so this is not a concern here.

4. **Info:**
   - **Severity:** Info
   - **Description:** Error handling does not leak sensitive information directly, but logging should be cautious to avoid exposing internal states.

#### Attack Vectors

- An attacker could manipulate `self.settings.telegram.alert_after_failures` to trigger unnecessary alerts or cause the daemon to pause unnecessarily.
  
#### Recommended Fixes

1. Ensure that `self.settings.telegram.alert_after_failures` is validated and sanitized before use.
2. Use structured logging with controlled output to avoid exposing sensitive information.

```python
if (self.notifier and self.stats.consecutive_ollama_failures >= self.settings.telegram.alert_after_failures):
    await self.notifier.send_alert(
        f"Ollama unavailable — {self.stats.consecutive_ollama_failures} consecutive failures",
        details=f"Retrying every {wait_seconds}s. Daemon is paused until Ollama recovers.",
    )
```

#### Overall Security Posture

The function has a good overall security posture, with no critical or high-severity issues identified. However, it's important to validate and sanitize external settings to prevent unintended behavior.

---

*Generated by CodeWorm on 2026-03-01 16:49*
