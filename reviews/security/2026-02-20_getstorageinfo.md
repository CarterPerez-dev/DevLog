# GetStorageInfo

**Type:** Security Review
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/docker/system.go
**Language:** go
**Lines:** 53-146
**Complexity:** 13.0

---

## Source Code

```go
func (c *Client) GetStorageInfo(
	ctx context.Context,
) (*model.StorageInfo, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	usage, err := c.cli.DiskUsage(ctx, types.DiskUsageOptions{})
	if err != nil {
		return nil, fmt.Errorf("getting disk usage: %w", err)
	}

	info := &model.StorageInfo{
		Details: model.StorageDetails{
			Images:     make([]model.ImageInfo, 0),
			Volumes:    make([]model.VolumeInfo, 0),
			BuildCache: make([]model.CacheInfo, 0),
		},
	}

	for _, img := range usage.Images {
		info.ImagesSize += uint64(img.Size)
		repoTag := "<none>:<none>"
		repo := "<none>"
		tag := "<none>"
		if len(img.RepoTags) > 0 {
			repoTag = img.RepoTags[0]
			parts := strings.Split(repoTag, ":")
			if len(parts) >= 1 {
				repo = parts[0]
			}
			if len(parts) >= 2 {
				tag = parts[1]
			}
		}

		info.Details.Images = append(info.Details.Images, model.ImageInfo{
			ID:         img.ID,
			Repository: repo,
			Tag:        tag,
			Size:       uint64(img.Size),
			InUse:      img.Containers > 0,
		})
	}

	for _, ctr := range usage.Containers {
		info.ContainersSize += uint64(ctr.SizeRw)
	}

	for _, vol := range usage.Volumes {
		size := int64(0)
		if vol.UsageData != nil {
			size = vol.UsageData.Size
		}
		info.VolumesSize += uint64(size)

		inUse := false
		if vol.UsageData != nil {
			inUse = vol.UsageData.RefCount > 0
		}

		info.Details.Volumes = append(info.Details.Volumes, model.VolumeInfo{
			Name:   vol.Name,
			Driver: vol.Driver,
			Size:   uint64(size),
			InUse:  inUse,
		})
	}

	for _, cache := range usage.BuildCache {
		info.BuildCacheSize += uint64(cache.Size)

		info.Details.BuildCache = append(
			info.Details.BuildCache,
			model.CacheInfo{
				ID:    cache.ID,
				Type:  cache.Type,
				Size:  uint64(cache.Size),
				InUse: cache.InUse,
			},
		)
	}

	info.TotalSize = info.ImagesSize + info.ContainersSize + info.VolumesSize + info.BuildCacheSize

	unusedImages := uint64(0)
	for _, img := range usage.Images {
		if img.Containers == 0 {
			unusedImages += uint64(img.Size)
		}
	}
	info.Reclaimable = unusedImages + info.BuildCacheSize

	return info, nil
}
```

---

## Security Review

### Security Review for `GetStorageInfo` Function

#### Vulnerabilities Found:

1. **Input Validation Gaps** (Medium):
   - The code iterates over `usage.Images`, `usage.Containers`, and `usage.Volumes` without validating the input structure or content, which could lead to unexpected behavior if the data is manipulated.

2. **Error Handling** (Low):
   - Error handling is present but could be more informative. Consider logging errors for better debugging and security auditing.

3. **Overall Security Posture**:
   - The function appears to handle internal data structures from a Docker client, which are likely validated by the underlying library. However, input validation gaps can still introduce issues if misused or manipulated.

#### Recommended Fixes:

1. **Input Validation Gaps (Line 12-36)**
   - Ensure that `img`, `ctr`, and `vol` fields are fully validated before processing.
   ```go
   for _, img := range usage.Images {
       if img == nil || img.Size <= 0 {
           continue // or handle invalid data appropriately
       }
       // Process img
   }
   ```

2. **Enhance Error Logging (Line 15)**
   - Improve error logging to capture more details about the failure.
   ```go
   return nil, fmt.Errorf("getting disk usage: %w", err).Error()
   ```

3. **Overall Security Posture**:
   - Regularly review and update dependencies to ensure they are free from known vulnerabilities.
   - Implement comprehensive input validation for all data sources.

By addressing these issues, the function's security posture can be significantly improved.

---

*Generated by CodeWorm on 2026-02-20 18:30*
