# checkResourceLimits

**Type:** Security Review
**Repository:** docksec
**File:** internal/analyzer/compose.go
**Language:** go
**Lines:** 332-399
**Complexity:** 10.0

---

## Source Code

```go
func (a *ComposeAnalyzer) checkResourceLimits(
	target finding.Target,
	serviceName string,
	node *yaml.Node,
) finding.Collection {
	var findings finding.Collection

	deployNode := findNode(node, "deploy")
	var resourcesNode *yaml.Node
	if deployNode != nil {
		resourcesNode = findNode(deployNode, "resources")
	}

	memLimitNode := findNode(node, "mem_limit")
	cpuLimitNode := findNode(node, "cpus")
	pidsLimitNode := findNode(node, "pids_limit")

	hasMemLimit := memLimitNode != nil
	hasCpuLimit := cpuLimitNode != nil
	hasPidsLimit := pidsLimitNode != nil

	if resourcesNode != nil {
		limitsNode := findNode(resourcesNode, "limits")
		if limitsNode != nil {
			if findNode(limitsNode, "memory") != nil {
				hasMemLimit = true
			}
			if findNode(limitsNode, "cpus") != nil {
				hasCpuLimit = true
			}
			if findNode(limitsNode, "pids") != nil {
				hasPidsLimit = true
			}
		}
	}

	if !hasMemLimit {
		loc := &finding.Location{Path: a.path, Line: node.Line}
		f := finding.New("CIS-5.10", "Service '"+serviceName+"' has no memory limit", finding.SeverityMedium, target).
			WithDescription("Without memory limits, a container can exhaust all available host memory.").
			WithCategory(string(CategoryCompose)).
			WithLocation(loc).
			WithRemediation("Set mem_limit or deploy.resources.limits.memory for the service.")
		findings = append(findings, f)
	}

	if !hasCpuLimit {
		loc := &finding.Location{Path: a.path, Line: node.Line}
		f := finding.New("CIS-5.11", "Service '"+serviceName+"' has no CPU limit", finding.SeverityMedium, target).
			WithDescription("Without CPU limits, a container can consume all available CPU resources.").
			WithCategory(string(CategoryCompose)).
			WithLocation(loc).
			WithRemediation("Set cpus or deploy.resources.limits.cpus for the service.")
		findings = append(findings, f)
	}

	if !hasPidsLimit {
		loc := &finding.Location{Path: a.path, Line: node.Line}
		f := finding.New("CIS-5.28", "Service '"+serviceName+"' has no PIDs limit", finding.SeverityMedium, target).
			WithDescription("Without PIDs limits, a container can fork-bomb and exhaust process table.").
			WithCategory(string(CategoryCompose)).
			WithLocation(loc).
			WithRemediation("Set pids_limit or deploy.resources.limits.pids for the service.")
		findings = append(findings, f)
	}

	return findings
}
```

---

## Security Review

### Security Review for `checkResourceLimits` Function

#### Vulnerabilities Found:

1. **Input Validation Gaps** (Line 7-16, Severity: Medium):
   - The function relies on the structure of YAML nodes without validating their content or existence thoroughly.
   - Potential for misconfiguration if the expected node paths are not present.

2. **Error Handling** (Lines 30-45, Severity: Low):
   - No explicit error handling is provided for `findNode` calls, which could lead to unexpected behavior if nodes are missing.

#### Attack Vectors:

1. **Misconfigured YAML Files**: An attacker could intentionally misconfigure the YAML file to bypass resource limit checks.
2. **Unexpected Node Paths**: If a node path is not found, it might cause the function to fail or produce incorrect findings.

#### Recommended Fixes:

1. **Enhance Input Validation**:
   - Implement more robust validation for `findNode` calls to ensure nodes exist and are correctly structured.
   ```go
   if deployNode == nil {
       return findings // Or log an error
   }
   ```

2. **Add Error Handling**:
   - Wrap the `findNode` calls in a try-catch block or use error checking to handle missing nodes gracefully.
   ```go
   limitNode, err := findNode(node, "limits")
   if err != nil {
       return findings // Or log an error
   }
   ```

3. **Document and Validate Paths**:
   - Ensure all expected paths are documented and validated within the function.

#### Overall Security Posture:

The current implementation is secure but could benefit from more rigorous validation and error handling to prevent misconfiguration issues. Addressing these gaps will enhance the robustness of the resource limit checks, ensuring better security posture.

---

*Generated by CodeWorm on 2026-02-21 15:01*
