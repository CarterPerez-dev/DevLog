# ScanMemoryLeaks

**Type:** Security Review
**Repository:** Yoshi-Audit
**File:** internal/audit/scanner.go
**Language:** go
**Lines:** 165-197
**Complexity:** 7.0

---

## Source Code

```go
func (s *Scanner) ScanMemoryLeaks(procs []system.ProcessInfo, history map[int][]uint64) []Finding {
	nameMap := make(map[int]string)
	for _, p := range procs {
		nameMap[p.PID] = p.Name
	}

	const threshold = 100 * 1024 * 1024

	var findings []Finding
	for pid, readings := range history {
		if len(readings) < 2 {
			continue
		}
		first := readings[0]
		last := readings[len(readings)-1]
		if last > first && (last-first) > threshold {
			grewMiB := (last - first) / (1024 * 1024)
			name := nameMap[pid]
			if name == "" {
				name = fmt.Sprintf("pid-%d", pid)
			}
			findings = append(findings, Finding{
				Type:     FindingMemoryLeak,
				Severity: SeverityWarn,
				PID:      pid,
				Name:     name,
				Message:  fmt.Sprintf("Process grew %d MiB in %d readings", grewMiB, len(readings)),
				Detail:   fmt.Sprintf("first: %d bytes, last: %d bytes", first, last),
			})
		}
	}
	return findings
}
```

---

## Security Review

### Security Review for `ScanMemoryLeaks` Function

#### Vulnerabilities and Severity:

1. **Info:**
   - The function does not contain any direct injection vulnerabilities, race conditions, or insecure deserialization issues.
   - There are no hardcoded secrets or credentials.

2. **Info:**
   - Error handling is minimal; the function assumes `procs`, `history`, and `nameMap` are valid. Ensure robust error handling for external inputs.

3. **Info:**
   - The function does not process user input directly, so XSS vulnerabilities are unlikely.

4. **Info:**
   - No race conditions or TOCTOU bugs are present as the function operates on static data structures.

5. **Info:**
   - Input validation is limited to checking `history` length and ensuring `nameMap[pid]` exists. Ensure all map accesses handle potential nil values gracefully.

#### Attack Vectors:

- If `procs`, `history`, or `nameMap` are manipulated, the function could produce unexpected results, but this is more about data integrity than security.
  
#### Recommended Fixes:

1. **Error Handling:**
   - Add checks for errors in map operations:
     ```go
     if name, ok := nameMap[pid]; !ok {
         findings = append(findings, Finding{
             Type:     FindingMemoryLeak,
             Severity: SeverityInfo,
             PID:      pid,
             Name:     fmt.Sprintf("pid-%d", pid),
             Message:  "Process name not found in map",
             Detail:   "",
         })
         continue
     }
     ```

2. **Logging and Monitoring:**
   - Implement logging for critical operations to monitor function behavior.

3. **Documentation:**
   - Document the expected types and formats of `procs` and `history` to prevent misuse.

#### Overall Security Posture:

The current implementation is secure but could benefit from enhanced error handling and documentation. Ensure that all external inputs are validated, and consider adding logging for critical operations to maintain a robust security posture.

---

*Generated by CodeWorm on 2026-03-01 22:16*
