# Update

**Type:** Security Review
**Repository:** Yoshi-Audit
**File:** internal/ui/dockertab/dockertab.go
**Language:** go
**Lines:** 184-284
**Complexity:** 33.0

---

## Source Code

```go
func (dt DockerTab) Update(msg tea.Msg) (DockerTab, tea.Cmd) {
	switch msg := msg.(type) {
	case DockerDataMsg:
		if msg.Err != nil {
			dt.err = msg.Err
			return dt, nil
		}
		dt.images = msg.Images
		dt.containers = msg.Containers
		dt.volumes = msg.Volumes
		dt.buildCache = msg.BuildCache
		dt.err = nil
	case DeleteResultMsg:
		if msg.Err != nil {
			dt.err = msg.Err
		}
		dt.confirming = false
		dt.confirmMsg = ""
		return dt, func() tea.Msg { return FetchDockerData(dt.config) }
	case tea.KeyMsg:
		if dt.confirming {
			switch msg.String() {
			case "y":
				return dt, dt.executeDelete()
			case "escape", "n":
				dt.confirming = false
				dt.confirmMsg = ""
			}
			return dt, nil
		}

		switch msg.String() {
		case "i":
			dt.subTab = SubTabImages
			dt.cursor = 0
		case "c":
			dt.subTab = SubTabContainers
			dt.cursor = 0
		case "v":
			dt.subTab = SubTabVolumes
			dt.cursor = 0
		case "n":
			dt.subTab = SubTabNetworks
			dt.cursor = 0
		case "up", "k":
			if dt.cursor > 0 {
				dt.cursor--
			}
		case "down", "j":
			items := dt.currentItems()
			if dt.cursor < len(items)-1 {
				dt.cursor++
			}
		case " ":
			items := dt.currentItems()
			if dt.cursor < len(items) && items[dt.cursor].State != Protected {
				if items[dt.cursor].State == Selected {
					items[dt.cursor].State = Unselected
				} else {
					items[dt.cursor].State = Selected
				}
				dt.setCurrentItems(items)
			}
		case "a":
			items := dt.currentItems()
			for idx := range items {
				if items[idx].State != Protected {
					items[idx].State = Selected
				}
			}
			dt.setCurrentItems(items)
		case "p":
			items := dt.currentItems()
			if dt.cursor < len(items) {
				if items[dt.cursor].State == Protected {
					items[dt.cursor].State = Unselected
					dt.protection.Unprotect(items[dt.cursor].Name)
				} else {
					items[dt.cursor].State = Protected
					dt.protection.Protect(items[dt.cursor].Name)
				}
				dt.setCurrentItems(items)
			}
		case "d":
			selected := dt.selectedItems()
			if len(selected) > 0 {
				dt.confirming = true
				dt.confirmMsg = dt.buildConfirmMsg(selected)
			}
		case "1":
			dt.applyPreset(0)
		case "2":
			dt.applyPreset(1)
		case "3":
			dt.applyPreset(2)
		case "4":
			dt.applyPreset(3)
		}
	}
	return dt, nil
}
```

---

## Security Review

### Security Review for `Update` Function

#### Vulnerabilities Found:

1. **Info - Input Validation Gaps:**
   - Lines 18-27, 36-50: Key messages are handled without proper validation or sanitization.
     - **Severity:** Info
     - **Attack Vector:** Malicious input could potentially cause unexpected behavior.

2. **Info - Error Handling:**
   - Line 9: Error handling for `DeleteResultMsg` is minimal, which might leak information about the error state.
     - **Severity:** Info
     - **Attack Vector:** Users may infer system state from error messages.

#### Recommended Fixes:

1. **Input Validation:**
   - Implement validation checks for key messages to ensure they are valid and expected inputs.
     ```go
     case tea.KeyMsg:
         if msg.String() == "y" || msg.String() == "escape" || msg.String() == "n" {
             // Handle keys
         }
     ```

2. **Enhanced Error Handling:**
   - Log errors instead of directly assigning them to `dt.err` to avoid information leakage.
     ```go
     case DeleteResultMsg:
         if msg.Err != nil {
             log.Error(msg.Err)
         }
     ```

#### Overall Security Posture:

The function is relatively secure but could benefit from more robust input validation and improved error handling. Ensuring that all inputs are validated and errors are handled discreetly can significantly enhance the security posture of this code.

---

*Generated by CodeWorm on 2026-03-01 20:19*
