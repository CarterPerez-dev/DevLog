# resolveUpdates

**Type:** Security Review
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/simple-vulnerability-scanner/internal/cli/update.go
**Language:** go
**Lines:** 404-504
**Complexity:** 12.0

---

## Source Code

```go
func resolveUpdates(
	deps []types.Dependency,
	versionMap map[string][]string,
	safe bool,
	includePrerelease bool,
	ignoreDeps []string,
) ([]types.UpdateResult, map[string]string) {
	var results []types.UpdateResult
	specs := make(map[string]string)

	ignoreSet := make(map[string]bool, len(ignoreDeps))
	for _, name := range ignoreDeps {
		ignoreSet[pypi.NormalizeName(name)] = true
	}

	for _, dep := range deps {
		if ignoreSet[pypi.NormalizeName(dep.Name)] {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "ignored in config",
			})
			continue
		}

		versions, ok := versionMap[dep.Name]
		if !ok {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "not found on PyPI",
			})
			continue
		}

		currentStr := pyproject.ExtractMinVersion(dep.Spec)
		if currentStr == "" {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "no version specifier",
			})
			continue
		}

		current, err := pypi.ParseVersion(currentStr)
		if err != nil {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "unparseable version",
			})
			continue
		}

		var latest pypi.Version
		if includePrerelease {
			latest, err = latestAny(versions)
		} else {
			latest, err = pypi.LatestStable(versions)
		}
		if err != nil {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  err.Error(),
			})
			continue
		}

		if latest.Compare(current) <= 0 {
			continue
		}

		change := pypi.ClassifyChange(current, latest)
		if safe && change == pypi.Major {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				OldVer:  current.String(),
				NewVer:  latest.String(),
				Change:  change.String(),
				Skipped: true,
				Reason:  "major bump (use --all to include)",
			})
			continue
		}

		newSpec := ">=" + latest.String()
		results = append(results, types.UpdateResult{
			Name:    dep.Name,
			OldVer:  current.String(),
			NewVer:  latest.String(),
			OldSpec: dep.Spec,
			NewSpec: newSpec,
			Change:  change.String(),
		})
		specs[dep.Name] = newSpec
	}

	return results, specs
}
```

---

## Security Review

### Security Review for `resolveUpdates` Function

#### Vulnerabilities Found:

1. **Input Validation Gaps** (Line 9-10, Line 15):
   - The function processes `ignoreDeps`, which is a slice of strings. However, there are no checks to validate the input format or ensure it does not contain malicious content.
   
2. **Error Handling** (Line 23, Line 46, Line 58):
   - Error handling could be improved. Currently, errors are logged with `Reason` but do not halt execution or provide clear error messages.

#### Attack Vectors:
- An attacker could inject invalid input into `ignoreDeps`, potentially leading to unexpected behavior.
- Improper error handling might expose sensitive information through error messages.

#### Recommended Fixes:

1. **Input Validation**:
   - Validate and sanitize the `ignoreDeps` slice to ensure it contains only valid package names.
     ```go
     for _, name := range ignoreDeps {
         if !isValidPackageName(name) {
             return nil, fmt.Errorf("invalid package name: %s", name)
         }
     }
     ```

2. **Enhanced Error Handling**:
   - Return specific errors and handle them appropriately to avoid leaking sensitive information.
     ```go
     if err != nil {
         results = append(results, types.UpdateResult{
             Name:    dep.Name,
             Skipped: true,
             Reason:  "Error parsing version: " + err.Error(),
         })
         continue
     }
     ```

#### Overall Security Posture:
The function is relatively secure but can be improved by validating inputs and handling errors more robustly. Ensure that all user-provided data is validated to prevent injection attacks, and handle errors gracefully without exposing sensitive information.

**Severity Ratings:**
- Input Validation Gaps: **Medium**
- Error Handling: **Low**

By addressing these issues, the overall security posture of the function can be significantly improved.

---

*Generated by CodeWorm on 2026-02-18 11:18*
