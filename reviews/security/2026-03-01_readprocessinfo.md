# readProcessInfo

**Type:** Security Review
**Repository:** Yoshi-Audit
**File:** internal/system/process.go
**Language:** go
**Lines:** 52-110
**Complexity:** 15.0

---

## Source Code

```go
func readProcessInfo(pid int) (ProcessInfo, error) {
	info := ProcessInfo{PID: pid}

	statusPath := fmt.Sprintf("/proc/%d/status", pid)
	f, err := os.Open(statusPath)
	if err != nil {
		return ProcessInfo{}, err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		parts := strings.SplitN(line, ":", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		val := strings.TrimSpace(parts[1])

		switch key {
		case "Name":
			info.Name = val
		case "State":
			fields := strings.Fields(val)
			if len(fields) > 0 {
				info.State = fields[0]
			}
		case "PPid":
			ppid, parseErr := strconv.Atoi(val)
			if parseErr == nil {
				info.PPID = ppid
			}
		case "VmRSS":
			valStr := strings.TrimSuffix(val, " kB")
			valStr = strings.TrimSpace(valStr)
			rss, parseErr := strconv.ParseUint(valStr, 10, 64)
			if parseErr == nil {
				info.RSS = rss * 1024
			}
		}
	}

	cmdlinePath := fmt.Sprintf("/proc/%d/cmdline", pid)
	data, err := os.ReadFile(cmdlinePath)
	if err == nil && len(data) > 0 {
		args := strings.Split(string(data), "\x00")
		var cleaned []string
		for _, a := range args {
			if a != "" {
				cleaned = append(cleaned, a)
			}
		}
		info.Cmdline = strings.Join(cleaned, " ")
	}

	return info, nil
}
```

---

## Security Review

### Security Review for `readProcessInfo` Function

#### Vulnerabilities Found:

1. **Information Disclosure** - **Severity: Low**
   - The function reads sensitive information from `/proc/<pid>/status` and `/proc/<pid>/cmdline`. While these paths are typically readable by processes with sufficient permissions, the code does not handle errors or edge cases that could lead to information disclosure.

2. **Input Validation Gaps** - **Severity: Medium**
   - The function uses `strconv.Atoi` and `strconv.ParseUint` without validating input ranges, which could lead to integer overflow if unexpected large values are encountered.

3. **Error Handling** - **Severity: Low**
   - The error handling is basic but does not provide detailed information that might help attackers understand the system's state or structure.

#### Attack Vectors:

- An attacker could exploit potential buffer overflows in `strconv` functions by providing very large input values.
- Improper error handling could reveal details about file permissions and process structures.

#### Recommended Fixes:

1. **Input Validation**:
   - Add range checks for integer conversions: 
     ```go
     if ppid, parseErr := strconv.Atoi(val); parseErr == nil && ppid > 0 {
         info.PPID = ppid
     }
     ```

2. **Error Handling**:
   - Improve error messages and logging to avoid leaking information:
     ```go
     if err != nil {
         return ProcessInfo{}, fmt.Errorf("failed to read process status: %w", err)
     }
     ```

3. **Security Posture**:
   - Ensure that the function is used in a secure context, such as with proper authentication and authorization checks.

#### Overall Security Posture:

The current implementation has some security gaps but does not present immediate critical risks. Addressing the input validation and error handling issues will significantly improve the code's robustness and reduce potential attack vectors.

---

*Generated by CodeWorm on 2026-03-01 21:10*
