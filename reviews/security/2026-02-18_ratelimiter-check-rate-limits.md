# RateLimiter._check_rate_limits

**Type:** Security Review
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/api-rate-limiter/src/fastapi_420/limiter.py
**Language:** python
**Lines:** 216-295
**Complexity:** 13.0

---

## Source Code

```python
async def _check_rate_limits(
        self,
        request: Request,
        rules: list[RateLimitRule],
        key_func: Callable[[Request],
                           str] | None = None,
        raise_on_limit: bool = True,
    ) -> RateLimitResult:
        """
        Check all rules and return/raise for the most restrictive failure
        """
        if not self._initialized:
            await self.init()

        storage = await self._get_active_storage()
        if storage is None:
            if self._settings.FAIL_OPEN:
                return RateLimitResult(
                    allowed = True,
                    limit = 0,
                    remaining = 0,
                    reset_after = 0,
                )
            raise StorageError(operation = "check", backend = None)

        fingerprint = await self._fingerprinter.extract(request)  # type: ignore[union-attr]
        endpoint = self._get_endpoint(request)

        if key_func:
            identifier = key_func(request)
        else:
            identifier = fingerprint.to_composite_key(
                self._settings.fingerprint.LEVEL
            )

        worst_result: RateLimitResult | None = None

        for rule in rules:
            key = RateLimitKey(
                prefix = self._settings.KEY_PREFIX,
                version = self._settings.KEY_VERSION,
                layer = Layer.USER,
                endpoint = endpoint,
                identifier = identifier,
                window = rule.window_seconds,
            ).build()

            result = await self._algorithm.check(  # type: ignore[union-attr]
                storage = storage,
                key = key,
                rule = rule,
            )

            if not result.allowed:  # noqa: SIM102
                if worst_result is None or result.retry_after > (worst_result.retry_after or 0):  # type: ignore[operator]
                    worst_result = result

        if worst_result is not None:
            if self._settings.LOG_VIOLATIONS:
                logger.warning(
                    "Rate limit exceeded",
                    extra = {
                        "endpoint": endpoint,
                        "identifier": identifier[: 16],
                        "remaining": worst_result.remaining,
                        "reset_after": worst_result.reset_after,
                    },
                )

            if raise_on_limit:
                raise EnhanceYourCalm(
                    result = worst_result,
                    message = self._settings.HTTP_420_MESSAGE,
                    detail = self._settings.HTTP_420_DETAIL,
                )

            return worst_result

        best_result = result
        return best_result
```

---

## Security Review

### Security Review for `RateLimiter._check_rate_limits`

#### Vulnerabilities and Severity

1. **Input Validation Gaps** (Medium):
   - Line 28: The function accepts a `key_func` parameter, but it does not validate or sanitize the input.
   
2. **Logging Information Disclosure** (Low):
   - Lines 37-40: Logging sensitive information like identifiers and remaining limits could potentially leak data.

#### Attack Vectors

1. **Injection**: If `key_func` is user-controlled, it could be used to inject malicious code or bypass rate limiting.
2. **Information Leakage**: Sensitive logging might expose internal state to attackers.

#### Recommended Fixes

1. **Input Validation**:
   - Ensure `key_func` returns a safe identifier by validating its input (e.g., using type hints and checking for valid characters).
   
2. **Secure Logging**:
   - Mask or remove sensitive information from logs before sending them to the logging system.
   ```python
   if self._settings.LOG_VIOLATIONS:
       logger.warning(
           "Rate limit exceeded",
           extra={
               "endpoint": endpoint,
               "identifier": identifier[:16],
               "remaining": worst_result.remaining,
               "reset_after": worst_result.reset_after,
           },
       )
   ```

#### Overall Security Posture

The function is well-structured and handles rate limiting effectively. However, it lacks robust input validation for `key_func` and could benefit from more secure logging practices. Addressing these issues will significantly improve the security posture of this module.

**Severity Ratings:**
- Input Validation Gaps: Medium
- Logging Information Disclosure: Low

---

*Generated by CodeWorm on 2026-02-18 13:57*
