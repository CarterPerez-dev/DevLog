# checkVolumes

**Type:** Performance Analysis
**Repository:** docksec
**File:** internal/analyzer/compose.go
**Language:** go
**Lines:** 170-228
**Complexity:** 10.0

---

## Source Code

```go
func (a *ComposeAnalyzer) checkVolumes(
	target finding.Target,
	serviceName string,
	node *yaml.Node,
) finding.Collection {
	var findings finding.Collection

	volumesNode := findNode(node, "volumes")
	if volumesNode == nil {
		return findings
	}

	for _, volNode := range volumesNode.Content {
		var hostPath string
		switch volNode.Kind {
		case yaml.ScalarNode:
			parts := strings.SplitN(volNode.Value, ":", 2)
			hostPath = parts[0]
		case yaml.MappingNode:
			sourceNode := findNode(volNode, "source")
			if sourceNode != nil {
				hostPath = sourceNode.Value
			}
		}

		if hostPath == "" {
			continue
		}

		if rules.IsDockerSocket(hostPath) {
			loc := &finding.Location{Path: a.path, Line: volNode.Line}
			f := finding.New("CIS-5.31", "Service '"+serviceName+"' mounts Docker socket", finding.SeverityCritical, target).
				WithDescription("Mounting Docker socket gives the container full control over the Docker daemon.").
				WithCategory(string(CategoryCompose)).
				WithLocation(loc).
				WithRemediation("Do not mount /var/run/docker.sock inside containers.")
			findings = append(findings, f)
			continue
		}

		if rules.IsSensitivePath(hostPath) {
			loc := &finding.Location{Path: a.path, Line: volNode.Line}
			severity := rules.GetPathSeverity(hostPath)
			pathInfo, _ := rules.GetPathInfo(hostPath)
			description := "Mounting sensitive host paths can enable container escape."
			if pathInfo.Description != "" {
				description = pathInfo.Description
			}
			f := finding.New("CIS-5.5", "Service '"+serviceName+"' mounts sensitive path: "+hostPath, severity, target).
				WithDescription(description).
				WithCategory(string(CategoryCompose)).
				WithLocation(loc).
				WithRemediation("Do not mount sensitive host directories. Use Docker volumes instead.")
			findings = append(findings, f)
		}
	}

	return findings
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n \times m)\), where \(n\) is the number of volume nodes, and \(m\) is the average length of each node's content. This is due to the nested loops and string operations.

**Space Complexity:** The space complexity is \(O(1)\) for variables like `findings`, but it grows with the size of the input `node` and the number of findings generated, making it dependent on the volume nodes.

**Bottlenecks:**
- **String Operations:** Repeated string operations such as `strings.SplitN` and `rules.IsDockerSocket/rules.IsSensitivePath` can be costly.
- **Redundant Checks:** The function checks for empty paths multiple times, which is redundant.

### Optimization Opportunities

1. **Cache Path Checks:** Cache the results of path checks like `IsDockerSocket` and `IsSensitivePath` to avoid redundant calls.
2. **Early Exit:** If a volume node does not have a valid host path, skip further checks for that node.
3. **Use Short-circuit Evaluation:** Use logical operators to reduce unnecessary evaluations.

### Resource Usage Concerns

- Ensure all resources are properly closed if used in async contexts.
- Consider using goroutines or channels to process nodes concurrently if the input is large.

By caching and optimizing path checks, you can significantly improve performance and reduce redundant operations.

---

*Generated by CodeWorm on 2026-02-22 00:01*
