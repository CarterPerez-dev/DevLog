# create_order

**Type:** Performance Analysis
**Repository:** fastapi-rc
**File:** fastapi-rc/examples/04_full_api_example.py
**Language:** python
**Lines:** 194-240
**Complexity:** 4.0

---

## Source Code

```python
async def create_order(
    user_id: str,
    product_ids: list[str],
    user_cache: UserCache,
    product_cache: ProductCache,
    order_cache: OrderCache,
    redis: RedisClient,
):
    """
    Create order with multi-cache coordination

    Pattern: Cache user, products, then order creation
    """
    user = await user_cache.get_or_set(
        identifier = user_id,
        factory = lambda: fetch_user(user_id),
    )

    products: list[Product] = []
    for product_id in product_ids:
        product = await product_cache.get_or_set(
            identifier = product_id,
            factory = lambda pid = product_id: fetch_product(pid),
        )
        products.append(product)

    total = sum(p.price for p in products)

    order = Order(
        id = "order_123",
        user_id = user.id,
        product_ids = product_ids,
        total = total,
        created_at = datetime.now(),
    )

    await order_cache.set(
        identifier = order.id,
        value = order,
        ttl = 300,
    )

    async for key in redis.scan_iter(
            f"ecommerce:v1:orders:user:{user_id}:*"):
        await redis.delete(key)

    return order
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n + m)\), where \(n\) is the number of `product_ids` and \(m\) is the cost of fetching each user and product. The main bottleneck is the `fetch_user` and `fetch_product` calls, which are called for every product ID.

**Space Complexity:** Space complexity is \(O(m + k)\), where \(k\) is the size of the order object. The primary memory usage comes from storing products in the list and creating an order object.

**Bottlenecks or Inefficiencies:**
1. **Redundant Fetches:** `fetch_user` is called even if the user already exists in the cache.
2. **N+1 Query Pattern:** For each product ID, a separate call to `fetch_product` is made, leading to multiple database hits.

**Optimization Opportunities:**
1. Use a single query to fetch all products by their IDs using an ORM batch operation or a raw SQL query.
2. Cache the result of `fetch_user` if it's called frequently.

**Resource Usage Concerns:**
- **Blocking Calls:** The function is marked as `async`, but there are no awaitable operations inside loops, which could block the event loop.
- **Redis Operations:** The `redis.scan_iter` operation might be costly due to its iterative nature. Consider using a more efficient pattern for cleaning up old keys.

### Suggested Optimizations
1. Use an ORM batch fetch or raw SQL query to get all products in one go.
2. Cache the result of `fetch_user` if it's called frequently.
3. Ensure that async operations are properly awaited within loops and use context managers for Redis connections to avoid leaks.

---

*Generated by CodeWorm on 2026-02-21 19:59*
