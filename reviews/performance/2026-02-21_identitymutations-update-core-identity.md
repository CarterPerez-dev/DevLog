# IdentityMutations.update_core_identity

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/core/foundation/repositories/identity_mutations.py
**Language:** python
**Lines:** 43-86
**Complexity:** 8.0

---

## Source Code

```python
async def update_core_identity(
        session: AsyncSession,
        data: dict
    ) -> CoreIdentity:
        """
        Update core identity (singleton) - partial update supported

        Args:
            data: Dict with fields to update (only updates fields present)
                  Fields: name, age, background, current_role, primary_goal, target_audience
        """
        result = await session.execute(select(CoreIdentity).limit(1))
        identity = result.scalar_one_or_none()

        if not identity:
            identity = CoreIdentity(
                name=data.get("name", ""),
                age=data.get("age", 0),
                background=data.get("background", ""),
                current_role=data.get("current_role", ""),
                primary_goal=data.get("primary_goal", ""),
                target_audience=data.get("target_audience", ""),
            )
            session.add(identity)
            await session.flush()
            await session.refresh(identity)
            return identity

        if "name" in data:
            identity.name = data["name"]
        if "age" in data:
            identity.age = data["age"]
        if "background" in data:
            identity.background = data["background"]
        if "current_role" in data:
            identity.current_role = data["current_role"]
        if "primary_goal" in data:
            identity.primary_goal = data["primary_goal"]
        if "target_audience" in data:
            identity.target_audience = data["target_audience"]

        await session.flush()
        await session.refresh(identity)
        return identity
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is \(O(n)\), where \(n\) is the number of fields in `data`. Each field update involves an `if` check and a potential database operation.

**Space Complexity:** The space complexity is \(O(1)\) as no additional data structures are created that scale with input size. However, the memory footprint for database operations can be significant due to context manager usage.

**Bottlenecks or Inefficiencies:**
- **Redundant `await session.flush()` and `session.refresh()`:** These calls are made twiceâ€”once after adding a new identity and once during updates. This is unnecessary since both operations are idempotent.
- **Unnecessary `if` Checks:** Each field update involves an `if` check, which can be optimized.

**Optimization Opportunities:**
- Combine the `flush()` and `refresh()` calls into one for updates to avoid redundancy.
- Use a dictionary comprehension or loop to handle dynamic field updates more efficiently.

```python
async def update_core_identity(
        session: AsyncSession,
        data: dict
    ) -> CoreIdentity:
    result = await session.execute(select(CoreIdentity).limit(1))
    identity = result.scalar_one_or_none()

    if not identity:
        identity = CoreIdentity(**{k: v for k, v in data.items() if v})
        session.add(identity)
        await session.flush()
        await session.refresh(identity)
        return identity

    for key, value in {k: v for k, v in data.items() if v}.items():
        setattr(identity, key, value)

    await session.flush()
    await session.refresh(identity)
    return identity
```

**Resource Usage Concerns:**
- Ensure `session` is properly managed and closed after use to avoid resource leaks.
- Consider using a context manager for the database session to ensure it's always closed.

```python
async with AsyncSession() as session:
    # Function call here
```

By optimizing these areas, you can improve both performance and maintainability.

---

*Generated by CodeWorm on 2026-02-21 17:52*
