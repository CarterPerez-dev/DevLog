# CycleService.get_calendar_month

**Type:** Performance Analysis
**Repository:** ios-test
**File:** fastapi/app/cycle/service.py
**Language:** python
**Lines:** 174-265
**Complexity:** 18.0

---

## Source Code

```python
async def get_calendar_month(
        self,
        user_id: UUID,
        year: int,
        month: int,
    ) -> CalendarMonth:
        """
        Get calendar data for a specific month
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        first_day = date(year, month, 1)
        if month == 12:
            last_day = date(year + 1, 1, 1) - timedelta(days = 1)
        else:
            last_day = date(year, month + 1, 1) - timedelta(days = 1)

        period_logs = await PeriodLogRepository.get_by_partner_id(
            self.session,
            partner.id,
            limit = 12,
        )

        daily_logs = await DailyLogRepository.get_date_range(
            self.session,
            partner.id,
            first_day,
            last_day,
        )
        daily_log_map = {log.log_date: log for log in daily_logs}

        period_dates: set[date] = set()
        predicted_dates: set[date] = set()

        for log in period_logs:
            period_length = partner.average_period_length
            if log.end_date:
                period_length = (log.end_date - log.start_date).days + 1

            for i in range(period_length):
                d = log.start_date + timedelta(days = i)
                if log.is_predicted:
                    predicted_dates.add(d)
                else:
                    period_dates.add(d)

        if partner.last_period_start:
            predicted_start = partner.last_period_start + timedelta(
                days = partner.average_cycle_length
            )
            while predicted_start <= last_day:
                if predicted_start >= first_day:
                    for i in range(partner.average_period_length):
                        d = predicted_start + timedelta(days = i)
                        if first_day <= d <= last_day and d not in period_dates:
                            predicted_dates.add(d)
                predicted_start += timedelta(days = partner.average_cycle_length)

        days: list[CalendarDay] = []
        current_date = first_day

        while current_date <= last_day:
            cycle_day = None
            phase = CyclePhase.UNKNOWN

            if partner.last_period_start:
                days_since = (current_date - partner.last_period_start).days + 1
                if days_since > 0:
                    cycle_day = ((days_since - 1) % partner.average_cycle_length) + 1
                    phase = self._get_phase(cycle_day, partner.average_cycle_length)

            daily_log = daily_log_map.get(current_date)

            days.append(CalendarDay(
                date = current_date,
                cycle_day = cycle_day,
                phase = phase,
                is_period = current_date in period_dates,
                is_predicted_period = current_date in predicted_dates,
                has_daily_log = daily_log is not None,
            
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n^2)\) due to the nested loops in `predicted_dates` calculation, where \(n\) is the number of logs. This can be optimized.

**Space Complexity:** The space complexity is \(O(m + p)\), where \(m\) is the number of daily logs and \(p\) is the number of period logs. Reducing redundant storage could improve efficiency.

**Bottlenecks:**
1. **Nested Loops in `predicted_dates` Calculation:** The nested loop iterating over `period_length` for each log can be costly.
2. **Multiple Database Queries:** The function makes multiple database queries, which can be expensive if not optimized.
3. **Redundant Operations:** Calculating `period_length` and `cycle_day` repeatedly.

**Optimization Opportunities:**
1. **Reduce Nested Loops:** Use a more efficient method to calculate `predicted_dates`, such as a set comprehension or list comprehension.
2. **Batch Queries:** Combine multiple database queries into one using `IN` clauses where applicable.
3. **Memoization:** Cache results of expensive operations like `_get_phase`.

**Resource Usage Concerns:**
- Ensure proper use of context managers for database sessions to avoid resource leaks.
- Use async I/O efficiently by minimizing blocking calls.

### Suggested Optimizations
1. Replace nested loops in `predicted_dates` with a set comprehension.
2. Combine `PeriodLogRepository.get_by_partner_id` and `DailyLogRepository.get_date_range` into one query if possible.
3. Cache results of `_get_phase` using decorators like `functools.lru_cache`.

By addressing these points, the function can be made more efficient and scalable.

---

*Generated by CodeWorm on 2026-02-21 23:21*
