# get_language_distribution

**Type:** Performance Analysis
**Repository:** kill-pr0cess.inc
**File:** backend/src/routes/github.rs
**Language:** rust
**Lines:** 259-327
**Complexity:** 10.0

---

## Source Code

```rust
pub async fn get_language_distribution(
    State(app_state): State<AppState>,
) -> Result<JsonResponse<serde_json::Value>> {
    info!("Calculating language distribution across repositories");

    let username = &app_state.config.github_username;

    // Get all repositories
    let repositories = match app_state.github_service.get_user_repositories(username).await {
        Ok(repos) => repos,
        Err(_) => get_repositories_from_db(&app_state, username).await?,
    };

    // Calculate language statistics
    let mut language_stats: HashMap<String, LanguageStat> = HashMap::new();
    let mut total_size: i64 = 0;

    for repo in &repositories {
        if repo.is_archived || repo.is_fork {
            continue; // Skip archived and forked repositories for cleaner stats
        }

        total_size += repo.size_kb as i64;

        if let Some(ref language) = repo.language {
            let stat = language_stats.entry(language.clone()).or_insert(LanguageStat {
                name: language.clone(),
                repository_count: 0,
                total_size_kb: 0,
                total_stars: 0,
                average_stars: 0.0,
                percentage: 0.0,
            });

            stat.repository_count += 1;
            stat.total_size_kb += repo.size_kb as i64;
            stat.total_stars += repo.stargazers_count;
        }
    }

    // Calculate percentages and averages
    for stat in language_stats.values_mut() {
        stat.percentage = if total_size > 0 {
            (stat.total_size_kb as f64 / total_size as f64) * 100.0
        } else { 0.0 };
        stat.average_stars = if stat.repository_count > 0 {
            stat.total_stars as f64 / stat.repository_count as f64
        } else { 0.0 };
    }

    // Sort by usage (repository count)
    let mut sorted_languages: Vec<_> = language_stats.into_values().collect();
    sorted_languages.sort_by(|a, b| b.repository_count.cmp(&a.repository_count));

    let response = serde_json::json!({
        "languages": sorted_languages,
        "summary": {
            "total_languages": sorted_languages.len(),
            "total_repositories_analyzed": repositories.len(),
            "total_size_kb": total_size,
            "most_used_language": sorted_languages.first().map(|l| &l.name),
            "language_diversity_score": calculate_diversity_score(&sorted_languages)
        },
        "analysis_timestamp": chrono::Utc::now()
    });

    info!("Language distribution calculated for {} languages", sorted_languages.len());
    Ok(Json(response))
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of O(n + m log m), where `n` is the number of repositories, and `m` is the number of unique languages. The primary bottleneck is the sorting step (`sorted_languages.sort_by()`).

**Space Complexity:** The space complexity is O(m) for storing language statistics in `language_stats`. The `repositories` vector also consumes O(n) space.

**Bottlenecks or Inefficiencies:**
1. **Sorting Step:** Sorting the languages by usage (repository count) can be costly, especially as the number of unique languages grows.
2. **Redundant Operations:** Recalculating percentages and averages in a loop after sorting is redundant since these values are already computed.

**Optimization Opportunities:**
1. **Minimize Redundant Calculations:** Move percentage and average calculations outside the sorting step to avoid recalculating them multiple times.
2. **Efficient Sorting:** Use a more efficient sorting algorithm if `m` can be large, or consider an in-place sort if memory is not a concern.

**Resource Usage Concerns:**
1. **Memory Leaks:** Ensure that all database connections are properly closed when fetching repositories from the database.
2. **Error Handling:** Improve error handling to provide more informative responses and avoid unwrapping errors without proper context.

By optimizing these areas, you can improve both performance and resource utilization in your function.

---

*Generated by CodeWorm on 2026-02-21 19:22*
