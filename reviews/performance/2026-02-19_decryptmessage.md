# decryptMessage

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/crypto/double-ratchet.ts
**Language:** typescript
**Lines:** 225-289
**Complexity:** 9.0

---

## Source Code

```typescript
async function decryptMessage(
  state: DoubleRatchetState,
  message: EncryptedMessage,
  associatedData?: Uint8Array
): Promise<Uint8Array> {
  const peerPublicKey = base64ToBytes(message.header.dh_public_key)

  const skippedKeyId = createSkippedKeyId(
    peerPublicKey,
    message.header.message_number
  )
  const skippedKey = state.skipped_message_keys.get(skippedKeyId)

  if (skippedKey !== undefined) {
    state.skipped_message_keys.delete(skippedKeyId)

    const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
    const aad =
      associatedData !== undefined
        ? concatBytes(associatedData, headerBytes)
        : headerBytes

    return await aesGcmDecrypt(skippedKey, message.ciphertext, message.nonce, aad)
  }

  const isDifferentRatchetKey =
    state.dh_peer_public_key === null ||
    bytesToBase64(state.dh_peer_public_key) !== message.header.dh_public_key

  if (isDifferentRatchetKey) {
    if (state.receiving_chain_key !== null && state.dh_peer_public_key !== null) {
      await skipMessageKeys(state, message.header.previous_chain_length)
    }

    await performDHRatchet(state, peerPublicKey)
  }

  await skipMessageKeys(state, message.header.message_number)

  if (state.receiving_chain_key === null) {
    throw new Error('Receiving chain key not initialized after ratchet')
  }

  const { messageKey, nextChainKey } = await deriveMessageKey(
    state.receiving_chain_key
  )

  const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
  const aad =
    associatedData !== undefined
      ? concatBytes(associatedData, headerBytes)
      : headerBytes

  const plaintext = await aesGcmDecrypt(
    messageKey,
    message.ciphertext,
    message.nonce,
    aad
  )

  state.receiving_chain_key = nextChainKey
  state.receiving_message_number++

  return plaintext
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity**: The function has a time complexity of \(O(n)\), where \(n\) is the length of the message header due to string encoding operations.

**Space Complexity**: The space complexity is \(O(1)\) for variables, but the `state` object's memory usage depends on its internal state and can grow over time if not properly managed.

**Bottlenecks or Inefficiencies**:
- **Redundant Operations**: Converting `message.header` to a string and then back to bytes is redundant. Directly use the header fields.
- **Blocking Calls**: Asynchronous operations like `aesGcmDecrypt`, `performDHRatchet`, and `skipMessageKeys` are awaited, which can block other tasks.

**Optimization Opportunities**:
1. **Remove Redundant Operations**: Directly use header fields without converting to string.
2. **Minimize Async Await**: Use `.then()` chaining for async operations if possible to avoid blocking the event loop.
3. **Cache Header Fields**: Cache `message.header` fields to reduce repeated conversions.

**Resource Usage Concerns**:
- Ensure `state.skipped_message_keys` and other state-related resources are properly managed to prevent memory leaks.
- Consider implementing a timeout mechanism for async operations to handle potential long-running tasks.

By addressing these areas, you can improve the function's performance and responsiveness.

---

*Generated by CodeWorm on 2026-02-19 10:41*
