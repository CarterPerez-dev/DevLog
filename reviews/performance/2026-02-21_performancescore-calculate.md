# PerformanceScore.calculate

**Type:** Performance Analysis
**Repository:** kill-pr0cess.inc
**File:** backend/src/models/performance.rs
**Language:** rust
**Lines:** 532-583
**Complexity:** 10.0

---

## Source Code

```rust
pub fn calculate(system_info: &SystemInfo, app_metrics: &ApplicationMetrics) -> Self {
        let mut component_scores = HashMap::new();
        let mut bottlenecks = Vec::new();
        let mut recommendations = Vec::new();

        // Calculate component scores
        let cpu_score = calculate_cpu_score(system_info.cpu_usage_percent);
        let memory_score = calculate_memory_score(system_info.memory_usage_percent);
        let response_time_score = calculate_response_time_score(app_metrics.average_response_time_ms);
        let error_rate_score = calculate_error_rate_score(app_metrics.error_rate_percent);

        component_scores.insert("cpu".to_string(), cpu_score);
        component_scores.insert("memory".to_string(), memory_score);
        component_scores.insert("response_time".to_string(), response_time_score);
        component_scores.insert("error_rate".to_string(), error_rate_score);

        // Identify bottlenecks
        if cpu_score < 70.0 {
            bottlenecks.push("High CPU utilization".to_string());
            recommendations.push("Consider optimizing CPU-intensive operations".to_string());
        }
        if memory_score < 70.0 {
            bottlenecks.push("High memory usage".to_string());
            recommendations.push("Review memory usage and implement cleanup".to_string());
        }
        if response_time_score < 70.0 {
            bottlenecks.push("Slow response times".to_string());
            recommendations.push("Optimize database queries and caching".to_string());
        }
        if error_rate_score < 70.0 {
            bottlenecks.push("High error rate".to_string());
            recommendations.push("Investigate and fix error sources".to_string());
        }

        let overall_score = component_scores.values().sum::<f64>() / component_scores.len() as f64;
        let grade = match overall_score {
            x if x >= 90.0 => PerformanceGrade::A,
            x if x >= 80.0 => PerformanceGrade::B,
            x if x >= 70.0 => PerformanceGrade::C,
            x if x >= 60.0 => PerformanceGrade::D,
            _ => PerformanceGrade::F,
        };

        Self {
            overall_score,
            grade,
            component_scores,
            bottlenecks,
            recommendations,
            trend: PerformanceTrend::Stable, // Would be calculated from historical data
        }
    }
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(1)\), as the operations inside are constant-time, involving fixed number of calculations and insertions.

**Space Complexity:** The space complexity is also \(O(1)\) for the core logic. However, `component_scores`, `bottlenecks`, and `recommendations` vectors grow with input size, making them \(O(n)\).

**Bottlenecks or Inefficiencies:**
- **Redundant Checks:** Each condition in `if` statements is checked independently, even if previous conditions fail.
- **Repeated Insertions:** Using `.insert()` multiple times for the same hashmap can be optimized.

**Optimization Opportunities:**
- Use a single pass to populate `component_scores`, `bottlenecks`, and `recommendations`.
- Consider using a struct to store component scores directly, reducing repeated insertions.

```rust
let mut component_scores = HashMap::new();
let cpu_score = calculate_cpu_score(system_info.cpu_usage_percent);
let memory_score = calculate_memory_score(system_info.memory_usage_percent);
let response_time_score = calculate_response_time_score(app_metrics.average_response_time_ms);
let error_rate_score = calculate_error_rate_score(app_metrics.error_rate_percent);

component_scores.insert("cpu", cpu_score);
component_scores.insert("memory", memory_score);
component_scores.insert("response_time", response_time_score);
component_scores.insert("error_rate", error_rate_score);

if let Some(cpu_score) = component_scores.get("cpu") {
    if *cpu_score < 70.0 {
        bottlenecks.push("High CPU utilization".to_string());
        recommendations.push("Consider optimizing CPU-intensive operations".to_string());
    }
}

// Repeat for other components
```

**Resource Usage Concerns:**
- Ensure `SystemInfo` and `ApplicationMetrics` are properly managed to avoid resource leaks.
- Consider caching results of `calculate_cpu_score`, etc., if these functions are expensive.

This refactoring reduces redundancy and improves code readability, making the function more efficient.

---

*Generated by CodeWorm on 2026-02-21 19:19*
