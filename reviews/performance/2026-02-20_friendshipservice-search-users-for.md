# FriendshipService.search_users_for_friends

**Type:** Performance Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/social/services/friendship_ops.py
**Language:** python
**Lines:** 393-478
**Complexity:** 11.0

---

## Source Code

```python
def search_users_for_friends(
        user_id: str | ObjectId,
        search_term: str,
        limit: int = 20
    ) -> list[SearchUserDict]:
        """
        Search users by username (autocomplete)
        Returns users with their friendship status relative to the searcher
        """
        user_id = ObjectId(user_id
                           ) if isinstance(user_id,
                                           str) else user_id

        users = User.objects(
            username__icontains = search_term,
            id__ne = user_id
        ).limit(limit)

        existing_friendships = Friendship.objects().filter(
            __raw__ = {
                "$or": [
                    {
                        "requesterUserId": user_id
                    },
                    {
                        "recipientUserId": user_id
                    }
                ]
            }
        )

        friendship_map = {}
        for friendship in existing_friendships:
            if friendship.requesterUserId == user_id:
                friend_id = str(friendship.recipientUserId)
            else:
                friend_id = str(friendship.requesterUserId)

            can_send = True
            if friendship.status == FriendshipStatus.REJECTED.value and friendship.requesterUserId == user_id:
                thirty_days_ago = datetime.now(UTC) - timedelta(days = 30)
                recent_rejections = [
                    dt for dt in friendship.rejectionHistory if (
                        dt.replace(tzinfo = UTC) if dt.tzinfo is
                        None else dt
                    ) >= thirty_days_ago
                ]
                can_send = len(recent_rejections) < 6

            friendship_map[friend_id] = {
                "status": friendship.status,
                "friendshipId": str(friendship.id),
                "iRequested": friendship.requesterUserId == user_id,
                "canSendRequest": can_send,
            }

        result: list[SearchUserDict] = []
        for user in users:
            friend_data = friendship_map.get(str(user.id), {})
            result.append(
                {
                    "userId":
                    str(user.id),
                    "username":
                    user.username,
                    "level":
                    user.level,
                    "currentAvatar":
                    str(user.currentAvatar)
                    if user.currentAvatar else None,
                    "nameColor":
                    user.nameColor,
                    "friendshipStatus":
                    friend_data.get("status"),
                    "friendshipId":
                    friend_data.get("friendshipId"),
                    "iRequested":
                    friend_data.get("iRequested",
                                    False),
                    "canSendRequest":
                    friend_data.get("canSendRequest",
                                    True),
     
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The primary bottleneck is the `existing_friendships` query, which has a time complexity of \(O(n)\), where \(n\) is the number of friendships. This is followed by iterating over each user to find their friendship status, also \(O(m)\) where \(m\) is the number of users. Overall, the function's time complexity is approximately \(O(n + m)\).

**Space Complexity:** The `friendship_map` dictionary uses additional space proportional to the number of friendships, making it \(O(n)\). The result list has a space complexity of \(O(m)\), as each user can have friendship data.

**Bottlenecks and Inefficiencies:**
1. **Blocking Calls in Async Contexts:** The function is synchronous; ensure that database queries are not blocking.
2. **N+1 Query Pattern:** The `existing_friendships` query followed by individual lookups for each user's friendship status can lead to N+1 queries, which should be optimized using eager loading or batch processing.
3. **Redundant Operations:** Calculating recent rejections multiple times is inefficient.

**Optimization Opportunities:**
1. Use `.only()` to limit the fields fetched from the database in `existing_friendships`.
2. Implement caching for frequently accessed friendship statuses.
3. Optimize the rejection history check by using a set or dictionary for faster lookups.

**Resource Usage Concerns:**
- Ensure all database connections are properly managed, especially if this function is called concurrently.
- Use context managers to handle file operations if any are present.

---

*Generated by CodeWorm on 2026-02-20 20:29*
