# run

**Type:** Performance Analysis
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/cmd/api/main.go
**Language:** go
**Lines:** 42-197
**Complexity:** 14.0

---

## Source Code

```go
func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	var telemetry *core.Telemetry
	if cfg.Otel.Enabled {
		tel, telErr := core.NewTelemetry(ctx, cfg.Otel, cfg.App)
		if telErr != nil {
			logger.Warn("failed to initialize telemetry", "error", telErr)
		} else {
			telemetry = tel
			logger.Info("OpenTelemetry tracer initialized",
				"endpoint", cfg.Otel.Endpoint,
			)
		}
	}

	db, err := core.NewDatabase(ctx, cfg.Database)
	if err != nil {
		return err
	}
	logger.Info("database connected",
		"max_open_conns", cfg.Database.MaxOpenConns,
		"max_idle_conns", cfg.Database.MaxIdleConns,
	)

	redis, err := core.NewRedis(ctx, cfg.Redis)
	if err != nil {
		return err
	}
	logger.Info("redis connected",
		"pool_size", cfg.Redis.PoolSize,
	)

	jwtManager, err := auth.NewJWTManager(cfg.JWT)
	if err != nil {
		return err
	}
	logger.Info("JWT manager initialized",
		"algorithm", "ES256",
		"key_id", jwtManager.GetKeyID(),
	)

	userRepo := user.NewRepository(db.DB)
	userSvc := user.NewService(userRepo)
	userHandler := user.NewHandler(userSvc)

	authRepo := auth.NewRepository(db.DB)
	authSvc := auth.NewService(authRepo, jwtManager, userSvc, redis.Client)
	authHandler := auth.NewHandler(authSvc)

	healthHandler := health.NewHandler(db, redis)

	adminHandler := admin.NewHandler(admin.HandlerConfig{
		DBStats:    db.Stats,
		RedisStats: redis.PoolStats,
		DBPing:     db.Ping,
		RedisPing:  redis.Ping,
	})

	srv := server.New(server.Config{
		ServerConfig:  cfg.Server,
		HealthHandler: healthHandler,
		Logger:        logger,
	})

	router := srv.Router()

	router.Use(middleware.RequestID)
	router.Use(middleware.Logger(logger))
	router.Use(
		middleware.NewRateLimiter(redis.Client, middleware.RateLimitConfig{
			Limit: middleware.PerMinute(
				cfg.RateLimit.Requests,
				cfg.RateLimit.Burst,
			),
			FailOpen: true,
		}).Handler,
	)
	router.Use(middleware.SecurityHeaders(cfg.App.Environment == "production"))
	router.Use(middleware.CORS(cfg.CORS))

	healthHandler.RegisterRoutes(router)

	router.Get("/.well-known/jwks.json", jwtManager.GetJWKSHandler())

	authenticator := middleware.Authenticator(jwtManager)
	adminOnly := middleware.RequireAdmin

	router.Route("/v1", func(r chi.Router) {
		authHandler.RegisterRoutes(r, authenticator)

		r.Post("/users", authHandler.Register)

		userHandler.RegisterRoutes(r, authenticator)
		userHandler.RegisterAdminRoutes(r, authenticator, adminOnly)
		adminHandler.RegisterRoutes(r, authenticator, adminOnly)
	})

	errChan := make(chan error, 1)
	go func() {
		errChan <- srv.Start()
	}()

	select {
	case err := <-errChan:
		return err
	case <-ctx.Done():
		logger.Info("shutdown si
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(1)\) for the majority of operations, as most setup functions are called once. However, the `NewDatabase` and `NewRedis` calls involve network or database connections, which could be costly if not optimized.

**Space Complexity:** The primary space concerns include the creation of multiple handlers and services, each holding references to underlying resources like databases and Redis clients. This can lead to increased memory usage, especially during concurrent operations.

**Bottlenecks & Inefficiencies:**
1. **Redundant Logging:** Each resource connection (database, Redis) is logged separately, which might not be necessary if a single log message summarizes the connections.
2. **Blocking Calls in Async Contexts:** The `srv.Start()` call inside a goroutine could block until the server starts, potentially causing delays.

**Optimization Opportunities:**
1. **Combine Logging:** Log all resource connections with a single message to reduce overhead.
2. **Non-blocking Server Start:** Use non-blocking calls for starting the server and handle errors asynchronously.
3. **Resource Pooling:** Consider using connection pooling for database and Redis clients to manage resources more efficiently.

**Resource Usage Concerns:**
1. **Unclosed Connections:** Ensure all connections are properly closed in `defer` statements, especially if an error occurs early in the function.
2. **Memory Leaks:** Avoid unnecessary object allocations by reusing objects where possible.

By addressing these areas, you can improve both the performance and reliability of your application.

---

*Generated by CodeWorm on 2026-02-21 02:02*
