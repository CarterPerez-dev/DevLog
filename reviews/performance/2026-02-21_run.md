# Run

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/websocket/hub.go
**Language:** go
**Lines:** 44-94
**Complexity:** 10.0

---

## Source Code

```go
func (h *Hub) Run(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			h.mu.Lock()
			for client := range h.clients {
				close(client.send)
				delete(h.clients, client)
			}
			h.mu.Unlock()
			return

		case client := <-h.register:
			h.mu.Lock()
			h.clients[client] = true
			h.mu.Unlock()
			h.logger.Debug("websocket client connected",
				"client_id", client.clientID,
				"total_clients", len(h.clients),
			)

		case client := <-h.unregister:
			h.mu.Lock()
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send)
			}
			h.mu.Unlock()
			h.logger.Debug("websocket client disconnected",
				"client_id", client.clientID,
				"total_clients", len(h.clients),
			)

		case message := <-h.broadcast:
			h.mu.RLock()
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					h.mu.RUnlock()
					h.mu.Lock()
					delete(h.clients, client)
					close(client.send)
					h.mu.Unlock()
					h.mu.RLock()
				}
			}
			h.mu.RUnlock()
		}
	}
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is primarily determined by the operations within the `select` statement, which are O(1) for each case. However, the critical bottleneck lies in the `broadcast` case where a nested loop and potential relocking of mutexes occur, leading to an overall complexity that can degrade to O(n^2) in the worst case due to repeated locking and unlocking.

**Space Complexity:** The space complexity is O(n), where n is the number of connected clients. This is due to the storage of client connections in `h.clients`.

### Bottlenecks or Inefficiencies

1. **Nested Loops and Relocking:** The nested loop within the `broadcast` case can lead to unnecessary relocking, causing performance degradation.
2. **Redundant Operations:** Each iteration checks if a client exists before sending messages, which is redundant.

### Optimization Opportunities

1. **Avoid Redundant Checks:** Remove the check for existence of clients in each iteration by using a separate map or slice to track active clients.
2. **Reduce Locking Overhead:** Use `sync.Map` instead of `map` for `h.clients` to avoid locking during read operations.

### Resource Usage Concerns

- Ensure that all resources, such as file handles and network connections, are properly closed when a client disconnects.
- Consider using `context.WithTimeout` or similar mechanisms to handle long-running contexts more gracefully.

By addressing these points, you can significantly improve the performance and efficiency of your WebSocket hub implementation.

---

*Generated by CodeWorm on 2026-02-21 18:37*
