# run

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** Docker-Kentros/cmd/server/main.go
**Language:** go
**Lines:** 80-189
**Complexity:** 10.0

---

## Source Code

```go
func run(ctx context.Context, cfg *config.Config, logger *slog.Logger) error {
	logger.Info("starting holophyly",
		"version", version,
		"address", cfg.Address(),
	)

	dockerClient, err := docker.NewClient()
	if err != nil {
		return fmt.Errorf("creating docker client: %w", err)
	}
	defer func() { _ = dockerClient.Close() }()

	if err := dockerClient.Ping(ctx); err != nil {
		return fmt.Errorf("docker daemon not available: %w", err)
	}
	logger.Info("connected to docker daemon")

	if !docker.IsComposeInstalled(ctx) {
		logger.Warn("docker compose not found - compose operations will fail")
	}

	dataDir := cfg.DataDir
	if dataDir == "" {
		home, _ := os.UserHomeDir()
		dataDir = filepath.Join(home, ".config", "holophyly")
	}

	prefStore, err := store.New(dataDir)
	if err != nil {
		logger.Warn("failed to initialize preferences store", "error", err)
	} else {
		defer func() { _ = prefStore.Close() }()
		logger.Info("preferences store initialized", "path", dataDir)
	}

	fileScanner := scanner.NewScanner(cfg.Scanner.Paths, cfg.Scanner.Exclude)

	protection := project.NewProtectionConfig(
		cfg.Protection.Patterns,
		cfg.Protection.Projects,
	)

	manager := project.NewManager(dockerClient, fileScanner, protection, prefStore)

	if err := manager.Refresh(ctx); err != nil {
		logger.Warn("initial project scan failed", "error", err)
	} else {
		projects := manager.ListProjects()
		logger.Info("initial scan complete", "projects_found", len(projects))
	}

	hub := websocket.NewHub(logger)
	go hub.Run(ctx)

	router := api.NewRouter(api.RouterConfig{
		Manager:        manager,
		Hub:            hub,
		Logger:         logger,
		AllowedOrigins: cfg.Server.AllowedOrigins,
	})

	api.MountStatic(router, web.FS())

	server := &http.Server{
		Addr:         cfg.Address(),
		Handler:      router,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 10 * time.Minute,
		IdleTimeout:  60 * time.Second,
	}

	go runPeriodicScanner(ctx, manager, cfg.Scanner.ScanInterval, logger)

	go hub.StartStatsStreamer(ctx, createStatsGetter(manager))

	serverErr := make(chan error, 1)
	go func() {
		logger.Info("server listening",
			"host", cfg.Server.Host,
			"port", cfg.Server.Port,
			"url", fmt.Sprintf("http://%s", cfg.Address()),
		)
		if err := server.ListenAndServe(); err != http.ErrServerClosed {
			serverErr <- err
		}
		close(serverErr)
	}()

	select {
	case err := <-serverErr:
		return fmt.Errorf("server error: %w", err)
	case <-ctx.Done():
		logger.Info("shutdown signal received")
	}

	shutdownCtx, cancel := context.WithTimeout(
		context.Background(),
		30*time.Second,
	)
	defer cancel()

	logger.Info("shutting down server")
	if err := server.Shutdown(shutdownCtx); err != nil {
		logger.Error("server shutdown error", "error", err)
		return fmt.Errorf("shutdown error: %w", err)
	}

	logger.Info("server stopped gracefully")
	return nil
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of the `run` function is primarily driven by the operations within the goroutines, such as `dockerClient.Ping`, `manager.Refresh`, and `hub.Run`. These operations are generally O(1) or O(n), but the overall complexity is influenced by the number of projects (`O(n)` where `n` is the number of projects).

#### Space Complexity
The space complexity is moderate due to the use of goroutines, channels, and temporary variables. The main memory concerns include:
- `dockerClient`, `prefStore`, and `fileScanner` are allocated but deferred for cleanup.
- `projects` list is created during the initial scan.

#### Bottlenecks or Inefficiencies
1. **Redundant Operations**: The `dockerClient.Ping` call is made even if the connection was previously established, which could be avoided by checking a flag.
2. **Blocking Calls in Async Contexts**: The `server.ListenAndServe()` and `hub.Run(ctx)` are blocking calls within goroutines, potentially causing delays.

#### Optimization Opportunities
1. **Conditional Ping**: Introduce a flag to avoid redundant pings if the connection is known to be active.
   ```go
   if !dockerClient.IsConnected() {
       if err := dockerClient.Ping(ctx); err != nil {
           return fmt.Errorf("docker daemon not available: %w", err)
       }
   }
   ```

2. **Non-blocking Server Listen**: Use a non-blocking approach for the server to handle interruptions better.
   ```go
   go func() {
       if err := server.ListenAndServe(); err != http.ErrServerClosed && err != nil {
           serverErr <- err
       }
   }()
   ```

3. **Resource Management**: Ensure that all resources are properly closed, especially in case of errors.

#### Resource Usage Concerns
- **Unclosed Connections**: Ensure `dockerClient.Close()` and `prefStore.Close()` are called even if an error occurs.
- **Memory Leaks**: Use context cancellation to gracefully shut down goroutines and close resources.

By addressing these points, the function can be made more efficient and robust.

---

*Generated by CodeWorm on 2026-02-21 17:29*
