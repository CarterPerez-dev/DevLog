# run

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/cmd/api/main.go
**Language:** go
**Lines:** 46-192
**Complexity:** 11.0

---

## Source Code

```go
func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	_ = godotenv.Load()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	mongoClient, err := mongodb.NewClient(ctx, cfg.Mongo)
	if err != nil {
		return err
	}
	logger.Info("mongodb connected",
		"database", cfg.Mongo.Database,
		"max_pool_size", cfg.Mongo.MaxPoolSize,
	)

	sqliteClient, err := sqlite.NewClient(cfg.SQLite)
	if err != nil {
		return err
	}
	logger.Info("sqlite connected",
		"path", cfg.SQLite.Path,
	)

	healthHandler := health.NewHandler(mongoClient, sqliteClient)

	metricsRepo := mongodb.NewMetricsRepository(mongoClient)
	metricsSvc := metrics.NewService(metricsRepo, cfg.Mongo.Database)
	metricsHandler := handler.NewMetricsHandler(metricsSvc)

	backupRepo := sqlite.NewBackupRepository(sqliteClient)
	backupExecutor := backup.NewExecutor(cfg.Backup, cfg.Mongo.URI)
	backupScheduler := backup.NewScheduler(logger)
	backupSvc := backup.NewService(backupExecutor, backupScheduler, backupRepo, cfg.Backup.RetentionDays, logger)
	backupsHandler := handler.NewBackupsHandler(backupSvc, cfg.Mongo.Database)

	collectionsRepo := mongodb.NewCollectionsRepository(mongoClient)
	collectionsHandler := handler.NewCollectionsHandler(collectionsRepo, cfg.Mongo.Database)

	cleanupSvc := cleanup.NewService(mongoClient.Client(), cfg.Mongo.Database, 30, logger)

	wsHub := websocket.NewHub(logger)
	go wsHub.Run(ctx)

	wsHandler := websocket.NewHandler(wsHub, logger)

	metricsGetter := func(ctx context.Context) (any, error) {
		return metricsSvc.GetDashboardMetrics(ctx)
	}
	broadcaster := websocket.NewMetricsBroadcaster(wsHub, metricsGetter, 2000, logger)
	broadcaster.Start(ctx)
	logger.Info("websocket broadcaster started", "interval_ms", 2000)

	srv := server.New(server.Config{
		ServerConfig:  cfg.Server,
		HealthHandler: healthHandler,
		Logger:        logger,
	})

	router := srv.Router()

	router.Use(middleware.RequestID)
	router.Use(middleware.Logger(logger))
	router.Use(middleware.SecurityHeaders(cfg.App.Environment == "production"))
	router.Use(middleware.CORS(cfg.CORS))

	healthHandler.RegisterRoutes(router)
	metricsHandler.RegisterRoutes(router)
	backupsHandler.RegisterRoutes(router)
	collectionsHandler.RegisterRoutes(router)
	router.Handle("/ws", wsHandler)

	backupSvc.StartScheduler()
	if err := backupSvc.SetupDailyBackup(cfg.Mongo.Database); err != nil {
		logger.Warn("failed to setup daily backup", "error", err)
	}

	_, err = backupScheduler.Cron().AddFunc("0 20 21 * * *", func() {
		cleanupCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
		defer cancel()

		logger.Info("starting scheduled cleanup task")
		_, cleanupErr := cleanupSvc.CleanOldDocuments(cleanupCtx)
		i
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity (Big O Notation)
The function `run` has a time complexity dominated by the setup of database clients, services, and handlers, which are all linear in terms of their initialization processes. The primary bottlenecks include:
- **Health checks**: `health.NewHandler(mongoClient, sqliteClient)` and `backupSvc.StartScheduler()` involve periodic tasks.
- **Cron job scheduling**: The cron job setup for daily backups involves a context timeout mechanism.

#### Space Complexity and Memory Allocation
The function uses several goroutines and channels, which are managed well with proper context cancellation. However:
- **Resource Leaks**: Ensure all connections (`mongoClient`, `sqliteClient`) are properly closed in the event of errors or shutdowns.
- **Memory Usage**: The setup of multiple handlers and services can consume significant memory if not optimized.

#### Bottlenecks or Inefficiencies
1. **Redundant Operations**: The `godotenv.Load()` call is redundant as it's not used elsewhere, and the logger setup could be simplified.
2. **Blocking Calls in Async Contexts**: `backupSvc.StartScheduler()` and `backupSvc.SetupDailyBackup(cfg.Mongo.Database)` are blocking calls within an async context.

#### Optimization Opportunities
1. **Error Handling**: Centralize error handling to avoid redundant checks.
2. **Resource Management**: Ensure all database connections are closed properly, especially during shutdown.
3. **Cron Job Simplification**: Use a more efficient scheduling mechanism like `cron` or `go-cron`.

#### Resource Usage Concerns
- **Context Management**: Properly manage context cancellation for graceful shutdown.
- **Logging**: Ensure logs are not excessive and do not impact performance.

By addressing these areas, the function can be optimized to reduce overhead and improve overall efficiency.

---

*Generated by CodeWorm on 2026-02-21 17:19*
