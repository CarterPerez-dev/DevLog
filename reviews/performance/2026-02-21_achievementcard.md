# AchievementCard

**Type:** Performance Analysis
**Repository:** ios-test
**File:** red-recon/app/(app)/achievements.tsx
**Language:** tsx
**Lines:** 60-140
**Complexity:** 13.0

---

## Source Code

```tsx
function AchievementCard({
  id,
  isUnlocked,
}: {
  id: AchievementId
  isUnlocked: boolean
}): React.ReactElement {
  const achievement = ACHIEVEMENTS[id]
  const rarityColor = RARITY_COLORS[achievement.rarity]
  const rarityBg = RARITY_BG_COLORS[achievement.rarity]
  const rarityLabel = RARITY_LABELS[achievement.rarity]

  return (
    <Stack
      backgroundColor={isUnlocked ? '$bgSurface100' : '$bgSurface100'}
      borderWidth={1}
      borderColor={isUnlocked ? rarityColor : '$borderDefault'}
      borderRadius="$3"
      padding="$4"
      opacity={isUnlocked ? 1 : 0.5}
    >
      <XStack gap="$4" alignItems="flex-start">
        <Stack
          width={52}
          height={52}
          borderRadius="$2"
          backgroundColor={isUnlocked ? rarityBg : '$bgSurface200'}
          alignItems="center"
          justifyContent="center"
        >
          {isUnlocked ? (
            ICON_MAP[achievement.icon] ?? <Award size={24} color={colors.textDefault.val} />
          ) : (
            <Lock size={24} color={colors.textMuted.val} />
          )}
        </Stack>

        <YStack flex={1}>
          <XStack alignItems="center" gap="$2" marginBottom="$1">
            <Text
              fontSize={15}
              fontWeight="600"
              color={isUnlocked ? '$textDefault' : '$textMuted'}
              fontFamily="$heading"
            >
              {achievement.title}
            </Text>
          </XStack>

          <Text
            fontSize={12}
            color={isUnlocked ? '$textLight' : '$textMuted'}
            fontFamily="$body"
            lineHeight={17}
            marginBottom="$2"
          >
            {isUnlocked ? achievement.description : '???'}
          </Text>

          <Stack
            backgroundColor={isUnlocked ? `${rarityColor}20` : '$bgSurface200'}
            paddingVertical="$1"
            paddingHorizontal="$2"
            borderRadius="$1"
            alignSelf="flex-start"
          >
            <Text
              fontSize={10}
              fontWeight="700"
              color={isUnlocked ? rarityColor : '$textMuted'}
              fontFamily="$body"
              letterSpacing={0.5}
            >
              {rarityLabel}
            </Text>
          </Stack>
        </YStack>
      </XStack>
    </Stack>
  )
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The function has a time complexity of O(1), as it performs a fixed number of operations regardless of the input size.

#### Space Complexity
Space complexity is also O(1) since the memory used does not scale with the input size. However, there are potential bottlenecks:

- **Bottlenecks and Inefficiencies:**
  - The `ACHIEVEMENTS` array lookup (`ACHIEVEMENTS[id]`) could be costly if it's large.
  - Redundant re-computation of `rarityColor`, `rarityBg`, and `rarityLabel` for each render, even though they don't change frequently.

#### Optimization Opportunities
1. **Memoization:** Use React.memo or a custom hook to memoize the component when props do not change.
2. **Lazy Initialization:** If `ACHIEVEMENTS` is large, consider lazy loading or caching the achievement data.
3. **Conditional Rendering:** Simplify conditional rendering by combining similar conditions.

#### Resource Usage Concerns
- Ensure that `ICON_MAP`, `RARITY_COLORS`, and other global objects are properly initialized to avoid undefined behavior.
- Consider using a more efficient data structure for `ACHIEVEMENTS` if it's very large, such as an object with direct key access.

```tsx
const AchievementCard = React.memo(({ id, isUnlocked }) => {
  const achievement = ACHIEVEMENTS[id] ?? { icon: 'default', rarity: 'common' }
  const rarityColor = RARITY_COLORS[achievement.rarity]
  const rarityBg = RARITY_BG_COLORS[achievement.rarity]
  const rarityLabel = RARITY_LABELS[achievement.rarity]

  return (
    // ... (rest of the component)
  )
})
```

By applying these optimizations, you can improve both performance and maintainability.

---

*Generated by CodeWorm on 2026-02-21 23:42*
