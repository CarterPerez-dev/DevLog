# IdentityMutations.update_revenue_goals

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/core/foundation/repositories/identity_mutations.py
**Language:** python
**Lines:** 617-656
**Complexity:** 7.0

---

## Source Code

```python
async def update_revenue_goals(
        session: AsyncSession,
        data: dict
    ) -> RevenueGoal:
        """
        Update revenue goals - partial update supported

        Args:
            data: {paying_users_target, monthly_price, monthly_revenue_target, current_paying_users, note}
        """
        result = await session.execute(select(RevenueGoal).limit(1))
        revenue_goal = result.scalar_one_or_none()

        if not revenue_goal:
            identity = await session.execute(select(CoreIdentity).limit(1))
            revenue_goal = RevenueGoal(
                identity_id = identity.scalar_one().id,
                paying_users_target = 0,
                monthly_price = 0,
                monthly_revenue_target = 0,
                current_paying_users = 0,
            )
            session.add(revenue_goal)

        if "paying_users_target" in data:
            revenue_goal.paying_users_target = data["paying_users_target"]
        if "monthly_price" in data:
            revenue_goal.monthly_price = data["monthly_price"]
        if "monthly_revenue_target" in data:
            revenue_goal.monthly_revenue_target = data[
                "monthly_revenue_target"]
        if "current_paying_users" in data:
            revenue_goal.current_paying_users = data["current_paying_users"
                                                     ]
        if "note" in data:
            revenue_goal.note = data["note"]

        await session.flush()
        await session.refresh(revenue_goal)
        return revenue_goal
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of the function is \(O(1)\) for most operations, as it involves a fixed number of database queries and updates. However, the `session.execute` calls are costly due to potential round-trips to the database.

#### Space Complexity
Space complexity is also \(O(1)\), assuming that the input dictionary `data` does not grow significantly in size.

#### Bottlenecks or Inefficiencies
- **Redundant Query**: The function always executes a `select` query with `.limit(1)`, even if an existing `RevenueGoal` object is found.
- **Multiple Updates**: Multiple `if` checks for each field update are redundant, especially since the dictionary keys can be checked once.

#### Optimization Opportunities
- **Single Query Check**: Use `session.get()` to check if a `RevenueGoal` exists with a single query.
- **Batch Update**: Combine all updates into one transaction using `session.execute()` or ORM methods like `update()`.
  
```python
async def update_revenue_goals(
        session: AsyncSession,
        data: dict
    ) -> RevenueGoal:
    
    revenue_goal = await session.get(RevenueGoal, 1)  # Assuming an ID of 1 for simplicity
    
    if not revenue_goal:
        identity = await session.execute(select(CoreIdentity).limit(1))
        revenue_goal = RevenueGoal(
            identity_id=identity.scalar_one().id,
            paying_users_target=0,
            monthly_price=0,
            monthly_revenue_target=0,
            current_paying_users=0,
        )
        session.add(revenue_goal)
    
    for key, value in data.items():
        if hasattr(revenue_goal, key):
            setattr(revenue_goal, key, value)
    
    await session.flush()
    await session.refresh(revenue_goal)
    return revenue_goal
```

#### Resource Usage Concerns
- Ensure that the `AsyncSession` is properly managed to avoid resource leaks.
- Use context managers for sessions if they are not already being used.

```python
async with AsyncSession() as session:
    # Function call here
```

This approach reduces redundant queries and simplifies the update logic, improving both time and space efficiency.

---

*Generated by CodeWorm on 2026-02-21 18:04*
