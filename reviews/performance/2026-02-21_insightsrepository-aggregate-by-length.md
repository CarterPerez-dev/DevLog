# InsightsRepository.aggregate_by_length_range

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/analytics/facets/insights/repository.py
**Language:** python
**Lines:** 303-347
**Complexity:** 6.0

---

## Source Code

```python
async def aggregate_by_length_range(
        cls, session: AsyncSession
    ) -> dict[str, dict]:
        """Aggregate performance by video length ranges"""
        videos = await cls.get_all_videos(session)

        range_stats = defaultdict(lambda: {
            "videos": [],
            "total_views": 0,
            "total_engagement": 0,
            "total_watch_percentage": 0,
        })

        for video in videos:
            seconds = cls.convert_length_to_seconds(video.length)
            range_label = cls.get_length_range_label(seconds)
            engagement_rate = cls.calculate_engagement_rate(video)

            range_stats[range_label]["videos"].append(video)
            range_stats[range_label]["total_views"] += video.views
            range_stats[range_label]["total_engagement"] += engagement_rate
            range_stats[range_label]["total_watch_percentage"] += video.watched_full_video_percentage

        # Calculate averages and add min/max seconds
        result = {}
        for range_label, stats in range_stats.items():
            count = len(stats["videos"])
            # Extract min/max from range label (e.g., "1:00-1:30" -> 60, 90)
            if range_label == "3:00+":
                min_sec, max_sec = 180, 999
            else:
                parts = range_label.split("-")
                min_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[0].split(":"))))
                max_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[1].split(":"))))

            result[range_label] = {
                "min_seconds": min_sec,
                "max_seconds": max_sec,
                "video_count": count,
                "avg_views": stats["total_views"] / count,
                "avg_engagement_rate": stats["total_engagement"] / count,
                "avg_watch_percentage": stats["total_watch_percentage"] / count,
            }

        return result
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n \cdot m)\), where \(n\) is the number of videos, and \(m\) is the number of operations per video (e.g., converting length to seconds). This can be optimized.

**Space Complexity:** The space complexity is \(O(k + n)\), where \(k\) is the number of unique length ranges. The dictionary `range_stats` stores data for each video in memory, which could be reduced by processing videos directly into the final result.

**Bottlenecks and Inefficiencies:**
1. **Redundant Operations:** Converting `video.length` to seconds repeatedly within the loop can be costly.
2. **String Parsing:** Splitting and calculating time values from string labels is inefficient.
3. **Multiple Aggregations:** Repeatedly summing up views, engagement rates, and watch percentages in each iteration.

**Optimization Opportunities:**
1. **Memoize Length Conversion:** Use a cache to store the result of `cls.convert_length_to_seconds(video.length)` to avoid redundant calculations.
2. **Direct Calculation for Averages:** Compute averages directly within the loop instead of storing intermediate sums.
3. **String Formatting Optimization:** Simplify string parsing by using a dictionary mapping range labels to their corresponding time values.

**Resource Usage Concerns:**
- Ensure `AsyncSession` is properly managed and closed if necessary, though it appears to be handled correctly here.
- Consider batch processing or parallelization for very large datasets to improve performance.

---

*Generated by CodeWorm on 2026-02-21 18:24*
