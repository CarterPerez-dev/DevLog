# get_repos

**Type:** Performance Analysis
**Repository:** CodeWorm
**File:** dashboard/backend/api.py
**Language:** python
**Lines:** 109-155
**Complexity:** 7.0

---

## Source Code

```python
async def get_repos() -> list[RepoStatus]:
    config_dir = Path(os.environ.get("CODEWORM_CONFIG_DIR", "config"))
    repos_path = config_dir / "repos.yaml"

    repos: list[RepoStatus] = []
    if repos_path.exists():
        import yaml

        with repos_path.open() as f:
            data = yaml.safe_load(f) or {}

        db = _get_db_path()
        repo_counts: dict[str, int] = {}
        repo_last: dict[str, str] = {}

        if db.exists():
            with _get_conn() as conn:
                for row in conn.execute(
                        "SELECT source_repo, COUNT(*), MAX(documented_at) "
                        "FROM documented_snippets GROUP BY source_repo"
                ).fetchall():
                    repo_counts[row[0]] = row[1]
                    repo_last[row[0]] = row[2]

        for entry in data.get("repositories", []):
            from datetime import datetime

            name = entry.get("name", "")
            last_str = repo_last.get(name)
            last_dt = datetime.fromisoformat(last_str) if last_str else None

            repos.append(
                RepoStatus(
                    name = name,
                    path = str(entry.get("path",
                                         "")),
                    weight = entry.get("weight",
                                       5),
                    enabled = entry.get("enabled",
                                        True),
                    docs_generated = repo_counts.get(name,
                                                     0),
                    last_activity = last_dt,
                )
            )

    return repos
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n + m)\), where \(n\) is the number of entries in `repos.yaml` and \(m\) is the number of rows returned by the database query.

**Space Complexity:** The space complexity is \(O(k + r)\), where \(k\) is the number of unique repository names from the YAML file, and \(r\) is the number of repositories stored in memory. 

**Bottlenecks or Inefficiencies:**
1. **Blocking Calls:** `_get_conn()` might be a blocking call if it doesn't use an asynchronous database connection.
2. **Redundant Operations:** The `repos_path.exists()` check and subsequent file opening are redundant since the `open` context manager will handle this internally.
3. **N+1 Query Pattern:** The query fetches data for each repository, which can be optimized using a single query with a JOIN.

**Optimization Opportunities:**
1. Use an asynchronous database connection to avoid blocking calls.
2. Combine the YAML loading and database fetching into one loop to reduce redundant operations.
3. Optimize the SQL query by adding a `JOIN` or subquery to fetch all necessary data in one go.

**Resource Usage Concerns:**
- Ensure `_get_conn()` returns an asynchronous context manager for non-blocking behavior.
- Close any unclosed file handles properly, though Python's `with` statement should handle this automatically.

By addressing these points, you can significantly improve the performance and efficiency of your function.

---

*Generated by CodeWorm on 2026-03-02 08:59*
