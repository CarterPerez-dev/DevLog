# PayoutService.create_payout

**Type:** Performance Analysis
**Repository:** stripe-referral
**File:** src/stripe_referral/services/payout_service.py
**Language:** python
**Lines:** 142-213
**Complexity:** 6.0

---

## Source Code

```python
def create_payout(
        db: Session,
        tracking_id: int,
        adapter_type: str,
        recipient_data: dict[str,
                             Any],
    ) -> PayoutInfo:
        """
        Create a payout record for a tracking entry
        """
        tracking_repo = ReferralTrackingRepository(db)
        payout_repo = PayoutRepository(db)
        program_repo = ReferralProgramRepository(db)

        tracking = tracking_repo.get_by_id(tracking_id)
        if not tracking:
            raise TrackingNotFoundError(
                f"Tracking ID {tracking_id} not found",
                tracking_id = tracking_id,
            )

        existing_payout = payout_repo.get_by_tracking_id(tracking_id)
        if existing_payout:
            raise PayoutAlreadyExistsError(
                f"Payout already exists for tracking ID {tracking_id}",
                tracking_id = tracking_id,
            )

        program = program_repo.get_by_id(tracking.program_id)
        if not program:
            raise TrackingNotFoundError(
                f"Program ID {tracking.program_id} not found",
                program_id = tracking.program_id,
            )

        adapter = PayoutService._get_adapter(
            adapter_type,
            program.adapter_config
        )

        validation: RecipientValidation = adapter.validate_recipient(
            recipient_data
        )
        if not validation["valid"]:
            raise InvalidRecipientDataError(
                validation.get("error",
                               "Invalid recipient data"),
                recipient_data = recipient_data,
                adapter_type = adapter_type,
            )

        payout = payout_repo.create(
            user_id = tracking.referrer_user_id,
            tracking_id = tracking_id,
            amount = tracking.amount_earned,
            currency = tracking.currency,
            status = PayoutStatus.PENDING.value,
            adapter_type = adapter_type,
            recipient_data = recipient_data,
        )

        return PayoutInfo(
            id = payout.id,
            user_id = payout.user_id,
            amount = payout.amount,
            currency = payout.currency,
            status = payout.status,
            adapter_type = payout.adapter_type,
            processed_at = payout.processed_at.isoformat()
            if payout.processed_at else None,
            external_transaction_id = payout.external_transaction_id,
        )
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(1)\) for the core logic, but the actual performance is influenced by the repository methods (`get_by_id`, `get_by_tracking_id`, and `create`). These methods likely involve database queries, making the overall time complexity dependent on the efficiency of those operations.

**Space Complexity:** The space complexity is \(O(1)\), as the function uses a fixed amount of additional memory regardless of input size. However, the creation of objects like `validation` and `PayoutInfo` can consume some memory.

**Bottlenecks or Inefficiencies:**
- **Multiple Database Queries:** Three separate queries are made to the database (one for each repository). This could be optimized by fetching related data in a single query if possible.
- **Redundant Error Handling:** The function checks for `tracking` and `program` existence twice, which is redundant.

**Optimization Opportunities:**
- **Batch Queries:** Use JOINs or fetch related entities in a single database call to reduce the number of queries.
- **Error Handling Refinement:** Combine error handling logic to avoid redundancy. For example, raise an exception only once if any entity is not found.

**Resource Usage Concerns:**
- Ensure that all database connections are properly managed using context managers or connection pools to prevent resource leaks.
- Consider caching frequently accessed data like `tracking` and `program` to reduce the load on the database.

By addressing these points, you can improve both the performance and maintainability of the function.

---

*Generated by CodeWorm on 2026-02-21 20:57*
