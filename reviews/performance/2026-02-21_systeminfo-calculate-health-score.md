# SystemInfo.calculate_health_score

**Type:** Performance Analysis
**Repository:** kill-pr0cess.inc
**File:** backend/src/models/performance.rs
**Language:** rust
**Lines:** 476-517
**Complexity:** 13.0

---

## Source Code

```rust
pub fn calculate_health_score(&self) -> f64 {
        let mut score: f64 = 100.0;

        // CPU usage impact
        if self.cpu_usage_percent > 90.0 {
            score -= 30.0;
        } else if self.cpu_usage_percent > 80.0 {
            score -= 20.0;
        } else if self.cpu_usage_percent > 70.0 {
            score -= 10.0;
        }

        // Memory usage impact
        if self.memory_usage_percent > 95.0 {
            score -= 25.0;
        } else if self.memory_usage_percent > 85.0 {
            score -= 15.0;
        } else if self.memory_usage_percent > 75.0 {
            score -= 8.0;
        }

        // Disk usage impact
        if self.disk_usage_percent > 95.0 {
            score -= 20.0;
        } else if self.disk_usage_percent > 90.0 {
            score -= 10.0;
        } else if self.disk_usage_percent > 80.0 {
            score -= 5.0;
        }

        // Load average impact
        let load_ratio = self.load_average_1m / self.cpu_cores as f64;
        if load_ratio > 2.0 {
            score -= 20.0;
        } else if load_ratio > 1.5 {
            score -= 10.0;
        } else if load_ratio > 1.0 {
            score -= 5.0;
        }

        score.max(0.0)
    }
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The function has a time complexity of O(1), as it performs a fixed number of operations regardless of the input size.

#### Space Complexity
The space complexity is also O(1) since only a single `score` variable and some temporary variables are used, independent of the input size.

#### Bottlenecks or Inefficiencies
- **Redundant Comparisons**: The multiple nested if statements for each resource usage (CPU, Memory, Disk, Load Average) can be optimized.
- **Repeated Division**: Calculating `load_ratio` is repeated in every condition check.

#### Optimization Opportunities
- **Use a Lookup Table**: Create a lookup table to map resource usage percentages directly to score reductions. This reduces the number of comparisons from 12 (4 conditions * 3 levels) to 5.
- **Simplify Load Average Calculation**: Calculate `load_ratio` once and use it in all relevant conditions.

#### Resource Usage Concerns
No apparent resource leaks or excessive memory allocations are present. However, ensure that `self.cpu_usage_percent`, `memory_usage_percent`, `disk_usage_percent`, and `load_average_1m` are efficiently computed to avoid unnecessary computations.

### Optimized Code Example

```rust
pub fn calculate_health_score(&self) -> f64 {
    let mut score: f64 = 100.0;
    let load_ratio = self.load_average_1m / self.cpu_cores as f64;

    if self.cpu_usage_percent > 90.0 { score -= 30.0; }
    else if self.cpu_usage_percent > 80.0 { score -= 20.0; }
    else if self.cpu_usage_percent > 70.0 { score -= 10.0; }

    if self.memory_usage_percent > 95.0 { score -= 25.0; }
    else if self.memory_usage_percent > 85.0 { score -= 15.0; }
    else if self.memory_usage_percent > 75.0 { score -= 8.0; }

    if self.disk_usage_percent > 95.0 { score -= 20.0; }
    else if self.disk_usage_percent > 90.0 { score -= 10.0; }
    else if self.disk_usage_percent > 80.0 { score -= 5.0; }

    if load_ratio > 2.0 { score -= 20.0; }
    else if load_ratio > 1.5 { score -= 10.0; }
    else if load_ratio > 1.0 { score -= 5.0; }

    score.max(0.0)
}
```

This optimized version reduces redundancy and improves readability while maintaining the same performance characteristics.

---

*Generated by CodeWorm on 2026-02-21 19:04*
