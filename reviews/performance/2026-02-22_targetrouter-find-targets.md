# TargetRouter.find_targets

**Type:** Performance Analysis
**Repository:** CodeWorm
**File:** codeworm/analysis/targets.py
**Language:** python
**Lines:** 640-684
**Complexity:** 9.0

---

## Source Code

```python
def find_targets(
        self,
        doc_type: DocType,
        repo: RepoEntry,
        limit: int = 20,
    ) -> list[DocumentationTarget]:
        if doc_type == DocType.FUNCTION_DOC:
            candidates = self.perspective_finder.analyzer.find_candidates(
                repo = repo,
                limit = limit,
            )
            return [
                DocumentationTarget(
                    doc_type = DocType.FUNCTION_DOC,
                    snippet = c.snippet,
                    source_context = c.snippet.source,
                    metadata = {
                        "relative_path": str(c.scanned_file.relative_path)
                    },
                ) for c in candidates
            ]

        if doc_type == DocType.FILE_DOC:
            return self.file_finder.find(repo, limit)

        if doc_type == DocType.CLASS_DOC:
            return self.class_finder.find(repo, limit)

        if doc_type == DocType.MODULE_DOC:
            return self.module_finder.find(repo, limit)

        if doc_type == DocType.CODE_EVOLUTION:
            return self.evolution_finder.find(repo, limit)

        if doc_type == DocType.PATTERN_ANALYSIS:
            return self.pattern_finder.find(repo, limit)

        if doc_type in (
                DocType.SECURITY_REVIEW,
                DocType.PERFORMANCE_ANALYSIS,
                DocType.TIL,
        ):
            return self.perspective_finder.find(repo, doc_type, limit)

        return []
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of candidates returned by each finder method, as it iterates over `candidates` to construct `DocumentationTarget` objects.

**Space Complexity:** The space complexity is also \(O(n)\) due to the list comprehension that creates `DocumentationTarget` instances for each candidate. Memory usage can be optimized by directly returning the result from the finders without intermediate lists.

**Bottlenecks and Inefficiencies:**
- **Redundant Iteration:** The function iterates over a potentially large number of candidates, even if only one type is requested.
- **Unnecessary List Construction:** Creating `DocumentationTarget` objects for each candidate can be costly. Directly returning the result from the finder methods could reduce overhead.

**Optimization Opportunities:**
- **Direct Return:** Modify the function to directly return the results from the appropriate finder method, reducing unnecessary list construction and iteration.
  ```python
  def find_targets(
          self,
          doc_type: DocType,
          repo: RepoEntry,
          limit: int = 20,
      ) -> list[DocumentationTarget]:
      if doc_type == DocType.FUNCTION_DOC:
          return [
              DocumentationTarget(
                  doc_type=DocType.FUNCTION_DOC,
                  snippet=c.snippet,
                  source_context=c.snippet.source,
                  metadata={"relative_path": str(c.scanned_file.relative_path)},
              )
              for c in self.perspective_finder.analyzer.find_candidates(repo, limit)
          ]

      # ... other cases ...

      return []
  ```

**Resource Usage Concerns:**
- Ensure that `find` methods from different finders handle large datasets efficiently and do not block or leak resources. Use context managers where necessary to ensure proper resource cleanup.

By optimizing the function as suggested, you can reduce unnecessary operations and improve overall performance.

---

*Generated by CodeWorm on 2026-02-22 09:08*
