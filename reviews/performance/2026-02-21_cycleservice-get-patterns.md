# CycleService.get_patterns

**Type:** Performance Analysis
**Repository:** ios-test
**File:** fastapi/app/cycle/service.py
**Language:** python
**Lines:** 267-350
**Complexity:** 17.0

---

## Source Code

```python
async def get_patterns(self, user_id: UUID) -> CyclePattern:
        """
        Analyze historical patterns
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        period_logs = await PeriodLogRepository.get_actual_logs(
            self.session,
            partner.id,
            limit = 12,
        )

        cycle_lengths = [
            log.cycle_length for log in period_logs
            if log.cycle_length is not None
        ]

        if cycle_lengths:
            avg_cycle = sum(cycle_lengths) / len(cycle_lengths)
            cycle_range = (min(cycle_lengths), max(cycle_lengths))
        else:
            avg_cycle = float(partner.average_cycle_length)
            cycle_range = (partner.average_cycle_length, partner.average_cycle_length)

        period_lengths = []
        for log in period_logs:
            if log.end_date:
                length = (log.end_date - log.start_date).days + 1
                period_lengths.append(length)

        avg_period = (
            sum(period_lengths) / len(period_lengths)
            if period_lengths
            else float(partner.average_period_length)
        )

        daily_logs = await DailyLogRepository.get_by_partner_id(
            self.session,
            partner.id,
            limit = 90,
        )

        symptoms_by_phase: dict[str, list[str]] = defaultdict(list)
        mood_counts_by_phase: dict[str, dict[str, int]] = defaultdict(lambda: defaultdict(int))

        for log in daily_logs:
            if not partner.last_period_start:
                continue

            days_since = (log.log_date - partner.last_period_start).days + 1
            if days_since <= 0:
                continue

            cycle_day = ((days_since - 1) % partner.average_cycle_length) + 1
            phase = self._get_phase(cycle_day, partner.average_cycle_length)
            phase_key = phase.value

            for symptom in log.symptoms:
                if symptom not in symptoms_by_phase[phase_key]:
                    symptoms_by_phase[phase_key].append(symptom)

            if log.mood:
                mood_counts_by_phase[phase_key][log.mood.value] += 1

        common_symptoms = {
            phase: symptoms[:5] for phase, symptoms in symptoms_by_phase.items()
        }

        mood_trends: dict[str, str | None] = {}
        for phase, counts in mood_counts_by_phase.items():
            if counts:
                mood_trends[phase] = max(counts, key = counts.get)
            else:
                mood_trends[phase] = None

        return CyclePattern(
            average_cycle_length = round(avg_cycle, 1),
            cycle_length_range = cycle_range,
            average_period_length = round(avg_period, 1),
            common_symptoms_by_phase = common_symptoms,
            mood_trends_by_phase = mood_trends,
        )
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of period logs and daily logs. The primary bottlenecks are iterating over the `period_logs` and `daily_logs`, which can be costly if these lists are large.

**Space Complexity:** The space complexity is also \(O(n)\) due to storing `cycle_lengths`, `period_lengths`, `symptoms_by_phase`, and `mood_counts_by_phase`. This can lead to high memory usage for large datasets.

**Bottlenecks or Inefficiencies:**
1. **Redundant Operations:** The calculation of `avg_cycle` and `cycle_range` is repeated if `cycle_lengths` are empty.
2. **Unnecessary Iterations:** The loop over `daily_logs` can be optimized by using more efficient data structures like sets for symptoms, which would reduce the time complexity from \(O(n^2)\) to \(O(n)\).
3. **Blocking Calls in Async Contexts:** Ensure that all database calls are properly asynchronous and not blocking.

**Optimization Opportunities:**
1. Use `async` comprehensions or list comprehensions with `async for` where applicable.
2. Utilize sets for symptoms to avoid redundant checks.
3. Cache results of `self._get_phase` if it is a time-consuming operation.

**Resource Usage Concerns:**
- Ensure that database connections are properly managed using context managers (`async with`).
- Handle exceptions and edge cases, such as empty logs or missing data, to prevent runtime errors.

By addressing these points, you can significantly improve the performance and efficiency of your function.

---

*Generated by CodeWorm on 2026-02-21 23:26*
