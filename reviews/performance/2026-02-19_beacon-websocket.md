# beacon_websocket

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/c2-beacon/backend/app/beacon/router.py
**Language:** python
**Lines:** 93-169
**Complexity:** 11.0

---

## Source Code

```python
async def beacon_websocket(ws: WebSocket) -> None:
    """
    WebSocket endpoint for beacon connections
    """
    await ws.accept()

    registry: BeaconRegistry = ws.app.state.registry
    task_manager: TaskManager = ws.app.state.task_manager
    ops_manager = ws.app.state.ops_manager
    beacon_id: str | None = None

    try:
        raw = await ws.receive_text()
        message = unpack(raw, settings.XOR_KEY)

        if message.type != MessageType.REGISTER:
            await ws.close(code = 4001, reason = "Expected REGISTER message")
            return

        meta = BeaconMeta.model_validate(message.payload)
        beacon_id = message.payload.get("id", str(uuid.uuid4()))

        async with get_db() as db:
            await registry.register(beacon_id, meta, ws, db)

        logger.info("Beacon registered: %s (%s)", beacon_id, meta.hostname)

        if hasattr(ops_manager, "broadcast"):
            beacon_record = meta.model_dump()
            beacon_record["id"] = beacon_id
            await ops_manager.broadcast(
                {
                    "type": "beacon_connected",
                    "payload": beacon_record,
                }
            )

        send_task = asyncio.create_task(_send_tasks(ws, beacon_id, task_manager))
        recv_task = asyncio.create_task(
            _receive_messages(ws,
                              beacon_id,
                              registry,
                              task_manager,
                              ops_manager)
        )

        done, pending = await asyncio.wait(
            [send_task, recv_task],
            return_when=asyncio.FIRST_COMPLETED,
        )

        for task in pending:
            task.cancel()

        for task in done:
            if (exc := task.exception()) is not None:
                raise exc

    except WebSocketDisconnect:
        logger.info("Beacon disconnected: %s", beacon_id)
    except ValueError as exc:
        logger.warning("Protocol error from beacon %s: %s", beacon_id, exc)
    finally:
        if beacon_id:
            async with get_db() as db:
                await registry.unregister(beacon_id, db)
            task_manager.remove_queue(beacon_id)

            if hasattr(ops_manager, "broadcast"):
                await ops_manager.broadcast(
                    {
                        "type": "beacon_disconnected",
                        "payload": {
                            "id": beacon_id
                        },
                    }
                )
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of tasks managed by `task_manager` and `ops_manager`. The primary bottlenecks are database operations (`get_db`, `registry.register/unregister`) and task creation/cancellation.

**Space Complexity:** The space complexity is \(O(1)\) for local variables, but the function creates multiple tasks (`send_task`, `recv_task`) which can consume significant memory if many beacons connect simultaneously. The `asyncio.wait` call also uses additional resources to manage coroutines.

**Bottlenecks and Inefficiencies:**
- **Database Operations:** `registry.register/unregister` calls are made within the try block, but they could be optimized by batching operations or using transactions.
- **Redundant Task Creation:** Creating tasks for sending and receiving messages can lead to unnecessary overhead. Consider merging these into a single task if possible.
- **Resource Management:** The function uses `asyncio.wait`, which might not be the most efficient way to handle concurrent tasks, especially with many connections.

**Optimization Opportunities:**
- Use database transactions to batch operations for better performance and consistency.
- Merge sending and receiving tasks into one to reduce overhead.
- Implement proper error handling and logging to avoid unnecessary exceptions.

**Resource Usage Concerns:**
- Ensure that `get_db()` is efficient and does not block the event loop.
- Consider using connection pooling in database interactions to manage resources more efficiently.

---

*Generated by CodeWorm on 2026-02-19 08:48*
