# operator_websocket

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/c2-beacon/backend/app/ops/router.py
**Language:** python
**Lines:** 45-110
**Complexity:** 7.0

---

## Source Code

```python
async def operator_websocket(ws: WebSocket) -> None:
    """
    WebSocket endpoint for operator dashboard connections
    """
    ops_manager: OpsManager = ws.app.state.ops_manager
    registry: BeaconRegistry = ws.app.state.registry
    task_manager: TaskManager = ws.app.state.task_manager

    await ops_manager.connect(ws)

    try:
        async with get_db() as db:
            beacons = await registry.get_all(db)

        beacon_list = []
        for b in beacons:
            record = b.model_dump()
            record["active"] = registry.is_active(b.id)
            beacon_list.append(record)

        await ws.send_text(json.dumps({
            "type": "beacon_list",
            "payload": beacon_list,
        }))

        while True:
            raw = await ws.receive_text()
            data = json.loads(raw)

            if data.get("type") == "submit_task":
                payload = data["payload"]
                task = TaskRecord(
                    id = str(uuid.uuid4()),
                    beacon_id = payload["beacon_id"],
                    command = CommandType(payload["command"]),
                    args = payload.get("args"),
                )

                async with get_db() as db:
                    await task_manager.submit(task, db)

                await ws.send_text(
                    json.dumps(
                        {
                            "type": "task_submitted",
                            "payload": {
                                "local_id": payload.get("local_id"),
                                "task_id": task.id,
                            },
                        }
                    )
                )

                logger.info(
                    "Task %s (%s) submitted for beacon %s",
                    task.id,
                    task.command,
                    task.beacon_id,
                )

    except WebSocketDisconnect:
        pass
    except json.JSONDecodeError:
        logger.warning("Invalid JSON from operator")
    finally:
        ops_manager.disconnect(ws)
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n + m)\), where \(n\) is the number of beacons retrieved from the database, and \(m\) is the number of tasks submitted during the session. The `get_all` call is costly due to potential N+1 query patterns.

**Space Complexity:** The primary space concern is the creation of `beacon_list`, which can grow large if there are many beacons. This could lead to increased memory usage, especially in long-running sessions.

**Bottlenecks and Inefficiencies:**
- **N+1 Query Pattern:** The call to `registry.get_all(db)` fetches all beacons without a join query, leading to multiple database hits.
- **Redundant Database Connections:** Opening a new database connection for each task submission is inefficient. Consider using a single connection or connection pooling.
- **Blocking Calls in Async Context:** Using `get_db()` within the loop can block the event loop.

**Optimization Opportunities:**
- Use a single database connection to reduce overhead.
- Optimize the beacon retrieval by fetching related data in a single query.
- Cache frequently accessed data, such as active beacons, using Redis or another cache system.

**Resource Usage Concerns:**
- Ensure proper handling of `WebSocketDisconnect` and close any unclosed connections or file handles.
- Use context managers for database connections to ensure they are properly closed.

### Suggested Optimizations
1. **Fetch Related Data in a Single Query:** Modify the `registry.get_all(db)` call to include related data in one query.
2. **Use Connection Pooling:** Implement connection pooling to manage database connections efficiently.
3. **Cache Active Beacons:** Use Redis or another caching mechanism to store frequently accessed beacon states.

By addressing these issues, you can significantly improve the performance and efficiency of your WebSocket endpoint.

---

*Generated by CodeWorm on 2026-02-28 17:35*
