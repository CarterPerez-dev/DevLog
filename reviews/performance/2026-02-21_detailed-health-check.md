# detailed_health_check

**Type:** Performance Analysis
**Repository:** vuemantics
**File:** backend/routers/v1/health.py
**Language:** python
**Lines:** 45-91
**Complexity:** 9.0

---

## Source Code

```python
async def detailed_health_check() -> HealthDetailedResponse:
    """
    Detailed health check including database connectivity

    healthy, degraded, or unhealthy
    """
    db_status = HealthStatus.UNHEALTHY
    redis_status = None

    try:
        await db.fetchval("SELECT 1")
        db_status = HealthStatus.HEALTHY
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        db_status = HealthStatus.UNHEALTHY

    if settings.redis_url:
        try:
            redis_client = redis.from_url(
                settings.redis_url,
                decode_responses = settings.redis_decode_responses
            )
            await redis_client.ping()
            await redis_client.close()
            redis_status = HealthStatus.HEALTHY
        except Exception as e:
            logger.error(f"Redis health check failed: {e}")
            redis_status = HealthStatus.UNHEALTHY

    services = [db_status,
                redis_status] if redis_status is not None else [db_status]
    healthy_count = sum(1 for s in services if s == HealthStatus.HEALTHY)

    if healthy_count == len(services):
        overall = HealthStatus.HEALTHY
    elif healthy_count > 0:
        overall = HealthStatus.DEGRADED
    else:
        overall = HealthStatus.UNHEALTHY

    return HealthDetailedResponse(
        status = overall,
        environment = settings.environment,
        version = config.APP_VERSION,
        database = db_status,
        redis = redis_status,
    )
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is \(O(n)\), where \(n\) is the number of services checked (currently 2: database and Redis). Each service check involves a network call, which can be expensive.

**Space Complexity:** The space complexity is \(O(1)\) as no additional data structures grow with input size. However, creating `redis_client` and handling exceptions consume minor resources.

**Bottlenecks or Inefficiencies:**
- **Redundant Operations:** The `sum()` function iterates over the services list to count healthy statuses, which is unnecessary since you can directly compare lengths.
- **Blocking Calls in Async Contexts:** `await redis_client.ping()` and `await redis_client.close()` are blocking calls within an async context, potentially causing delays.

**Optimization Opportunities:**
- Replace `sum(1 for s in services if s == HealthStatus.HEALTHY)` with a direct comparison of lengths:
  ```python
  healthy_count = len([s for s in services if s == HealthStatus.HEALTHY])
  ```
- Use async context managers to avoid explicit calls to close resources.

**Resource Usage Concerns:**
- Ensure `redis_client` is properly closed using an `async with` statement to prevent resource leaks:
  ```python
  try:
      async with redis.from_url(...) as redis_client:
          await redis_client.ping()
  except Exception as e:
      logger.error(f"Redis health check failed: {e}")
      redis_status = HealthStatus.UNHEALTHY
  ```

By addressing these points, the code will be more efficient and maintainable.

---

*Generated by CodeWorm on 2026-02-21 22:51*
