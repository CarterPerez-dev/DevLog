# lifespan

**Type:** Performance Analysis
**Repository:** vuemantics
**File:** backend/core/lifespan.py
**Language:** python
**Lines:** 24-83
**Complexity:** 3.0

---

## Source Code

```python
async def lifespan(_app: FastAPI) -> AsyncIterator[None]:
    """
    Manage application lifecycle

    Handles startup and shutdown events for database connections
    and any other resources that need initialization/cleanup
    """
    logger.info(
        f"Starting {config.settings.app_name} in {config.settings.environment} mode"
    )

    try:
        await init_db()
        logger.info("Database connection pool initialized")

        # Foreign key dependency
        await UploadBatch.ensure_table_exists()
        logger.info("UploadBatch table initialized")

        version = await db.fetchval(
            "SELECT extversion FROM pg_extension WHERE extname = 'vector'"
        )
        if version:
            logger.info(f"pgvector {version} is ready")
        else:
            logger.warning(
                "pgvector extension not found - vector search will fail"
            )

        await init_redis()
        logger.info("Redis connection pool initialized")

        await redis_pool.client.ping()  # type: ignore[union-attr]
        logger.info("Redis is ready")

        init_manager()
        init_publisher()

        await get_publisher().start()
        logger.info("WebSocket publisher started")

    except Exception as e:
        logger.error(f"Startup failed: {e}")
        raise

    yield

    logger.info("Shutting down application")

    await get_manager().disconnect_all()
    logger.info("All WebSocket connections closed")

    await get_publisher().stop()
    logger.info("WebSocket publisher stopped")

    await close_redis()
    logger.info("Redis connection pool closed")

    await close_db()
    logger.info("Database connection pool closed")
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity of the `lifespan` function is O(1), as it performs a fixed number of operations regardless of input size.

**Space Complexity:** The space complexity is also O(1) since no additional data structures are created that scale with input size. However, there's an implicit use of event loops and asynchronous context managers which can impact memory usage during the execution.

**Bottlenecks or Inefficiencies:**
- **Redundant Operations:** `await redis_pool.client.ping()` is unnecessary if you're confident the connection is active.
- **Blocking Calls in Async Contexts:** Ensure that all database and Redis operations are truly asynchronous. If any synchronous calls are made, they can block the event loop.

**Optimization Opportunities:**
- Remove redundant checks like `redis_pool.client.ping()`.
- Use `contextlib.asynccontextmanager` for resource management to ensure proper cleanup.
- Consider using connection pooling more efficiently by reusing connections where possible.

**Resource Usage Concerns:**
- Ensure all database and Redis connections are properly closed. The use of context managers (`async with`) can help manage resources automatically.
- Log messages should be minimized during critical operations to avoid performance overhead.

By addressing these points, you can improve the efficiency and reliability of your application's startup and shutdown processes.

---

*Generated by CodeWorm on 2026-02-21 23:01*
