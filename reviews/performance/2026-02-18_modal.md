# Modal

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/components/UI/Modal.tsx
**Language:** tsx
**Lines:** 18-117
**Complexity:** 16.0

---

## Source Code

```tsx
function Modal(props: ModalProps): JSX.Element {
  const size = (): Size => props.size ?? "md"
  const closeOnOverlayClick = (): boolean => props.closeOnOverlayClick ?? true
  const showCloseButton = (): boolean => props.showCloseButton ?? true

  const handleOverlayClick = (e: MouseEvent): void => {
    if (e.target === e.currentTarget && closeOnOverlayClick()) {
      props.onClose()
    }
  }

  const handleKeyDown = (e: KeyboardEvent): void => {
    if (e.key === "Escape") {
      props.onClose()
    }
  }

  createEffect(() => {
    if (props.isOpen) {
      document.addEventListener("keydown", handleKeyDown)
      document.body.style.overflow = "hidden"
    }

    onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown)
      document.body.style.overflow = ""
    })
  })

  const handleOverlayKeyDown = (e: KeyboardEvent): void => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault()
      if (closeOnOverlayClick()) {
        props.onClose()
      }
    }
  }

  return (
    <Show when={props.isOpen}>
      <div
        class="fixed inset-0 z-50 flex items-center justify-center p-4"
        role="button"
        tabIndex={0}
        onClick={handleOverlayClick}
        onKeyDown={handleOverlayKeyDown}
        aria-label="Close modal overlay"
      >
        <div class="absolute inset-0 bg-black/80 animate-fade-in" />

        <div
          class={`
            relative z-10 w-full
            bg-black border-4 border-orange
            shadow-[8px_8px_0_var(--color-orange)]
            animate-scale-in
            ${SIZE_CLASSES[size()]}
          `}
          role="dialog"
          aria-modal="true"
          aria-labelledby={props.title ? "modal-title" : undefined}
        >
          <Show when={(props.title !== undefined && props.title !== "") || showCloseButton()}>
            <div class="flex items-start justify-between p-4 border-b-2 border-orange">
              <div class="flex-1">
                <Show when={props.title}>
                  <h2
                    id="modal-title"
                    class="font-pixel text-sm text-orange uppercase"
                  >
                    {props.title}
                  </h2>
                </Show>
                <Show when={props.description}>
                  <p class="font-pixel text-[10px] text-gray mt-1">
                    {props.description}
                  </p>
                </Show>
              </div>

              <Show when={showCloseButton()}>
                <IconButton
                  icon={<CloseIcon />}
                  ariaLabel="Close modal"
                  onClick={props.onClose}
                  size="sm"
                  variant="ghost"
                />
              </Show>
            </div>
          </Show>

          <div class="p-4">
            {props.children}
          </div>
        </div>
      </div>
    </Show>
  )
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of the `Modal` component is primarily driven by event listeners and conditional checks. The most costly operations are:
- Adding and removing event listeners in `createEffect`, which has a time complexity of O(1) but can be called multiple times.
- Conditional rendering with `Show` components, which incurs an overhead for each condition check.

#### Space Complexity
The space complexity is moderate due to the use of event listeners and conditional checks. The main memory concerns are:
- Event listener registration and removal in `createEffect`, which could lead to a small but non-negligible memory footprint.
- Conditional rendering with `Show` components, which may cause unnecessary re-renders.

#### Bottlenecks or Inefficiencies
1. **Redundant Checks**: The `closeOnOverlayClick` and `showCloseButton` functions are called multiple times within the component lifecycle without memoization.
2. **Event Listener Overhead**: Adding and removing event listeners in `createEffect` can be costly, especially if this function is triggered frequently.

#### Optimization Opportunities
1. **Memoize Conditional Checks**: Use React's `useMemo` or `useCallback` to memoize `closeOnOverlayClick` and `showCloseButton`.
2. **Optimize Event Listeners**: Ensure event listeners are only added when necessary by checking the component state more efficiently.
3. **Reduce Re-renders**: Optimize conditional rendering with `Show` components to minimize unnecessary re-renders.

#### Resource Usage Concerns
- Ensure that event listeners are properly cleaned up in `onCleanup` to avoid memory leaks.
- Consider using a more efficient way to handle conditional rendering, such as using custom hooks or refactoring the logic to reduce re-renders.

---

*Generated by CodeWorm on 2026-02-18 08:56*
