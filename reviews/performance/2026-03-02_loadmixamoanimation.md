# loadMixamoAnimation

**Type:** Performance Analysis
**Repository:** angelamos-3d
**File:** frontend/src/lib/animation/loadMixamoAnimation.ts
**Language:** typescript
**Lines:** 11-87
**Complexity:** 7.0

---

## Source Code

```typescript
async function loadMixamoAnimation(
	url: string,
	vrm: VRM,
): Promise<THREE.AnimationClip> {
	const loader = new FBXLoader();
	const asset = await loader.loadAsync(url);

	const clip = THREE.AnimationClip.findByName(asset.animations, "mixamo.com");
	if (!clip) throw new Error("mixamo.com animation clip not found");

	const tracks: THREE.KeyframeTrack[] = [];

	const restRotationInverse = new THREE.Quaternion();
	const parentRestWorldRotation = new THREE.Quaternion();
	const _quatA = new THREE.Quaternion();

	const motionHipsHeight =
		asset.getObjectByName("mixamorigHips")?.position.y ?? 1;
	const vrmHipsY = vrm.humanoid?.normalizedRestPose?.hips?.position?.[1] ?? 1;
	const hipsPositionScale = vrmHipsY / motionHipsHeight;

	clip.tracks.forEach((track) => {
		const trackSplitted = track.name.split(".");
		const mixamoRigName = trackSplitted[0];
		const vrmBoneName = mixamoVRMRigMap[mixamoRigName];
		const vrmNodeName = vrm.humanoid?.getNormalizedBoneNode(vrmBoneName)?.name;
		const mixamoRigNode = asset.getObjectByName(mixamoRigName);

		if (vrmNodeName != null && mixamoRigNode != null) {
			const propertyName = trackSplitted[1];

			mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
			mixamoRigNode.parent?.getWorldQuaternion(parentRestWorldRotation);

			if (track instanceof THREE.QuaternionKeyframeTrack) {
				for (let i = 0; i < track.values.length; i += 4) {
					const flatQuaternion = track.values.slice(i, i + 4);

					_quatA.fromArray(flatQuaternion);
					_quatA
						.premultiply(parentRestWorldRotation)
						.multiply(restRotationInverse);
					_quatA.toArray(flatQuaternion);

					flatQuaternion.forEach((v, index) => {
						track.values[index + i] = v;
					});
				}

				tracks.push(
					new THREE.QuaternionKeyframeTrack(
						`${vrmNodeName}.${propertyName}`,
						track.times,
						track.values.map((v, i) =>
							vrm.meta?.metaVersion === "0" && i % 2 === 0 ? -v : v,
						),
					),
				);
			} else if (track instanceof THREE.VectorKeyframeTrack) {
				const value = track.values.map(
					(v, i) =>
						(vrm.meta?.metaVersion === "0" && i % 3 !== 1 ? -v : v) *
						hipsPositionScale,
				);
				tracks.push(
					new THREE.VectorKeyframeTrack(
						`${vrmNodeName}.${propertyName}`,
						track.times,
						value,
					),
				);
			}
		}
	});

	return new THREE.AnimationClip("vrmAnimation", clip.duration, tracks);
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of `loadMixamoAnimation` is primarily determined by the number of bones in the VRM model, as it iterates over each track and bone. The function has a nested loop structure where each keyframe track is processed for every bone, leading to an overall complexity of \(O(n \times m)\), where \(n\) is the number of tracks and \(m\) is the number of bones.

#### Space Complexity
The space complexity is influenced by the creation of multiple temporary variables and arrays. The `tracks` array stores new keyframe tracks, which can grow significantly if there are many bones and tracks. This could lead to high memory usage, especially for complex VRM models.

#### Bottlenecks or Inefficiencies
1. **Redundant Operations**: The `restRotationInverse` and `parentRestWorldRotation` quaternions are recalculated in each iteration of the loop.
2. **Unnecessary Iterations**: The loop over `track.values` to modify quaternion values is redundant since it can be done more efficiently.
3. **Blocking Calls**: The function uses `await`, but there are no blocking calls that could be improved.

#### Optimization Opportunities
1. **Cache Quaternion Calculations**: Cache the results of `restRotationInverse` and `parentRestWorldRotation` to avoid recalculating them in each iteration.
2. **Optimize Loop Operations**: Instead of modifying `track.values` directly, consider creating a new array with transformed values to reduce side effects.

#### Resource Usage Concerns
- Ensure that all connections or file handles are properly closed if used.
- Consider caching the VRM model and animations to avoid repeated loading from the same URL.

By addressing these points, you can improve both the performance and memory efficiency of the function.

---

*Generated by CodeWorm on 2026-03-02 08:34*
