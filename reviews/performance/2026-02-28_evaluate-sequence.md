# _evaluate_sequence

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/siem-dashboard/backend/app/engine/correlation.py
**Language:** python
**Lines:** 212-254
**Complexity:** 9.0

---

## Source Code

```python
def _evaluate_sequence(
    rule: CorrelationRule,
    event_data: dict[str, Any],
    state: CorrelationState,
    rule_id: str,
    group_key: str,
) -> EvaluationResult | None:
    """
    Fire when all steps of a sequence are observed within window for a group
    """
    conditions = rule.conditions
    steps = conditions.get("steps", [])

    matched_step = None
    for idx, step in enumerate(steps):
        step_filter = step.get("event_filter", {})
        if _matches_filter(event_data, step_filter):
            matched_step = idx
            break

    if matched_step is None:
        return None

    event_id = event_data.get("id", "")
    state.record_event(
        rule_id, group_key, event_id, event_data,
        step_index=matched_step,
    )

    window_seconds = conditions.get("window_seconds", 0)
    entries = state.get_window(rule_id, group_key, window_seconds)

    for idx, step in enumerate(steps):
        required_count = step.get("count", 1)
        step_entries = [e for e in entries if e.step_index == idx]
        if len(step_entries) < required_count:
            return None

    state.mark_fired(rule_id, group_key)
    return EvaluationResult(
        matched_event_ids=[e.event_id for e in entries],
        group_value=group_key,
    )
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of `_evaluate_sequence` is \(O(n \times m)\), where \(n\) is the number of steps in the sequence and \(m\) is the number of entries in the window. The primary bottleneck is the nested loop that checks if each step has been matched within the window.

#### Space Complexity
The space complexity is \(O(m + k)\), where \(k\) is the size of `steps`. The main memory usage comes from storing the `entries` list and the state records.

#### Bottlenecks or Inefficiencies
1. **Nested Loops**: The nested loop to check if each step has been matched within the window can be costly, especially for large windows.
2. **Redundant Checks**: The function checks if a step filter matches in every iteration of `steps`, which may not be necessary.

#### Optimization Opportunities
1. **Memoization**: Cache the results of `_matches_filter` to avoid redundant checks.
2. **Early Exit**: If any condition fails, return early instead of processing all steps.
3. **Efficient Window Retrieval**: Ensure that `state.get_window` is optimized for quick access by step index.

#### Resource Usage Concerns
- **Unclosed Connections/Handles**: Ensure that all database connections and file handles are properly closed in the calling context or use context managers.
- **Memory Leaks**: Avoid storing large lists like `entries` if not necessary, especially in long-running processes.

By implementing these optimizations, you can significantly improve the performance of `_evaluate_sequence`.

---

*Generated by CodeWorm on 2026-02-28 17:17*
