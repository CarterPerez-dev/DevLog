# FetchVersions

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/simple-vulnerability-scanner/internal/pypi/client.go
**Language:** go
**Lines:** 76-137
**Complexity:** 12.0

---

## Source Code

```go
func (c *Client) FetchVersions(
	ctx context.Context,
	name string,
) ([]string, error) {
	normalized := NormalizeName(name)

	entry, hit := c.cache.Get(normalized)
	if hit && c.cache.IsFresh(entry) {
		return entry.Versions, nil
	}

	url := simpleAPIBase + normalized + "/"
	req, err := http.NewRequestWithContext(
		ctx, http.MethodGet, url, nil,
	)
	if err != nil {
		return nil, fmt.Errorf("build request for %s: %w", name, err)
	}
	req.Header.Set("Accept", simpleAPIAccept)
	req.Header.Set("User-Agent", c.userAgent)

	if entry != nil && entry.ETag != "" {
		req.Header.Set("If-None-Match", entry.ETag)
	}

	resp, err := c.doWithRetry(ctx, req)
	if err != nil {
		if entry != nil {
			return entry.Versions, nil
		}
		return nil, fmt.Errorf("fetch %s: %w", name, err)
	}
	defer func() { _ = resp.Body.Close() }() //nolint:errcheck

	switch resp.StatusCode {
	case http.StatusNotModified:
		c.cache.Touch(normalized)
		return entry.Versions, nil

	case http.StatusNotFound:
		return nil, fmt.Errorf(
			"package %q not found on PyPI", name,
		)

	case http.StatusOK:
		var result simpleAPIResponse
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, fmt.Errorf("decode %s: %w", name, err)
		}
		_ = c.cache.Set(normalized, &CacheEntry{ //nolint:errcheck
			ETag:     resp.Header.Get("ETag"),
			Versions: result.Versions,
			CachedAt: time.Now(),
		})
		return result.Versions, nil

	default:
		return nil, fmt.Errorf(
			"PyPI returned %d for %s", resp.StatusCode, name,
		)
	}
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is primarily determined by the HTTP request and response handling, which is `O(1)` for cache checks but can be `O(n)` if the cache misses and a network call is made.

**Space Complexity:** The space complexity is minimal due to local variable usage. However, storing large responses in memory could be an issue.

**Bottlenecks:**
- **HTTP Request Overhead:** Each request incurs significant overhead, especially for cache misses.
- **JSON Decoding:** If the response body is large, JSON decoding can be costly.
- **Error Handling:** Multiple error checks and handling can introduce inefficiencies.

**Optimization Opportunities:**
1. **Use `http.Client` with Persistent Connections:** Ensure HTTP connections are reused to reduce overhead.
2. **Batch Cache Updates:** Instead of updating cache in each request, consider a batch update mechanism.
3. **Stream JSON Decoding:** Use streaming or incremental decoding if the response body is large.

**Resource Usage Concerns:**
- **Unclosed Response Bodies:** The `defer resp.Body.Close()` ensures resources are released but should be handled more robustly with proper error checking.
- **Redundant Operations:** Cache checks and setting can be optimized by reducing redundant operations, especially in cache hits.

By addressing these points, you can significantly improve the performance and efficiency of your code.

---

*Generated by CodeWorm on 2026-02-19 14:24*
