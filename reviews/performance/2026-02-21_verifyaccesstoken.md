# VerifyAccessToken

**Type:** Performance Analysis
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/auth/jwt.go
**Language:** go
**Lines:** 160-225
**Complexity:** 10.0

---

## Source Code

```go
func (m *JWTManager) VerifyAccessToken(
	ctx context.Context,
	tokenString string,
) (*middleware.AccessTokenClaims, error) {
	token, err := jwt.Parse(
		[]byte(tokenString),
		jwt.WithKey(jwa.ES256(), m.publicKey),
		jwt.WithValidate(true),
		jwt.WithIssuer(m.config.Issuer),
		jwt.WithAudience(m.config.Audience),
	)
	if err != nil {
		if isTokenExpiredError(err) {
			return nil, fmt.Errorf("verify token: %w", core.ErrTokenExpired)
		}
		return nil, fmt.Errorf("verify token: %w", core.ErrTokenInvalid)
	}

	var tokenType string
	if err := token.Get("type", &tokenType); err != nil ||
		tokenType != "access" {
		return nil, fmt.Errorf(
			"verify token: invalid token type: %w",
			core.ErrTokenInvalid,
		)
	}

	subject, ok := token.Subject()
	if !ok || subject == "" {
		return nil, fmt.Errorf(
			"verify token: missing subject: %w",
			core.ErrTokenInvalid,
		)
	}

	var roleStr string
	if err := token.Get("role", &roleStr); err != nil {
		return nil, fmt.Errorf(
			"verify token: missing role claim: %w",
			core.ErrTokenInvalid,
		)
	}

	var tierStr string
	if err := token.Get("tier", &tierStr); err != nil {
		return nil, fmt.Errorf(
			"verify token: missing tier claim: %w",
			core.ErrTokenInvalid,
		)
	}

	var versionFloat float64
	if err := token.Get("token_version", &versionFloat); err != nil {
		return nil, fmt.Errorf(
			"verify token: missing token_version claim: %w",
			core.ErrTokenInvalid,
		)
	}

	return &middleware.AccessTokenClaims{
		UserID:       subject,
		Role:         roleStr,
		Tier:         tierStr,
		TokenVersion: int(versionFloat),
	}, nil
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of O(1) since the operations are constant-time, assuming `jwt.Parse` is optimized.

**Space Complexity:** The space complexity is also O(1), as no additional data structures grow with input size. However, error handling and type assertions could be optimized.

**Bottlenecks or Inefficiencies:**
- **Redundant Operations:** The function performs multiple calls to `token.Get`, which can be costly if the token claims are not cached.
- **Error Handling:** Multiple error checks and redundant type assertions increase complexity without adding value. Consider consolidating these into a single check.

**Optimization Opportunities:**
- **Cache Claims:** Cache frequently accessed claims (e.g., `role` and `tier`) to reduce repeated calls to `token.Get`.
- **Consolidate Error Handling:** Combine error checks for `token.Get` to avoid redundant code. For example, use a map of claim names and their expected types.

**Resource Usage Concerns:**
- Ensure that the `jwt.Parse` function does not hold onto resources unnecessarily.
- Validate that `m.publicKey` is correctly managed (e.g., no unclosed file handles).

### Suggested Optimizations

1. **Cache Claims:** Cache claims like `role` and `tier` in a map after initial parsing to avoid repeated calls.
2. **Consolidate Error Handling:** Use a single error handling block for all claim checks.

```go
claims := &middleware.AccessTokenClaims{}
errMap := map[string]struct{}{
	"role":  {},
	"tier":  {},
	"token_version": {},
}

for claim, _ := range errMap {
	if err := token.Get(claim, claims[claim]); err != nil {
		return nil, fmt.Errorf("verify token: missing %s claim: %w", claim, core.ErrTokenInvalid)
	}
}

return claims, nil
```

These changes will improve readability and reduce redundant operations.

---

*Generated by CodeWorm on 2026-02-21 07:00*
