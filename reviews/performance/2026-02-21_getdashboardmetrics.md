# GetDashboardMetrics

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/metrics/service.go
**Language:** go
**Lines:** 110-201
**Complexity:** 7.0

---

## Source Code

```go
func (s *Service) GetDashboardMetrics(ctx context.Context) (*DashboardMetrics, error) {
	serverStatus, err := s.repo.GetServerStatus(ctx)
	if err != nil {
		return nil, fmt.Errorf("get server status: %w", err)
	}

	dbStats, err := s.repo.GetDatabaseStats(ctx, s.database)
	if err != nil {
		return nil, fmt.Errorf("get database stats: %w", err)
	}

	databases, err := s.repo.ListDatabases(ctx)
	if err != nil {
		return nil, fmt.Errorf("list databases: %w", err)
	}

	activeOps, err := s.repo.GetCurrentOps(ctx)
	if err != nil {
		return nil, fmt.Errorf("get current ops: %w", err)
	}

	paidSubs, err := s.repo.GetTruePaidSubscribers(ctx, s.database)
	if err != nil {
		return nil, fmt.Errorf("get paid subscribers: %w", err)
	}

	totalOps := serverStatus.Opcounters.Insert +
		serverStatus.Opcounters.Query +
		serverStatus.Opcounters.Update +
		serverStatus.Opcounters.Delete +
		serverStatus.Opcounters.Getmore +
		serverStatus.Opcounters.Command

	currentOps := make([]CurrentOperation, 0, len(activeOps))
	for _, op := range activeOps {
		collection := extractCollection(op.Namespace)
		currentOps = append(currentOps, CurrentOperation{
			OpID:             op.OpID,
			Type:             op.Op,
			Namespace:        op.Namespace,
			Collection:       collection,
			MicrosecsRunning: op.MicrosecsRunning,
			MillisRunning:    float64(op.MicrosecsRunning) / 1000.0,
			Client:           op.Client,
		})
	}

	return &DashboardMetrics{
		Timestamp: time.Now(),
		Server: ServerMetrics{
			Host:      serverStatus.Host,
			Version:   serverStatus.Version,
			UptimeSec: serverStatus.Uptime,
		},
		Database: DatabaseMetrics{
			Name:           s.database,
			Collections:    dbStats.Collections,
			Documents:      dbStats.Objects,
			DataSizeMB:     bytesToMB(dbStats.DataSize),
			StorageSizeMB:  bytesToMB(dbStats.StorageSize),
			Indexes:        dbStats.Indexes,
			IndexSizeMB:    bytesToMB(dbStats.IndexSize),
			TotalDatabases: len(databases),
		},
		Connections: ConnectionStats{
			Current:      serverStatus.Connections.Current,
			Available:    serverStatus.Connections.Available,
			TotalCreated: serverStatus.Connections.TotalCreated,
		},
		Operations: OpCounters{
			Insert:  serverStatus.Opcounters.Insert,
			Query:   serverStatus.Opcounters.Query,
			Update:  serverStatus.Opcounters.Update,
			Delete:  serverStatus.Opcounters.Delete,
			Getmore: serverStatus.Opcounters.Getmore,
			Command: serverStatus.Opcounters.Command,
			Total:   totalOps,
		},
		Memory: MemoryStats{
			ResidentMB: serverStatus.Mem.Resident,
			VirtualMB:  serverStatus.Mem.Virtual,
		},
		Network: NetworkStats{
			BytesInMB:   bytesToMB(float64(serverStatus.Network.BytesIn)),
			BytesOutMB:  bytesToMB(float64(serverStatus.Network.BytesOut)),
			NumRequests: serverStatus.Network.NumRequests,
		},
		ActiveOps:       len(activeOps),
		CurrentOps:      currentOps,
		PaidSubscribers: paidSubs,
	}, nil
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The function has a time complexity of \(O(n)\), where \(n\) is the number of active operations returned by `s.repo.GetCurrentOps(ctx)`. Each database operation and metric retrieval is performed sequentially.

#### Space Complexity
Space complexity is also \(O(n)\) due to the storage of `currentOps` and other intermediate results. Memory usage can be optimized by reusing slices or minimizing allocations.

#### Bottlenecks and Inefficiencies
1. **Redundant Operations**: The function performs multiple database queries (e.g., `GetServerStatus`, `ListDatabases`, etc.), which could be reduced if these operations are not dependent on each other.
2. **Blocking Calls**: All repository calls are synchronous, which can block the execution of goroutines if this function is called concurrently.

#### Optimization Opportunities
1. **Batch Operations**: If possible, batch database queries to reduce the number of round trips to the database.
2. **Caching**: Cache `GetServerStatus` and other frequently accessed data to avoid redundant calls.
3. **Concurrency**: Use goroutines for asynchronous operations where blocking is not necessary.

#### Resource Usage Concerns
- Ensure that all connections, file handles, or other resources are properly closed to prevent leaks.
- Consider using context timeouts to handle long-running operations gracefully.

By optimizing the number of database queries and utilizing concurrency where appropriate, you can improve both performance and resource utilization.

---

*Generated by CodeWorm on 2026-02-21 18:28*
