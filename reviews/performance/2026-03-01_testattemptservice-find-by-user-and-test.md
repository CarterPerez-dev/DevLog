# TestAttemptService.find_by_user_and_test

**Type:** Performance Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/testing/services/session_ops.py
**Language:** python
**Lines:** 25-64
**Complexity:** 7.0

---

## Source Code

```python
def find_by_user_and_test(
        user_id: str | ObjectId,
        test_id: int | str,
        category: str | None = None,
        status: str | None = None
    ) -> TestAttempt | None:
        """
        Find test attempt by user and test.
        """
        if isinstance(user_id, str):
            try:
                user_id = ObjectId(user_id)
            except (InvalidId, ValueError):
                return None

        base_query: dict[str, Any] = {"userId": user_id, "testId": test_id}

        if category:
            base_query["category"] = category

        if status == "finished":
            return TestAttempt.objects(
                **base_query,
                finished = True
            ).order_by('-finishedAt').first()
        if status == "unfinished":
            return TestAttempt.objects(
                **base_query,
                finished = False
            ).first()
        attempt = TestAttempt.objects(
            **base_query,
            finished = False
        ).first()
        if not attempt:
            attempt = TestAttempt.objects(
                **base_query,
                finished = True
            ).order_by('-finishedAt').first()
        return attempt
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of documents in the collection, due to the `.first()` and `.order_by('-finishedAt').first()` calls.

**Space Complexity:** The space complexity is \(O(1)\) as there are no significant memory allocations beyond the input parameters and local variables.

**Bottlenecks or Inefficiencies:**
- **Redundant Queries:** The function performs multiple queries to fetch `TestAttempt` objects, which can be inefficient if the database has a large number of documents.
- **Unnecessary Iterations:** The `.first()` method is called twice with different conditions, leading to redundant database hits.

**Optimization Opportunities:**
1. **Combine Queries:** Use a single query with conditional filtering and ordering.
2. **Use Aggregation Pipeline:** Leverage MongoDB's aggregation framework for more efficient querying.

```python
def find_by_user_and_test(
        user_id: str | ObjectId,
        test_id: int | str,
        category: str | None = None,
        status: str | None = None
    ) -> TestAttempt | None:
    """
    Find test attempt by user and test.
    """
    if isinstance(user_id, str):
        try:
            user_id = ObjectId(user_id)
        except (InvalidId, ValueError):
            return None

    base_query: dict[str, Any] = {"userId": user_id, "testId": test_id}

    if category:
        base_query["category"] = category

    pipeline = [
        {"$match": {**base_query}},
        {"$addFields": {"status": "$finished"}},
        {"$project": {"_id": 0, "status": 1}}
    ]

    if status == "finished":
        pipeline.append({"$match": {"status": True}})
        pipeline.append({"$sort": {"finishedAt": -1}})
        return TestAttempt.objects.aggregate(*pipeline).first()
    
    if status == "unfinished":
        pipeline.append({"$match": {"status": False}})
        return TestAttempt.objects.aggregate(*pipeline).first()

    # Default to unfinished
    pipeline.append({"$match": {"status": False}})
    return TestAttempt.objects.aggregate(*pipeline).first()
```

**Resource Usage Concerns:**
- Ensure proper handling of `ObjectId` conversions and error propagation.
- Use context managers for database connections if the application is running in a server environment.

---

*Generated by CodeWorm on 2026-03-01 07:02*
