# loadMessages

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/services/room.service.ts
**Language:** typescript
**Lines:** 51-137
**Complexity:** 11.0

---

## Source Code

```typescript
async function loadMessages(
  roomId: string,
  limit: number = 50,
  offset: number = 0
): Promise<Message[]> {
  try {
    const localMessages = await getDecryptedMessages(roomId, limit)
    const localMessageIds = new Set(localMessages.map((m) => m.id))

    if (localMessages.length > 0) {
      setRoomMessages(roomId, localMessages)
    }

    const response = await api.rooms.getMessages(roomId, limit, offset)
    const serverMessages = response.messages.reverse()

    const newMessages: Message[] = []

    const currentUserId = $userId.get()

    for (const msg of serverMessages) {
      if (localMessageIds.has(msg.id)) {
        continue
      }

      let content = "[Encrypted - from another session]"
      const isOwnMessage = msg.sender_id === currentUserId

      if (isOwnMessage) {
        const localCopy = await getDecryptedMessage(msg.id)
        if (localCopy) {
          content = localCopy.content
        } else {
          content = "[Your message - not stored locally]"
        }
      } else {
        try {
          content = await cryptoService.decrypt(
            msg.sender_id,
            msg.ciphertext,
            msg.nonce,
            msg.header
          )
        } catch {
          content = "[Encrypted - from another session]"
        }
      }

      const decryptedMessage: Message = {
        id: msg.id,
        room_id: msg.room_id,
        sender_id: msg.sender_id,
        sender_username: msg.sender_username,
        content,
        status: "delivered" as const,
        is_encrypted: true,
        encrypted_content: msg.ciphertext,
        nonce: msg.nonce,
        header: msg.header,
        created_at: msg.created_at,
        updated_at: msg.created_at,
      }

      if (!content.startsWith("[Encrypted") && !content.startsWith("[Your message")) {
        void saveDecryptedMessage(decryptedMessage)
      }

      newMessages.push(decryptedMessage)
    }

    const allMessages = [...localMessages, ...newMessages]
    const uniqueMessages = Array.from(
      new Map(allMessages.map((m) => [m.id, m])).values()
    ).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime())

    setRoomMessages(roomId, uniqueMessages)
    setHasMore(roomId, response.has_more)
    return uniqueMessages
  } catch (err) {
    console.error("[RoomService] Failed to load messages:", err)
    const localMessages = await getDecryptedMessages(roomId, limit)
    if (localMessages.length > 0) {
      setRoomMessages(roomId, localMessages)
    }
    return localMessages
  }
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of `loadMessages` is primarily determined by the asynchronous operations, which are O(n + m), where n is the number of local messages and m is the number of server messages.

#### Space Complexity and Memory Allocation
- **Space Complexity**: The function uses additional space for `localMessageIds`, `newMessages`, and `uniqueMessages`. The space complexity is O(n + m) due to storing both local and new messages.
- **Memory Leaks**: Ensure that all asynchronous operations are properly awaited or handled with try-catch blocks. For instance, the `saveDecryptedMessage` call should be ensured not to leak memory.

#### Bottlenecks and Inefficiencies
1. **Redundant Decryption Checks**: The function checks if a message is encrypted multiple times within the loop.
2. **Unnecessary Iterations**: The `Array.from(new Map(...).values())` operation can be optimized by directly sorting the combined array of local and new messages.
3. **Blocking Calls in Async Contexts**: The `getDecryptedMessage` and `cryptoService.decrypt` calls are blocking, which could slow down performance if they take a long time.

#### Optimization Opportunities
1. **Reduce Redundant Checks**: Move the decryption check outside the loop to reduce redundant operations.
2. **Optimize Sorting**: Directly sort the combined array of local and new messages without using `Array.from(new Map(...).values())`.
3. **Use Async/Await Properly**: Ensure all asynchronous calls are properly awaited or handled with try-catch blocks.

#### Resource Usage Concerns
- **Unclosed Connections**: Ensure that any network connections, file handles, or database connections are properly closed.
- **Memory Management**: Use weak references or caching for frequently accessed data to avoid memory leaks.

By addressing these points, you can improve the performance and efficiency of `loadMessages`.

---

*Generated by CodeWorm on 2026-02-18 14:46*
