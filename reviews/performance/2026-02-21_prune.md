# Prune

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/docker/system.go
**Language:** go
**Lines:** 150-202
**Complexity:** 9.0

---

## Source Code

```go
func (c *Client) Prune(
	ctx context.Context,
	pruneImages, pruneVolumes, pruneBuildCache bool,
) (uint64, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	var totalReclaimed uint64

	containerReport, err := c.cli.ContainersPrune(ctx, filters.Args{})
	if err != nil {
		return 0, fmt.Errorf("pruning containers: %w", err)
	}
	totalReclaimed += containerReport.SpaceReclaimed

	if pruneImages {
		imageReport, err := c.cli.ImagesPrune(
			ctx,
			filters.NewArgs(filters.Arg("dangling", "false")),
		)
		if err != nil {
			return totalReclaimed, fmt.Errorf("pruning images: %w", err)
		}
		totalReclaimed += imageReport.SpaceReclaimed
	}

	if pruneVolumes {
		volumeReport, err := c.cli.VolumesPrune(ctx, filters.Args{})
		if err != nil {
			return totalReclaimed, fmt.Errorf("pruning volumes: %w", err)
		}
		totalReclaimed += volumeReport.SpaceReclaimed
	}

	if pruneBuildCache {
		buildReport, err := c.cli.BuildCachePrune(
			ctx,
			build.CachePruneOptions{All: true},
		)
		if err != nil {
			return totalReclaimed, fmt.Errorf("pruning build cache: %w", err)
		}
		totalReclaimed += buildReport.SpaceReclaimed
	}

	networkReport, err := c.cli.NetworksPrune(ctx, filters.Args{})
	if err != nil {
		return totalReclaimed, fmt.Errorf("pruning networks: %w", err)
	}
	_ = networkReport

	return totalReclaimed, nil
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of pruning operations performed (containers, images, volumes, build cache, networks). Each pruning operation involves an API call to Docker.

**Space Complexity:** The space complexity is \(O(1)\) as no additional data structures are created that grow with input size. However, memory allocation for error handling and reports can be considered constant per operation.

**Bottlenecks or Inefficiencies:**
- **Redundant Operations:** The function always locks the mutex (`c.mu.RLock()`), even if pruning is not requested.
- **Sequential API Calls:** Each pruning operation is called sequentially, which may introduce unnecessary latency. Consider using goroutines to prune in parallel.

**Optimization Opportunities:**
- **Parallel Pruning:** Use `go` to concurrently prune containers, images, volumes, and build cache. This can significantly reduce the overall execution time.
  ```go
  go func() {
    containerReport, err := c.cli.ContainersPrune(ctx, filters.Args{})
    if err != nil {
      log.Printf("pruning containers: %v", err)
    } else {
      totalReclaimed += containerReport.SpaceReclaimed
    }
  }()
  ```

- **Error Handling:** Instead of returning the first error and stopping further pruning, consider logging errors and continuing with other operations. This can improve overall resource utilization.

**Resource Usage Concerns:**
- Ensure that all API calls are properly handled to avoid blocking or hanging in async contexts.
- Consider caching results if pruning is frequently called with the same parameters to reduce repeated API calls.

---

*Generated by CodeWorm on 2026-02-21 18:00*
