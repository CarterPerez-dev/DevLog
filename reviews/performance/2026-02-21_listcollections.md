# ListCollections

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/mongodb/collections.go
**Language:** go
**Lines:** 93-151
**Complexity:** 12.0

---

## Source Code

```go
func (r *CollectionsRepository) ListCollections(ctx context.Context, dbName string) ([]CollectionInfo, error) {
	db := r.client.client.Database(dbName)

	cursor, err := db.ListCollections(ctx, bson.D{})
	if err != nil {
		return nil, fmt.Errorf("list collections: %w", err)
	}
	defer cursor.Close(ctx)

	var collections []CollectionInfo
	for cursor.Next(ctx) {
		var result bson.M
		if err := cursor.Decode(&result); err != nil {
			continue
		}

		name, _ := result["name"].(string)
		collType, _ := result["type"].(string)

		if collType == "" {
			collType = "collection"
		}

		info := CollectionInfo{
			Name: name,
			Type: collType,
		}

		count, _ := db.Collection(name).EstimatedDocumentCount(ctx)
		info.DocumentCount = count

		var stats bson.M
		if err := db.RunCommand(ctx, bson.D{{"collStats", name}}).Decode(&stats); err == nil {
			if size, ok := stats["size"].(int32); ok {
				info.SizeBytes = int64(size)
			} else if size, ok := stats["size"].(int64); ok {
				info.SizeBytes = size
			}
			if avgSize, ok := stats["avgObjSize"].(int32); ok {
				info.AvgDocSize = int64(avgSize)
			} else if avgSize, ok := stats["avgObjSize"].(int64); ok {
				info.AvgDocSize = avgSize
			} else if avgSize, ok := stats["avgObjSize"].(float64); ok {
				info.AvgDocSize = int64(avgSize)
			}
			if nindexes, ok := stats["nindexes"].(int32); ok {
				info.IndexCount = int(nindexes)
			}
		}

		collections = append(collections, info)
	}

	sort.Slice(collections, func(i, j int) bool {
		return collections[i].DocumentCount > collections[j].DocumentCount
	})

	return collections, nil
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity**: The function has a time complexity of \(O(N \times M)\), where \(N\) is the number of collections, and \(M\) is the number of operations performed on each collection (e.g., `EstimatedDocumentCount` and `RunCommand`). This can be costly for large databases.

**Space Complexity**: The space complexity is \(O(N)\) due to storing `collections` in memory. However, the function does not allocate significant additional space other than the slice used to store results.

**Bottlenecks or Inefficiencies**:
1. **Redundant Type Assertions**: Using type assertions (`_ := result["name"].(string)` and similar) can be error-prone and slow due to interface conversion.
2. **Multiple `RunCommand` Calls**: The function calls `RunCommand` for each collection, leading to \(O(N)\) database round-trips, which is inefficient.
3. **Sorting**: Sorting the collections at the end of the function has a time complexity of \(O(N \log N)\).

**Optimization Opportunities**:
1. Use `bson.M["name"].(string)` directly instead of type assertions.
2. Cache the result of `RunCommand` to reduce database round-trips, e.g., by using a map or cache.
3. Consider parallelizing collection statistics retrieval using goroutines.

**Resource Usage Concerns**:
- Ensure proper error handling and resource cleanup for database connections.
- Use context timeouts to prevent long-running operations from blocking the caller.

By addressing these points, you can significantly improve the performance of your function.

---

*Generated by CodeWorm on 2026-02-21 17:50*
