# handleText

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CarterBot-Telegram/src/handlers/text.ts
**Language:** typescript
**Lines:** 13-93
**Complexity:** 16.0

---

## Source Code

```typescript
async function handleText(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username || "unknown";
  const chatId = ctx.chat?.id;
  let message = ctx.message?.text;

  if (!userId || !message || !chatId) {
    return;
  }

  if (!isAuthorized(userId, ALLOWED_USERS)) {
    await ctx.reply("Unauthorized. Contact the bot owner for access.");
    return;
  }

  message = await checkInterrupt(message);
  if (!message.trim()) {
    return;
  }

  session.lastMessage = message;

  const stopProcessing = session.startProcessing();
  const typing = startTypingIndicator(ctx);

  let state = new StreamingState();
  let statusCallback = createStatusCallback(ctx, state);

  const MAX_RETRIES = 1;

  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    try {
      await session.sendMessageStreaming(
        message,
        username,
        userId,
        statusCallback,
        chatId,
        ctx
      );
      break;
    } catch (error) {
      const errorStr = String(error);
      const isClaudeCodeCrash = errorStr.includes("exited with code");

      for (const toolMsg of state.toolMessages) {
        try {
          await ctx.api.deleteMessage(toolMsg.chat.id, toolMsg.message_id);
        } catch {
          // Ignore cleanup errors
        }
      }

      if (isClaudeCodeCrash && attempt < MAX_RETRIES) {
        console.log(
          `Claude Code crashed, retrying (attempt ${attempt + 2}/${MAX_RETRIES + 1})...`
        );
        await session.kill();
        await ctx.reply("Claude crashed, retrying...");
        state = new StreamingState();
        statusCallback = createStatusCallback(ctx, state);
        continue;
      }

      console.error("Error processing message:", error);

      if (errorStr.includes("abort") || errorStr.includes("cancel")) {
        const wasInterrupt = session.consumeInterruptFlag();
        if (!wasInterrupt) {
          await ctx.reply("Query stopped.");
        }
      } else {
        await ctx.reply(`Error: ${errorStr.slice(0, 200)}`);
      }
      break;
    }
  }

  stopProcessing();
  typing.stop();
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of retries (up to 2). The primary bottlenecks are the `session.sendMessageStreaming` call and the cleanup of tool messages, which can be costly if there are many messages.

**Space Complexity:** The space complexity is \(O(1)\) for variables like `MAX_RETRIES`, but the state object `StreamingState` could grow with each retry. Ensure that `StreamingState` does not retain unnecessary data across retries to avoid memory leaks.

**Bottlenecks and Inefficiencies:**
- **Redundant Operations:** The `isAuthorized` check, `checkInterrupt`, and message processing are repeated in every attempt.
- **Blocking Calls:** `session.sendMessageStreaming` is a blocking call, which can delay the function execution. Consider making it asynchronous to improve performance.
- **N+1 Query Pattern:** The cleanup of tool messages inside the retry loop could lead to multiple database calls if there are many messages.

**Optimization Opportunities:**
- Move the authorization and interrupt checks outside the retry loop to avoid redundant operations.
- Use async/await properly in `session.sendMessageStreaming` to handle streaming responses asynchronously.
- Implement batching for message cleanup to reduce the number of API calls.

**Resource Usage Concerns:**
- Ensure that `StreamingState` is properly cleaned up after each attempt to prevent memory leaks.
- Close any unclosed connections or file handles used within the function.

---

*Generated by CodeWorm on 2026-02-21 16:53*
