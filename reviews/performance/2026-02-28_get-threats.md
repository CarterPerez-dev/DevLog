# get_threats

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/services/threat_service.py
**Language:** python
**Lines:** 51-99
**Complexity:** 6.0

---

## Source Code

```python
async def get_threats(
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0,
    severity: str | None = None,
    source_ip: str | None = None,
    since: datetime | None = None,
    until: datetime | None = None,
) -> ThreatListResponse:
    """
    Query threat events with optional filters, returning a paginated response.
    """
    query = select(ThreatEvent)
    count_query = select(func.count()).select_from(ThreatEvent)

    if severity:
        query = query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
        count_query = count_query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
    if source_ip:
        query = query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]
        count_query = count_query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]
    if since:
        query = query.where(ThreatEvent.created_at
                            >= since)  # type: ignore[arg-type]
        count_query = count_query.where(ThreatEvent.created_at
                                        >= since)  # type: ignore[arg-type]
    if until:
        query = query.where(ThreatEvent.created_at
                            <= until)  # type: ignore[arg-type]
        count_query = count_query.where(ThreatEvent.created_at
                                        <= until)  # type: ignore[arg-type]

    query = query.order_by(
        ThreatEvent.created_at.desc())  # type: ignore[attr-defined]
    query = query.offset(offset).limit(limit)

    total = (await session.execute(count_query)).scalar_one()
    rows = (await session.execute(query)).scalars().all()

    return ThreatListResponse(
        total=total,
        limit=limit,
        offset=offset,
        items=[_to_response(row) for row in rows],
    )
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity of the `get_threats` function is O(n + m), where n is the number of filtered threats and m is the count query execution time. The primary bottleneck is the repeated construction and modification of SQL queries, which can be costly.

**Space Complexity:** The space complexity is O(1) for the filters and O(n) for storing the results, assuming `n` rows are returned by the database query.

**Bottlenecks or Inefficiencies:**
- **Repeated Query Construction:** Repeatedly modifying the same SQL query object can be inefficient. Consider using a single query with dynamic WHERE clauses.
- **Redundant Operations:** The `count_query` is identical to the main query but executed separately, leading to redundant database calls.

**Optimization Opportunities:**
- Use a single query with dynamic WHERE conditions to avoid repeated construction and execution of SQL queries.
- Combine count and result retrieval into one database call using a subquery or a common table expression (CTE).

```python
async def get_threats(
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0,
    severity: str | None = None,
    source_ip: str | None = None,
    since: datetime | None = None,
    until: datetime | None = None,
) -> ThreatListResponse:
    query = select(ThreatEvent)
    
    if severity:
        query = query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
        
    if source_ip:
        query = query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]

    if since:
        query = query.where(ThreatEvent.created_at
                            >= since)  # type: ignore[arg-type]

    if until:
        query = query.where(ThreatEvent.created_at
                            <= until)  # type: ignore[arg-type]

    total_query = select(func.count()).select_from(
        select(ThreatEvent).where(
            *query.whereclause.args))  # type: ignore[attr-defined]
    
    query = query.order_by(
        ThreatEvent.created_at.desc())  # type: ignore[attr-defined]
    query = query.offset(offset).limit(limit)

    total = (await session.execute(total_query)).scalar_one()
    rows = (await session.execute(query)).scalars().all()

    return ThreatListResponse(
        total=total,
        limit=limit,
        offset=offset,
        items=[_to_response(row) for row in rows],
    )
```

**Resource Usage Concerns:**
- Ensure that the database connection is properly managed using context managers or async context managers to avoid resource leaks.

---

*Generated by CodeWorm on 2026-02-28 07:03*
