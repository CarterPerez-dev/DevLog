# AuthService.refresh_tokens

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/auth/services/auth.py
**Language:** python
**Lines:** 113-173
**Complexity:** 6.0

---

## Source Code

```python
async def refresh_tokens(
        session: AsyncSession,
        refresh_token: str,
        device_id: str | None = None,
        device_name: str | None = None,
        ip_address: str | None = None,
    ) -> tuple[TokenResponse, str]:
        """
        Refresh access token using refresh token

        Implements token rotation with replay attack detection

        Returns:
            Tuple of (TokenResponse, new_raw_refresh_token)
        """
        token_hash = hash_token(refresh_token)
        stored_token = await RefreshTokenRepository.get_by_hash(
            session,
            token_hash
        )

        if stored_token is None:
            raise TokenError(message = "Invalid refresh token")

        if stored_token.is_revoked:
            await RefreshTokenRepository.revoke_family(
                session,
                stored_token.family_id
            )
            raise TokenRevokedError()

        if stored_token.is_expired:
            raise TokenError(message = "Refresh token expired")

        user = await UserRepository.get_by_id(
            session,
            stored_token.user_id
        )
        if user is None or not user.is_active:
            raise TokenError(message = "User not found or inactive")

        await RefreshTokenRepository.revoke_token(session, stored_token)

        access_token = create_access_token(user.id, user.token_version)

        raw_refresh, new_hash, expires_at = create_refresh_token(
            user.id, stored_token.family_id
        )

        await RefreshTokenRepository.create_token(
            session,
            user_id = user.id,
            token_hash = new_hash,
            family_id = stored_token.family_id,
            expires_at = expires_at,
            device_id = device_id,
            device_name = device_name,
            ip_address = ip_address,
        )

        return TokenResponse(access_token = access_token), raw_refresh
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of database queries, primarily due to asynchronous calls to `RefreshTokenRepository` and `UserRepository`. Each query involves network I/O, which can be costly.

**Space Complexity:** The space complexity is \(O(1)\) for local variables. However, the function creates new tokens (`access_token`, `raw_refresh`) and stores them in the database, which may impact memory usage if this process is called frequently.

**Bottlenecks or Inefficiencies:**
- **Multiple Database Queries:** The function makes several asynchronous calls to the repository, leading to potential performance bottlenecks. Each call involves network I/O.
- **Redundant Operations:** Creating and storing new tokens (`access_token`, `raw_refresh`) might be redundant if not all operations succeed.

**Optimization Opportunities:**
- **Batch Queries:** Combine multiple queries into a single batch operation where possible, reducing the number of round trips to the database.
- **Caching:** Cache user and token data to reduce repeated lookups. Use decorators like `@lru_cache` for caching function results.
- **Error Handling:** Simplify error handling by using a more structured approach, such as returning a single exception or a custom error object.

**Resource Usage Concerns:**
- Ensure that all database connections are properly managed and closed to avoid resource leaks. Use context managers (`async with`) when interacting with the database.
- Consider implementing connection pooling for better performance in handling multiple concurrent requests.

---

*Generated by CodeWorm on 2026-02-21 17:41*
