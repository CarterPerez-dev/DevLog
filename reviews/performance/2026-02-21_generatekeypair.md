# GenerateKeyPair

**Type:** Performance Analysis
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/auth/jwt.go
**Language:** go
**Lines:** 77-121
**Complexity:** 10.0

---

## Source Code

```go
func GenerateKeyPair(privateKeyPath, publicKeyPath string) error {
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return fmt.Errorf("generate key: %w", err)
	}

	jwkPrivate, err := jwk.Import(privateKey)
	if err != nil {
		return fmt.Errorf("import private key: %w", err)
	}

	keyID := uuid.New().String()[:8]
	if setErr := jwkPrivate.Set(jwk.KeyIDKey, keyID); setErr != nil {
		return fmt.Errorf("set key id: %w", setErr)
	}
	if setErr := jwkPrivate.Set(jwk.AlgorithmKey, jwa.ES256()); setErr != nil {
		return fmt.Errorf("set algorithm: %w", setErr)
	}

	privatePEM, err := jwk.Pem(jwkPrivate)
	if err != nil {
		return fmt.Errorf("encode private key: %w", err)
	}

	if writeErr := os.WriteFile(privateKeyPath, privatePEM, 0o600); writeErr != nil {
		return fmt.Errorf("write private key: %w", writeErr)
	}

	jwkPublic, err := jwkPrivate.PublicKey()
	if err != nil {
		return fmt.Errorf("derive public key: %w", err)
	}

	publicPEM, err := jwk.Pem(jwkPublic)
	if err != nil {
		return fmt.Errorf("encode public key: %w", err)
	}

	//nolint:gosec // G306: public key is intentionally world-readable
	if writeErr := os.WriteFile(publicKeyPath, publicPEM, 0o644); writeErr != nil {
		return fmt.Errorf("write public key: %w", writeErr)
	}

	return nil
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(1)\), as the operations are constant-time, involving cryptographic key generation, JWK encoding, and file writing.

**Space Complexity:** The space complexity is also \(O(1)\) since the memory usage does not depend on input size. However, the `jwk` package might have some internal state that could be optimized for large-scale use.

**Bottlenecks or Inefficiencies:**
- **Redundant Operations:** The function repeatedly checks for errors and uses error wrapping, which can lead to performance overhead.
- **Blocking File I/O:** Writing files (`os.WriteFile`) is blocking, which might cause delays if the file system is busy.

**Optimization Opportunities:**
- Use a single `WriteFile` call with both private and public keys to reduce the number of I/O operations.
- Consider using asynchronous file writing or buffering to improve performance in high-load scenarios.
- Optimize error handling by returning detailed errors instead of wrapping them, which can help in diagnosing issues.

**Resource Usage Concerns:**
- Ensure that `rand.Reader` is properly initialized and does not block.
- Close any open connections or files if the function interacts with external resources (though none are used here).

By reducing the number of I/O operations and optimizing error handling, you can improve both performance and maintainability.

---

*Generated by CodeWorm on 2026-02-21 11:17*
