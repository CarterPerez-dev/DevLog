# createAuthResponse

**Type:** Performance Analysis
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/auth/service.go
**Language:** go
**Lines:** 352-411
**Complexity:** 5.0

---

## Source Code

```go
func (s *Service) createAuthResponse(
	ctx context.Context,
	user *UserInfo,
	userAgent, ipAddress, familyID string,
	oldTokenID *string,
) (*AuthResponse, error) {
	accessToken, err := s.jwt.CreateAccessToken(AccessTokenClaims{
		UserID:       user.ID,
		Role:         user.Role,
		Tier:         user.Tier,
		TokenVersion: user.TokenVersion,
	})
	if err != nil {
		return nil, fmt.Errorf("create access token: %w", err)
	}

	refreshData, err := s.jwt.CreateRefreshToken(user.ID, familyID)
	if err != nil {
		return nil, fmt.Errorf("create refresh token: %w", err)
	}

	newTokenID := uuid.New().String()

	refreshTokenEntity := &RefreshToken{
		ID:        newTokenID,
		UserID:    user.ID,
		TokenHash: refreshData.Hash,
		FamilyID:  refreshData.FamilyID,
		ExpiresAt: refreshData.ExpiresAt,
		UserAgent: userAgent,
		IPAddress: ipAddress,
	}

	if err := s.repo.Create(ctx, refreshTokenEntity); err != nil {
		return nil, fmt.Errorf("store refresh token: %w", err)
	}

	if oldTokenID != nil {
		//nolint:errcheck // best-effort token chain tracking
		_ = s.repo.MarkAsUsed(ctx, *oldTokenID, newTokenID)
	}

	return &AuthResponse{
		User: UserResponse{
			ID:        user.ID,
			Email:     user.Email,
			Name:      user.Name,
			Role:      user.Role,
			Tier:      user.Tier,
			CreatedAt: time.Now(),
		},
		Tokens: TokenResponse{
			AccessToken:  accessToken,
			RefreshToken: refreshData.Token,
			TokenType:    "Bearer",
			ExpiresIn:    int(15 * time.Minute / time.Second),
			ExpiresAt:    time.Now().Add(15 * time.Minute),
		},
	}, nil
}
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The function has a time complexity of \(O(1)\), as it performs a fixed number of operations regardless of the input size.

#### Space Complexity and Memory Allocation
- The space complexity is also \(O(1)\) since no additional data structures depend on the input size.
- `uuid.New().String()` creates a new UUID, which is memory-intensive but constant per call.

#### Bottlenecks or Inefficiencies
- **Redundant Error Handling**: The `errcheck` linting suppression for marking old tokens as used can be removed if not critical. Ensure proper error handling to avoid potential issues.
- **Blocking Calls in Async Contexts**: If this function is called within an async context, the blocking nature of database operations could impact performance.

#### Optimization Opportunities
- **Caching**: Cache user information and JWT creation results where possible to reduce repeated lookups and token creations.
- **Batch Operations**: If multiple `createAuthResponse` calls are made in a short period, consider batching database writes for efficiency.

#### Resource Usage Concerns
- Ensure that the database connection is properly managed. Use context-aware transactions or connection pooling if not already done.
- Consider using a more efficient UUID generator if performance becomes an issue.

By addressing these points, you can enhance both the performance and maintainability of your code.

---

*Generated by CodeWorm on 2026-02-21 14:55*
