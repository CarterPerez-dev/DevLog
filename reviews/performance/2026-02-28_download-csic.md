# download_csic

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/ml/download_csic.py
**Language:** python
**Lines:** 41-103
**Complexity:** 8.0

---

## Source Code

```python
def download_csic(output_dir: Path = DATASET_DIR, ) -> None:
    """
    Download CSIC 2010 dataset files
    """
    output_dir.mkdir(parents=True, exist_ok=True)

    for filename in FILES:
        dest = output_dir / filename

        if dest.exists() and dest.stat().st_size > MIN_FILE_BYTES:
            logger.info("Skipping %s (already exists)", filename)
            continue

        url = f"{BASE_URL}/{filename}"
        logger.info("Downloading %s", url)
        print(f"Downloading {filename}...")

        try:
            with httpx.stream(
                "GET",
                url,
                follow_redirects=True,
            ) as response:
                response.raise_for_status()
                total = int(
                    response.headers.get("content-length", 0)
                )
                downloaded = 0
                with open(dest, "wb") as f:
                    for chunk in response.iter_bytes(
                        chunk_size=65536
                    ):
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total > 0:
                            pct = min(
                                downloaded * 100 / total, 100
                            )
                            sys.stdout.write(f"\r  {pct:.0f}%")
                        else:
                            mb = downloaded / 1_048_576
                            sys.stdout.write(f"\r  {mb:.1f} MB")
                        sys.stdout.flush()
            print()
        except Exception as exc:
            logger.error(
                "Failed to download %s: %s",
                filename,
                exc,
            )
            print(f"\nError downloading {filename}: {exc}")
            continue

        size = dest.stat().st_size
        sha = _compute_sha256(dest)
        print(f"  Saved: {dest}"
              f" ({size:,} bytes, sha256={sha[:12]})")

        if size < MIN_FILE_BYTES:
            print(f"  WARNING: {filename} is suspiciously"
                  f" small ({size:,} bytes)")

    print(f"\nDataset directory: {output_dir.resolve()}")
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is primarily driven by the HTTP request and file download operations, which are O(n) where n is the number of files to be downloaded.

**Space Complexity:** The space complexity is O(1) for variables used within the function. However, the `response.iter_bytes()` method can consume significant memory if downloading large files.

### Bottlenecks or Inefficiencies

- **Redundant Operations:** The `stat().st_size` check and `exists()` call are redundant as they are checked again when writing to disk.
- **Blocking I/O:** The `open(dest, "wb")` operation is blocking, which can be a bottleneck for large files.
- **Resource Leaks:** Unclosed file handles in case of exceptions. Ensure proper handling using context managers.

### Optimization Opportunities

1. **Remove Redundant Checks:** Combine the existence and size checks into one condition to avoid redundant operations.
2. **Use Asynchronous HTTP Requests:** Replace `httpx.stream()` with asynchronous requests if the environment supports it, reducing blocking time.
3. **Context Managers for File Handling:** Use `with open(dest, "wb") as f:` to ensure files are properly closed even in case of exceptions.

### Resource Usage Concerns

- Ensure that file handles are always closed using context managers or proper exception handling.
- Consider using a progress bar library like `tqdm` instead of manual tqdm updates for cleaner and more efficient progress reporting.

---

*Generated by CodeWorm on 2026-02-28 18:54*
