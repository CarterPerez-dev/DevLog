# ShannonEntropy

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/rules/entropy.go
**Language:** go
**Lines:** 48-83
**Complexity:** 9.0

---

## Source Code

```go
func ShannonEntropy(data, charset string) float64 {
	if len(data) == 0 {
		return 0.0
	}

	filtered := data
	if charset != "" {
		cs := charsetSet(charset)
		var b strings.Builder
		b.Grow(len(data))
		for _, c := range data {
			if cs[c] {
				b.WriteRune(c)
			}
		}
		filtered = b.String()
		if len(filtered) == 0 {
			return 0.0
		}
	}

	freq := make(map[rune]int)
	for _, c := range filtered {
		freq[c]++
	}

	length := float64(len([]rune(filtered)))
	entropy := 0.0
	for _, count := range freq {
		p := float64(count) / length
		if p > 0 {
			entropy -= p * math.Log2(p)
		}
	}
	return entropy
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the length of `filtered`. This is due to the single pass through the string and the map operations.

**Space Complexity:** The space complexity is also \(O(n)\) because of the `freq` map, which can grow up to the size of the unique characters in `filtered`.

**Bottlenecks or Inefficiencies:**
1. **Redundant Operations:** The `charsetSet(charset)` function call and the subsequent filtering are redundant if `charset` is empty.
2. **Unnecessary Iterations:** The inner loop over `freq` can be optimized by using a direct sum of probabilities.

**Optimization Opportunities:**
1. **Conditional Check Optimization:** Simplify the conditional checks for `charset` to avoid unnecessary function calls and string manipulations.
2. **Direct Sum Calculation:** Use a single pass to calculate the entropy directly, reducing redundant operations.

```go
func ShannonEntropy(data, charset string) float64 {
	if len(data) == 0 {
		return 0.0
	}

	if charset != "" {
		cs := charsetSet(charset)
		var b strings.Builder
		b.Grow(len(data))
		for _, c := range data {
			if cs[c] {
				b.WriteRune(c)
			}
		}
		data = b.String()
	}

	freq := make(map[rune]int)
	for _, c := range data {
		freq[c]++
	}

	length := float64(len([]rune(data)))
	entropy := 0.0
	for _, count := range freq {
		p := float64(count) / length
		if p > 0 {
			entropy -= p * math.Log2(p)
		}
	}
	return entropy
}
```

**Resource Usage Concerns:**
- Ensure `charsetSet` is optimized to avoid unnecessary memory allocations.
- Use efficient string and map operations as shown above.

By optimizing the conditional checks and reducing redundant operations, you can improve both time and space efficiency.

---

*Generated by CodeWorm on 2026-03-02 09:46*
