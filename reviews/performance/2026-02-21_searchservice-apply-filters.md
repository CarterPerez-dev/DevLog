# SearchService._apply_filters

**Type:** Performance Analysis
**Repository:** vuemantics
**File:** backend/services/search_service.py
**Language:** python
**Lines:** 185-223
**Complexity:** 11.0

---

## Source Code

```python
def _apply_filters(
        self,
        results: list[SearchResult],
        request: SearchRequest
    ) -> list[SearchResult]:
        """
        Apply additional filters to search results

        Args:
            results: Initial search results
            request: Search request with filters

        Returns:
            Filtered results
        """
        filtered = results

        if request.file_types:
            filtered = [
                r for r in filtered
                if r.upload.file_type in request.file_types
            ]

        if request.date_from:
            filtered = [
                r for r in filtered
                if r.upload.created_at >= request.date_from
            ]

        if request.date_to:
            filtered = [
                r for r in filtered
                if r.upload.created_at <= request.date_to
            ]

        for rank, result in enumerate(filtered, 1):
            result.rank = rank

        return filtered
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity of the function is \(O(n \times m)\), where \(n\) is the number of results, and \(m\) is the number of filters applied (file types, date range). Each filter iteration over `filtered` can be costly if the list is large.

**Space Complexity:** The space complexity is \(O(1)\) as no additional data structures are used that scale with input size. However, the slicing operation in Python creates a new list, which might not be efficient for very large lists.

**Bottlenecks or Inefficiencies:**
- **Redundant Operations:** Each filter condition creates a new list via list comprehension, leading to multiple scans of `filtered`.
- **Unnecessary Iterations:** The rank assignment loop iterates over the filtered results again, which could be avoided by using an index.

**Optimization Opportunities:**
- Use a single pass with conditional filtering and rank assignment:
  ```python
  def _apply_filters(
      self,
      results: list[SearchResult],
      request: SearchRequest
  ) -> list[SearchResult]:
      filtered = [
          r for r in results
          if (not request.file_types or r.upload.file_type in request.file_types) and
             (not request.date_from or r.upload.created_at >= request.date_from) and
             (not request.date_to or r.upload.created_at <= request.date_to)
      ]
      
      for i, result in enumerate(filtered, 1):
          result.rank = i
      
      return filtered
  ```

**Resource Usage Concerns:**
- Ensure `SearchResult` objects are lightweight to avoid unnecessary memory usage.
- Consider caching filter results if the same filters are applied frequently.

---

*Generated by CodeWorm on 2026-02-21 22:44*
