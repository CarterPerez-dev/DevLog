# GetStorageInfo

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/docker/system.go
**Language:** go
**Lines:** 53-146
**Complexity:** 13.0

---

## Source Code

```go
func (c *Client) GetStorageInfo(
	ctx context.Context,
) (*model.StorageInfo, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	usage, err := c.cli.DiskUsage(ctx, types.DiskUsageOptions{})
	if err != nil {
		return nil, fmt.Errorf("getting disk usage: %w", err)
	}

	info := &model.StorageInfo{
		Details: model.StorageDetails{
			Images:     make([]model.ImageInfo, 0),
			Volumes:    make([]model.VolumeInfo, 0),
			BuildCache: make([]model.CacheInfo, 0),
		},
	}

	for _, img := range usage.Images {
		info.ImagesSize += uint64(img.Size)
		repoTag := "<none>:<none>"
		repo := "<none>"
		tag := "<none>"
		if len(img.RepoTags) > 0 {
			repoTag = img.RepoTags[0]
			parts := strings.Split(repoTag, ":")
			if len(parts) >= 1 {
				repo = parts[0]
			}
			if len(parts) >= 2 {
				tag = parts[1]
			}
		}

		info.Details.Images = append(info.Details.Images, model.ImageInfo{
			ID:         img.ID,
			Repository: repo,
			Tag:        tag,
			Size:       uint64(img.Size),
			InUse:      img.Containers > 0,
		})
	}

	for _, ctr := range usage.Containers {
		info.ContainersSize += uint64(ctr.SizeRw)
	}

	for _, vol := range usage.Volumes {
		size := int64(0)
		if vol.UsageData != nil {
			size = vol.UsageData.Size
		}
		info.VolumesSize += uint64(size)

		inUse := false
		if vol.UsageData != nil {
			inUse = vol.UsageData.RefCount > 0
		}

		info.Details.Volumes = append(info.Details.Volumes, model.VolumeInfo{
			Name:   vol.Name,
			Driver: vol.Driver,
			Size:   uint64(size),
			InUse:  inUse,
		})
	}

	for _, cache := range usage.BuildCache {
		info.BuildCacheSize += uint64(cache.Size)

		info.Details.BuildCache = append(
			info.Details.BuildCache,
			model.CacheInfo{
				ID:    cache.ID,
				Type:  cache.Type,
				Size:  uint64(cache.Size),
				InUse: cache.InUse,
			},
		)
	}

	info.TotalSize = info.ImagesSize + info.ContainersSize + info.VolumesSize + info.BuildCacheSize

	unusedImages := uint64(0)
	for _, img := range usage.Images {
		if img.Containers == 0 {
			unusedImages += uint64(img.Size)
		}
	}
	info.Reclaimable = unusedImages + info.BuildCacheSize

	return info, nil
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the number of images, containers, volumes, and build caches. Each loop processes each item in their respective lists.

**Space Complexity:** The space complexity is also \(O(n)\) due to the storage of details for each image, container, volume, and cache.

**Bottlenecks or Inefficiencies:**
1. **Redundant String Operations:** The `repoTag`, `repo`, and `tag` variables are repeatedly split from `img.RepoTags[0]`. This can be optimized by splitting the string once per image.
2. **Multiple Appends:** Repeatedly appending to slices (`info.Details.Images`, `info.Details.Volumes`, `info.Details.BuildCache`) can lead to multiple reallocations and copies, which is costly for large datasets.

**Optimization Opportunities:**
1. **Split String Once Per Image:** Move the string split operation outside the loop.
2. **Batch Appends:** Use a buffer or batch append strategy to reduce the number of allocations and copies.

```go
for _, img := range usage.Images {
	repoTag := "<none>:<none>"
	if len(img.RepoTags) > 0 {
		parts := strings.Split(img.RepoTags[0], ":")
		repoTag = parts[0] + ":" + parts[1]
	}
	info.Details.Images = append(info.Details.Images, model.ImageInfo{
		ID:         img.ID,
		Repository: parts[0],
		Tag:        parts[1],
		Size:       uint64(img.Size),
		InUse:      img.Containers > 0,
	})
}
```

**Resource Usage Concerns:**
- Ensure proper error handling and logging.
- Consider using context cancellation to avoid unnecessary processing if the operation is cancelled early.

By optimizing string operations and reducing slice reallocations, you can improve both time and space efficiency.

---

*Generated by CodeWorm on 2026-02-21 17:16*
