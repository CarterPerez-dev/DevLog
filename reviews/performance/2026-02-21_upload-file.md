# upload_file

**Type:** Performance Analysis
**Repository:** vuemantics
**File:** backend/routers/v1/upload.py
**Language:** python
**Lines:** 133-205
**Complexity:** 7.0

---

## Source Code

```python
async def upload_file(
    request: Request,
    file: Annotated[UploadFile,
                    File(description = "File to upload")],
    current_user: Annotated[User,
                            Depends(get_current_user)],
) -> UploadResponse:
    """
    Upload a new file

    File is saved immediately and processing happens in background
    Returns upload details with 'pending' status
    """
    # Generate upload ID early
    upload_id = uuid4()

    try:
        file_content = await file.read()
        file_size = len(file_content)

        # Reset file position for saving
        await file.seek(0)

        file_type, extension = await storage_service.validate_file(
            filename=file.filename or "unknown",
            mime_type=file.content_type or "application/octet-stream",
            file_size=file_size,
        )

        file_path = await storage_service.save_upload(
            file_content = file.file,
            user_id = current_user.id,
            upload_id = upload_id,
            extension = extension,
        )

        upload = await Upload.create(
            user_id = current_user.id,
            filename = file.filename or f"upload.{extension}",
            file_path = file_path,
            file_type = file_type,
            file_size = file_size,
            mime_type = file.content_type or "application/octet-stream",
            metadata = {
                "original_filename": file.filename,
                "upload_source": "web",
            },
            upload_id = upload_id,
        )

        # Queue background processing (fire and forget)
        task = asyncio.create_task(
            process_upload_background(
                upload_id = upload_id,
                user_id = current_user.id,
                file_type = file_type,
                extension = extension,
            )
        )
        # Store reference to prevent task from being garbage collected
        task.add_done_callback(lambda t: t.exception())

        logger.info(f"User {current_user.id} uploaded file {upload.id}")
        return UploadResponse.model_validate(upload)

    except StorageError as e:
        logger.error(f"Storage error during upload: {e}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error during upload: {e}")
        with contextlib.suppress(Exception):
            await storage_service.delete_upload(current_user.id, upload_id)
        raise
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity**: The function has a time complexity of \(O(1)\) for most operations, but the `storage_service.validate_file` and `storage_service.save_upload` calls could be costly if they involve database queries or complex computations.

**Space Complexity**: The space complexity is minimal as it primarily involves storing metadata. However, the use of `uuid4()` for generating an upload ID introduces a small overhead.

**Bottlenecks/Inefficiencies**:
1. **Redundant Operations**: Reading and then resetting the file position could be optimized by directly saving the file content.
2. **Background Task Management**: Storing the task reference to prevent garbage collection might not be necessary if the task is properly awaited or managed.

**Optimization Opportunities**:
1. **Direct File Saving**: Combine `await file.read()` and `await file.seek(0)` into a single operation by saving the file directly.
2. **Task Management**: Ensure tasks are properly awaited or use more efficient task management techniques to avoid unnecessary references.

**Resource Usage Concerns**:
- **File Handle Management**: Ensure that file handles are closed properly, especially if they are not used after the upload.
- **Error Handling**: The `with contextlib.suppress(Exception)` block might suppress important errors; consider logging or re-raising exceptions appropriately.

By addressing these points, you can improve both the efficiency and robustness of the code.

---

*Generated by CodeWorm on 2026-02-21 22:09*
