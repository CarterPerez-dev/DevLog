# RateLimiter._check_rate_limits

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/api-rate-limiter/src/fastapi_420/limiter.py
**Language:** python
**Lines:** 216-295
**Complexity:** 13.0

---

## Source Code

```python
async def _check_rate_limits(
        self,
        request: Request,
        rules: list[RateLimitRule],
        key_func: Callable[[Request],
                           str] | None = None,
        raise_on_limit: bool = True,
    ) -> RateLimitResult:
        """
        Check all rules and return/raise for the most restrictive failure
        """
        if not self._initialized:
            await self.init()

        storage = await self._get_active_storage()
        if storage is None:
            if self._settings.FAIL_OPEN:
                return RateLimitResult(
                    allowed = True,
                    limit = 0,
                    remaining = 0,
                    reset_after = 0,
                )
            raise StorageError(operation = "check", backend = None)

        fingerprint = await self._fingerprinter.extract(request)  # type: ignore[union-attr]
        endpoint = self._get_endpoint(request)

        if key_func:
            identifier = key_func(request)
        else:
            identifier = fingerprint.to_composite_key(
                self._settings.fingerprint.LEVEL
            )

        worst_result: RateLimitResult | None = None

        for rule in rules:
            key = RateLimitKey(
                prefix = self._settings.KEY_PREFIX,
                version = self._settings.KEY_VERSION,
                layer = Layer.USER,
                endpoint = endpoint,
                identifier = identifier,
                window = rule.window_seconds,
            ).build()

            result = await self._algorithm.check(  # type: ignore[union-attr]
                storage = storage,
                key = key,
                rule = rule,
            )

            if not result.allowed:  # noqa: SIM102
                if worst_result is None or result.retry_after > (worst_result.retry_after or 0):  # type: ignore[operator]
                    worst_result = result

        if worst_result is not None:
            if self._settings.LOG_VIOLATIONS:
                logger.warning(
                    "Rate limit exceeded",
                    extra = {
                        "endpoint": endpoint,
                        "identifier": identifier[: 16],
                        "remaining": worst_result.remaining,
                        "reset_after": worst_result.reset_after,
                    },
                )

            if raise_on_limit:
                raise EnhanceYourCalm(
                    result = worst_result,
                    message = self._settings.HTTP_420_MESSAGE,
                    detail = self._settings.HTTP_420_DETAIL,
                )

            return worst_result

        best_result = result
        return best_result
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is primarily driven by the loop over `rules` and the asynchronous call to `_algorithm.check`. This results in an overall complexity of \(O(n \cdot m)\), where \(n\) is the number of rules, and \(m\) is the latency of the async check.

**Space Complexity:** The space complexity is mainly influenced by the storage object (`storage`) and the `worst_result` variable. If `storage` is large or frequently updated, this could be a concern.

**Bottlenecks:**
1. **Async Calls:** The loop over rules involves multiple asynchronous calls to `_algorithm.check`, which can lead to increased latency.
2. **Redundant Operations:** The check for the most restrictive failure (`worst_result`) is redundant if `raise_on_limit` is set to `False`.

**Optimization Opportunities:**
1. **Batch Processing:** Consider batching the checks into fewer, larger async calls to reduce overhead.
2. **Memoization:** Cache results of `_algorithm.check` if they are likely to be reused.

**Resource Usage Concerns:**
- Ensure that `storage` is efficiently managed and not causing unnecessary memory leaks.
- Use context managers for any resources that need to be closed properly, such as database connections or file handles.

By optimizing the async calls and potentially caching results, you can reduce latency and improve overall performance.

---

*Generated by CodeWorm on 2026-02-18 14:44*
