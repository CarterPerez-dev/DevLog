# SQLiScanner._test_boolean_based_sqli

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/api-security-scanner/backend/scanners/sqli_scanner.py
**Language:** python
**Lines:** 141-214
**Complexity:** 15.0

---

## Source Code

```python
def _test_boolean_based_sqli(self) -> dict[str, Any]:
        """
        Test for boolean based blind SQL injection

        Compares responses from true vs false conditions to detect SQLi

        Returns:
            dict[str, Any]: Boolean based SQLi test results
        """
        try:
            baseline_response = self.make_request("GET", "/?id=1")
            baseline_length = len(baseline_response.text)
            baseline_status = baseline_response.status_code

            if baseline_status != 200:
                return {
                    "vulnerable": False,
                    "description": "Baseline request failed",
                    "baseline_status": baseline_status,
                }

            boolean_payloads = SQLiPayloads.BOOLEAN_BASED_BLIND
            true_payloads = [
                p for p in boolean_payloads
                if "AND '1'='1" in p or "AND 1=1" in p
            ]
            false_payloads = [
                p for p in boolean_payloads if "AND '1'='2" in p
                or "AND 1=2" in p or "AND 1=0" in p
            ]

            true_lengths = []
            for payload in true_payloads:
                response = self.make_request("GET", f"/?id={payload}")
                true_lengths.append(len(response.text))

            false_lengths = []
            for payload in false_payloads:
                response = self.make_request("GET", f"/?id={payload}")
                false_lengths.append(len(response.text))

            avg_true = statistics.mean(true_lengths)
            avg_false = statistics.mean(false_lengths)

            length_diff = abs(avg_true - avg_false)

            if length_diff > 100 and avg_true != avg_false:
                return {
                    "vulnerable":
                    True,
                    "baseline_length":
                    baseline_length,
                    "true_condition_avg_length":
                    avg_true,
                    "false_condition_avg_length":
                    avg_false,
                    "length_difference":
                    length_diff,
                    "confidence":
                    "HIGH" if length_diff > 500 else "MEDIUM",
                }

            return {
                "vulnerable": False,
                "description": "No boolean-based SQLi detected",
                "length_difference": length_diff,
            }

        except Exception as e:
            return {
                "vulnerable": False,
                "error": str(e),
                "description": "Error testing boolean-based SQLi",
            }
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n \cdot m)\), where \(n\) is the number of payloads in `boolean_payloads`, and \(m\) is the number of iterations for each payload (due to making separate requests). This can be costly, especially with many payloads.

**Space Complexity:** The space complexity is \(O(k + l)\) where \(k\) is the length of `true_lengths` and \(l\) is the length of `false_lengths`. Storing these lists can consume significant memory for large payload sets.

**Bottlenecks or Inefficiencies:**
1. **Redundant Requests:** Making separate requests for each true and false payload individually is inefficient.
2. **Blocking Calls:** The `make_request` function calls are blocking, which can slow down the process if multiple requests are made sequentially.
3. **Unnecessary Iterations:** The payloads are split into two lists based on conditions that could be optimized.

**Optimization Opportunities:**
1. **Batch Requests:** Use a single request with multiple payload parameters to reduce the number of calls.
2. **Concurrency:** Utilize `asyncio` or `concurrent.futures.ThreadPoolExecutor` for asynchronous requests to handle payloads concurrently.
3. **Payload Filtering:** Simplify payload filtering by directly checking conditions in the loop.

**Resource Usage Concerns:**
- Ensure proper handling and closing of connections if using a network library that requires it.
- Consider caching results from previous tests to avoid redundant checks.

By applying these optimizations, you can significantly improve the performance and efficiency of the function.

---

*Generated by CodeWorm on 2026-02-19 11:48*
