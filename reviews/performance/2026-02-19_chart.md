# chart

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/network-traffic-analyzer/src/netanal/main.py
**Language:** python
**Lines:** 363-423
**Complexity:** 8.0

---

## Source Code

```python
def chart(
    pcap_file: Annotated[
        Path,
        typer.Argument(help="PCAP file to visualize"),
    ],
    chart_type: Annotated[
        ChartType,
        typer.Option(
            "--type",
            "-t",
            help="Chart type",
        ),
    ] = "all",
    output: Annotated[
        Path | None,
        typer.Option(
            "--output",
            "-o",
            help="Output file path (for single chart)",
        ),
    ] = None,
    output_dir: Annotated[
        Path | None,
        typer.Option(
            "--output-dir",
            "-d",
            help="Output directory (for all charts)",
        ),
    ] = None,
) -> None:
    """
    [bold green]Generate charts[/bold green] from capture data

    Examples:
        netanal chart traffic.pcap --type protocols -o protocols.png
        netanal chart traffic.pcap --type all -d ./charts/
    """
    if not pcap_file.exists():
        print_error(f"File not found: {pcap_file}")
        raise typer.Exit(1)

    stats, _ = _analyze_pcap_to_stats(pcap_file)

    if chart_type == "all":
        out_dir = output_dir or Path()
        generated = generate_all_charts(stats, out_dir)
        for path in generated:
            print_success(f"Generated {path}")
    else:
        if not output:
            output = Path(f"{chart_type}.png")

        if chart_type == "protocols":
            fig = create_protocol_bar_chart(stats)
        elif chart_type == "top-talkers":
            fig = create_top_talkers_chart(stats)
        else:
            fig = create_bandwidth_chart(stats)

        save_chart(fig, output)
        print_success(f"Generated {output}")
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function's time complexity is primarily determined by the `_analyze_pcap_to_stats` call, which likely involves parsing the entire PCAP file. This operation can be costly, especially for large files. Generating charts (`generate_all_charts`, `create_protocol_bar_chart`, etc.) also adds to the computational load.

**Space Complexity:** The function uses significant memory to store parsed statistics and chart data. If the PCAP file is very large, this could lead to high memory usage.

**Bottlenecks or Inefficiencies:**
- **Redundant Checks:** The `if not pcap_file.exists()` check can be redundant if `_analyze_pcap_to_stats` already handles non-existent files.
- **Multiple Output Paths:** If both `output_dir` and `output` are provided, the function generates charts in two places, which is unnecessary.

**Optimization Opportunities:**
- **Lazy Parsing:** Consider using a streaming parser for PCAP files to reduce memory usage.
- **Conditional Generation:** Only generate necessary charts based on user input to save processing time.

**Resource Usage Concerns:**
- Ensure all file handles are properly closed using context managers or `with` statements to avoid resource leaks. For example, use `with open(pcap_file, 'rb') as f:` in `_analyze_pcap_to_stats`.

By addressing these points, you can improve the function's efficiency and reduce its memory footprint.

---

*Generated by CodeWorm on 2026-02-19 13:04*
