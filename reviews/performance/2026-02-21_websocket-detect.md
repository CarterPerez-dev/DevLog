# websocket_detect

**Type:** Performance Analysis
**Repository:** angelamos-operations
**File:** Angela-Wake/server/routes.py
**Language:** python
**Lines:** 66-129
**Complexity:** 17.0

---

## Source Code

```python
async def websocket_detect(websocket: WebSocket):
    await websocket.accept()

    model_paths = list(MODELS_DIR.glob("*.tflite")) + list(MODELS_DIR.glob("*.onnx"))
    if model_paths:
        m = Model(
            wakeword_models=[str(p) for p in model_paths],
            vad_threshold=VAD_THRESHOLD if ENABLE_VAD else None,
        )
    else:
        m = Model(vad_threshold=VAD_THRESHOLD if ENABLE_VAD else None)

    model_names = list(m.models.keys())
    frame_count = 0

    try:
        while True:
            msg = await websocket.receive()

            if msg.get('type') == 'websocket.disconnect':
                break

            if 'text' in msg:
                if msg['text'] == 'reset':
                    m.reset()
                    print("[DEBUG] Model reset")
                continue

            if 'bytes' not in msg:
                continue

            data = msg['bytes']
            audio = np.frombuffer(data, dtype=np.int16)
            frame_count += 1

            orig_len = len(audio)
            orig_amp = np.max(np.abs(audio))

            if len(audio) != TARGET_SAMPLES:
                ratio = len(audio) // TARGET_SAMPLES
                if ratio > 1:
                    audio = audio[::ratio][:TARGET_SAMPLES]
                else:
                    audio = signal.resample_poly(audio, TARGET_SAMPLES, len(audio)).astype(np.int16)

            predictions = m.predict(audio)

            for name in model_names:
                score = predictions.get(name, 0.0)
                if frame_count % 50 == 0:
                    print(f"[DEBUG] Frame {frame_count}: orig_len={orig_len}, orig_amp={orig_amp}, {name}={score:.4f}")
                if score >= DETECTION_THRESHOLD:
                    await websocket.send_json(
                        {
                            "detected": True,
                            "model": name,
                            "score": float(score),
                        }
                    )

    except WebSocketDisconnect:
        pass
    except Exception as e:
        await websocket.close(code = 1011, reason = str(e))
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity is primarily determined by the `m.predict(audio)` call, which can be costly depending on the model's size and complexity. The loop runs indefinitely until a disconnect signal, making it O(âˆž) in worst-case scenarios.

**Space Complexity:** The space complexity is moderate due to storing audio data (`audio`) and predictions (`predictions`). However, using `np.frombuffer` and slicing operations can be optimized for memory efficiency.

**Bottlenecks:**
1. **Model Initialization:** Loading all models from the directory (`model_paths`) can be slow if there are many files.
2. **Resampling Logic:** The resampling logic inside the loop is redundant, especially when `len(audio) == TARGET_SAMPLES`.
3. **Debug Print Statements:** Frequent debug prints can impact performance.

**Optimization Opportunities:**
1. **Lazy Model Loading:** Load models only as needed instead of upfront.
2. **Efficient Resampling:** Use more efficient resampling methods or avoid resampling if not necessary.
3. **Remove Redundant Operations:** Simplify the condition checks and remove unnecessary operations like debug prints.

**Resource Usage:**
- Ensure `Model` instances are properly managed to prevent memory leaks.
- Close any unclosed resources within the exception handler.

By addressing these points, you can significantly improve the performance and efficiency of your WebSocket detection function.

---

*Generated by CodeWorm on 2026-02-21 16:55*
