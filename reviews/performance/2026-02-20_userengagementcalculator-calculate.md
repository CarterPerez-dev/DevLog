# UserEngagementCalculator.calculate_engagement_score

**Type:** Performance Analysis
**Repository:** CertGames-Core
**File:** backend/api/admin/domains/users/queries.py
**Language:** python
**Lines:** 192-262
**Complexity:** 20.0

---

## Source Code

```python
def calculate_engagement_score(self) -> tuple[float, dict[str, float]]:
        """
        Calculate engagement score (0-100) based on activity
        """
        score = 0.0
        factors = {}

        if self.user.lastLoginAt:
            days_since_login = (
                datetime.now(UTC) - (
                    self.user.lastLoginAt.replace(tzinfo = UTC)
                    if self.user.lastLoginAt.tzinfo is None else
                    self.user.lastLoginAt
                )
            ).days
            if days_since_login == 0:
                login_score = 25
            elif days_since_login <= 7:
                login_score = 20
            elif days_since_login <= 30:
                login_score = 10
            else:
                login_score = 0
            factors['login_frequency'] = float(login_score)
            score += login_score
        else:
            factors['login_frequency'] = 0.0

        tests_per_day = self.test_attempts / self.days_since_signup
        if tests_per_day >= 1:
            test_score = 25
        elif tests_per_day >= 0.5:
            test_score = 20
        elif tests_per_day >= 0.1:
            test_score = 10
        else:
            test_score = 5 if self.test_attempts > 0 else 0
        factors['test_activity'] = float(test_score)
        score += test_score

        achievement_count = len(
            self.user.achievements_v2
        ) if self.user.achievements_v2 else 0
        if achievement_count >= 20:
            achievement_score = 25
        elif achievement_count >= 10:
            achievement_score = 20
        elif achievement_count >= 5:
            achievement_score = 15
        elif achievement_count >= 1:
            achievement_score = 10
        else:
            achievement_score = 0
        factors['achievement_progress'] = float(achievement_score)
        score += achievement_score

        expected_level = min(self.days_since_signup / 10, 50)
        if self.user.level >= expected_level:
            level_score = 25
        elif self.user.level >= expected_level * 0.75:
            level_score = 20
        elif self.user.level >= expected_level * 0.5:
            level_score = 15
        elif self.user.level >= expected_level * 0.25:
            level_score = 10
        else:
            level_score = 5 if self.user.level > 1 else 0
        factors['level_progression'] = float(level_score)
        score += level_score

        return score, factors
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of the `calculate_engagement_score` function is \(O(1)\), as it involves a fixed number of operations regardless of input size.

#### Space Complexity and Memory Allocation
- The space complexity is also \(O(1)\) since no additional data structures are created that scale with input size. Only local variables (`score`, `factors`) and temporary values are used.
- Ensure that the `user` object attributes (e.g., `lastLoginAt`, `test_attempts`, `achievements_v2`, `level`, `days_since_signup`) are efficiently accessible.

#### Bottlenecks or Inefficiencies
1. **Redundant Type Casting**: Converting integers to floats for factors is unnecessary, as factors can be stored as integers.
2. **Multiple Condition Checks**: The nested ternary operators and multiple condition checks in each factor calculation can be simplified using dictionaries or a more structured approach.

#### Optimization Opportunities
- Replace the nested ternary operators with a dictionary mapping conditions to scores:
  ```python
  login_score = {
      0: 25,
      <=7: 20,
      <=30: 10,
      >30: 0
  }.get(days_since_login, 0)
  ```
- Simplify the `test_activity` calculation similarly:
  ```python
  test_score = {
      >=1: 25,
      >=0.5: 20,
      >=0.1: 10,
      >0: 5,
      ==0: 0
  }.get(test_per_day, 0)
  ```

#### Resource Usage Concerns
- Ensure that `self.user` and its attributes are efficiently accessed to avoid unnecessary database queries or API calls.
- Use context managers for any file or network operations if they exist.

By applying these optimizations, the code will be more readable and maintainable while maintaining efficient performance.

---

*Generated by CodeWorm on 2026-02-20 16:17*
