# InterestScorer._calculate_pattern_bonus

**Type:** Performance Analysis
**Repository:** CodeWorm
**File:** codeworm/analysis/scoring.py
**Language:** python
**Lines:** 208-240
**Complexity:** 11.0

---

## Source Code

```python
def _calculate_pattern_bonus(
        self,
        decorators: list[str] | None,
        is_async: bool,
        source: str,
    ) -> float:
        """
        Calculate bonus points for interesting code patterns
        """
        bonus = 0.0

        if is_async:
            bonus += self.PATTERN_BONUSES["async"]

        if decorators:
            bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]

            decorator_text = " ".join(decorators).lower()
            if "property" in decorator_text:
                bonus += self.PATTERN_BONUSES["property"]
            if "classmethod" in decorator_text or "staticmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["class_method"]
            if "abstractmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["abstract"]
            if "dataclass" in decorator_text:
                bonus += self.PATTERN_BONUSES["dataclass"]

        if "yield" in source:
            bonus += self.PATTERN_BONUSES["generator"]
        if "__enter__" in source or "__exit__" in source:
            bonus += self.PATTERN_BONUSES["context_manager"]

        return bonus
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n)\), where \(n\) is the length of `decorators`. This is due to the iteration over `decorators` and the membership checks in `decorator_text`.

**Space Complexity:** The space complexity is \(O(1)\) since no additional data structures depend on input size. However, string concatenation in `decorator_text = " ".join(decorators).lower()` creates a new string each time, which can be inefficient for large lists.

**Bottlenecks or Inefficiencies:**
- The function performs multiple membership checks (`"property"`, `"classmethod"`, etc.) on the concatenated and lowercased string `decorator_text`. This is costly if `decorators` is long.
- Redundant operations like creating a new string each time `decorator_text` is updated.

**Optimization Opportunities:**
- Use a set for membership checks to reduce complexity from \(O(n)\) to \(O(1)\).
  ```python
  decorator_set = {"property", "classmethod", "staticmethod", "abstractmethod", "dataclass"}
  bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]
  if any(d in decorator_set for d in decorators):
      ...
  ```
- Avoid creating a new string by using `join` only once.
  ```python
  decorator_text = " ".join(decorators).lower()
  ```

**Resource Usage Concerns:**
- No resource leaks or blocking calls identified. Ensure that `PATTERN_BONUSES` is properly defined and does not cause any issues.

By applying these optimizations, the function will be more efficient, especially for large lists of decorators.

---

*Generated by CodeWorm on 2026-02-22 08:14*
