# capture

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/network-traffic-analyzer/src/netanal/main.py
**Language:** python
**Lines:** 111-212
**Complexity:** 7.0

---

## Source Code

```python
def capture(
    interface: Annotated[
        str | None,
        typer.Option(
            "--interface",
            "-i",
            help="Network interface to capture on",
        ),
    ] = None,
    filter_expr: Annotated[
        str | None,
        typer.Option(
            "--filter",
            "-f",
            help="BPF filter expression",
        ),
    ] = None,
    count: Annotated[
        int | None,
        typer.Option(
            "--count",
            "-c",
            help="Number of packets to capture",
        ),
    ] = None,
    timeout: Annotated[
        float | None,
        typer.Option(
            "--timeout",
            "-t",
            help="Capture timeout in seconds",
        ),
    ] = None,
    output: Annotated[
        Path | None,
        typer.Option(
            "--output",
            "-o",
            help="Output file for results (JSON)",
        ),
    ] = None,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            help="Show individual packets",
        ),
    ] = False,
) -> None:
    """
    [bold green]Capture[/bold green] live network packets

    Examples:
        netanal capture -i eth0 --count 100
        netanal capture --filter "tcp port 80" --timeout 30
        netanal capture -i lo -c 50 --verbose
    """
    can_capture, msg = check_capture_permissions()
    if not can_capture:
        print_error(f"Cannot capture packets: {msg}")
        raise typer.Exit(1)

    if filter_expr and not validate_bpf_filter(filter_expr):
        print_error(f"Invalid BPF filter: {filter_expr}")
        raise typer.Exit(1)

    config = CaptureConfig(
        interface=interface,
        bpf_filter=filter_expr,
        packet_count=count,
        timeout_seconds=timeout,
    )

    packets_captured: list[PacketInfo] = []

    def on_packet(packet: PacketInfo) -> None:
        if verbose:
            print_packet(packet)
        if output:
            packets_captured.append(packet)

    console.print(
        f"[cyan]Starting capture on {interface or 'all interfaces'}...[/cyan]"
    )
    console.print("[dim]Press Ctrl+C to stop[/dim]\n")

    engine = CaptureEngine(
        config=config,
        on_packet=on_packet if verbose or output else None
    )

    with GracefulCapture(engine) as cap:
        stats = cap.wait()

    console.print()
    print_capture_summary(stats)
    print_protocol_table(stats)
    print_top_talkers(stats)

    if output:
        export_to_json(stats, output, packets_captured)
        print_success(f"Results saved to {output}")
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function's time complexity is primarily determined by the packet capture process, which can be O(n), where n is the number of packets captured. However, the `validate_bpf_filter` and `check_capture_permissions` functions introduce additional overhead.

**Space Complexity:** The space complexity is O(n) due to storing captured packets in the `packets_captured` list. This could lead to memory issues if capturing a large number of packets.

**Bottlenecks or Inefficiencies:**
1. **Redundant Operations:** The `validate_bpf_filter` and `check_capture_permissions` checks are performed unconditionally, even when their results are not used.
2. **Unnecessary Iterations:** If `verbose` is set to `False`, the `on_packet` function still gets called with a condition check, which can be optimized away.

**Optimization Opportunities:**
1. **Conditional Checks:** Move `validate_bpf_filter` and `check_capture_permissions` inside conditional blocks where they are actually used.
2. **Lazy Initialization:** Use lazy initialization for `engine` to avoid unnecessary object creation unless the `on_packet` callback is needed.

**Resource Usage Concerns:**
- Ensure that file handles (`output`) are properly closed using context managers or explicit `close()` calls.
- Consider implementing a timeout mechanism in `GracefulCapture` to handle long-running captures gracefully.

### Suggested Optimizations

1. **Conditional Checks:**
   ```python
   if filter_expr and not validate_bpf_filter(filter_expr):
       print_error(f"Invalid BPF filter: {filter_expr}")
       raise typer.Exit(1)
   
   if can_capture:
       config = CaptureConfig(
           interface=interface,
           bpf_filter=filter_expr,
           packet_count=count,
           timeout_seconds=timeout,
       )
       
       engine = CaptureEngine(
           config=config,
           on_packet=on_packet if verbose or output else None
       )

       with GracefulCapture(engine) as cap:
           stats = cap.wait()
   ```

2. **Lazy Initialization:**
   ```python
   engine = CaptureEngine(config=None, on_packet=None)
   
   if verbose or output:
       engine.config = config
       engine.on_packet = on_packet

   with GracefulCapture(engine) as cap:
       stats = cap.wait()
   ```

By addressing these points, you can improve the efficiency and resource management of your code.

---

*Generated by CodeWorm on 2026-02-18 20:39*
