# checkAddInstruction

**Type:** Performance Analysis
**Repository:** docksec
**File:** internal/analyzer/dockerfile.go
**Language:** go
**Lines:** 159-205
**Complexity:** 11.0

---

## Source Code

```go
func (a *DockerfileAnalyzer) checkAddInstruction(
	target finding.Target,
	ast *parser.Node,
) finding.Collection {
	var findings finding.Collection

	for _, node := range ast.Children {
		if strings.ToUpper(node.Value) == "ADD" {
			src := ""
			if node.Next != nil {
				src = node.Next.Value
			}

			isURL := strings.HasPrefix(src, "http://") ||
				strings.HasPrefix(src, "https://")
			isArchive := strings.HasSuffix(src, ".tar") ||
				strings.HasSuffix(src, ".tar.gz") ||
				strings.HasSuffix(src, ".tgz") ||
				strings.HasSuffix(src, ".tar.bz2")

			if !isURL && !isArchive {
				control, _ := benchmark.Get("4.9")
				loc := &finding.Location{Path: a.path, Line: node.StartLine}
				f := finding.New("CIS-4.9", control.Title, finding.SeverityLow, target).
					WithDescription(control.Description).
					WithCategory(string(CategoryDockerfile)).
					WithLocation(loc).
					WithRemediation(control.Remediation).
					WithReferences(control.References...).
					WithCISControl(control.ToCISControl())
				findings = append(findings, f)
			}

			if isURL {
				loc := &finding.Location{Path: a.path, Line: node.StartLine}
				f := finding.New("DS-ADD-URL", "ADD instruction fetches from URL", finding.SeverityMedium, target).
					WithDescription("ADD with URLs can introduce security risks. Use curl/wget with verification instead.").
					WithCategory(string(CategoryDockerfile)).
					WithLocation(loc).
					WithRemediation("Use RUN with curl or wget and verify checksums of downloaded files.")
				findings = append(findings, f)
			}
		}
	}

	return findings
}
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n \times m)\), where \(n\) is the number of nodes in the AST, and \(m\) is the number of operations performed on each node (e.g., string comparisons). This can be optimized by reducing redundant operations.

**Space Complexity:** The space complexity is primarily determined by the `findings` collection. If many findings are generated, this could lead to increased memory usage. Ensure that `finding.New` and other allocations are efficient.

**Bottlenecks:**
- **Redundant Operations:** The string comparisons (`strings.HasPrefix`, `strings.HasSuffix`) are performed multiple times for each node.
- **Error Handling:** The error handling in `control, _ := benchmark.Get("4.9")` is ignored, which could lead to silent failures.

**Optimization Opportunities:**
1. **Cache String Comparisons:** Use a map or set to cache the results of string comparisons to avoid redundant checks.
2. **Improve Error Handling:** Handle errors properly by logging them instead of ignoring them.
3. **Reduce Redundant Operations:** Move common operations outside loops, such as initializing `loc` and `f`.

**Resource Usage Concerns:**
- Ensure that all resources are closed properly if necessary, although this function does not appear to use any external connections or file handles.

By optimizing string comparisons and improving error handling, you can enhance the efficiency of the function.

---

*Generated by CodeWorm on 2026-02-22 00:05*
