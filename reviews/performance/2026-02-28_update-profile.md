# update_profile

**Type:** Performance Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/siem-dashboard/backend/app/controllers/auth_ctrl.py
**Language:** python
**Lines:** 99-149
**Complexity:** 11.0

---

## Source Code

```python
def update_profile() -> dict[str, Any]:
    """
    Update the authenticated user's own profile fields
    """
    user = g.current_user
    data = g.validated

    is_valid, _ = verify_password(data.current_password, user.password_hash)
    if not is_valid:
        raise AuthenticationError("Current password is incorrect")

    updates: dict[str, str] = {}

    if data.username is not None and data.username != user.username:
        if User.username_exists(data.username):
            raise ConflictError("Username already taken")
        updates["username"] = data.username

    if data.email is not None and data.email != user.email:
        if User.email_exists(data.email):
            raise ConflictError("Email already registered")
        updates["email"] = data.email

    if data.password is not None:
        updates["password_hash"] = hash_password(data.password)

    if not updates:
        raise ValidationError("No fields to update")

    user.update_profile(**updates)

    new_token: str | None = None
    if "username" in updates:
        new_token = create_access_token(
            user_id = str(user.id),
            extra_claims = {
                "username": user.username,
                "role": user.role,
            },
        )

    return UpdateProfileResponse(
        user = UserResponse(
            id = str(user.id),
            username = user.username,
            email = user.email,
            role = user.role,
            is_active = user.is_active,
        ),
        access_token = new_token,
    ).model_dump(exclude_none = True)
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The time complexity of `update_profile` is \(O(1)\) for most operations, but it can be up to \(O(n)\) due to the `username_exists` and `email_exists` checks, where \(n\) is the number of users. The password hashing operation also adds a constant overhead.

**Space Complexity:** The space complexity is \(O(1)\), as no additional data structures grow with input size. However, the `updates` dictionary can hold up to 3 key-value pairs, which is a small constant.

### Bottlenecks and Inefficiencies

- **Redundant Checks:** The `username_exists` and `email_exists` checks are called twice for each potential update, leading to redundant database queries.
- **Blocking Calls:** The `User.username_exists` and `User.email_exists` calls block the execution until a response is received from the database.

### Optimization Opportunities

1. **Reduce Redundant Checks:** Combine the username and email existence checks into one call if possible, reducing the number of database hits to 2.
2. **Use Async Contexts:** If the database operations are async, ensure they are awaited properly to avoid blocking calls.
3. **Caching:** Cache the results of `username_exists` and `email_exists` for a short period to reduce repeated checks.

### Resource Usage Concerns

- Ensure that all database connections are properly managed using context managers or connection pools to prevent resource leaks.
- Use type hints consistently throughout the codebase to improve readability and maintainability.

By addressing these points, you can significantly enhance the performance and efficiency of the `update_profile` function.

---

*Generated by CodeWorm on 2026-02-28 21:07*
