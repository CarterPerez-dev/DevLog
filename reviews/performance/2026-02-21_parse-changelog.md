# parse_changelog

**Type:** Performance Analysis
**Repository:** vuemantics
**File:** backend/routers/v1/changelog.py
**Language:** python
**Lines:** 28-103
**Complexity:** 27.0

---

## Source Code

```python
def parse_changelog() -> ChangelogResponse:
    """
    Parse CHANGELOG.md and return structured data
    """
    if not CHANGELOG_PATH.exists():
        return ChangelogResponse(versions = [])

    content = CHANGELOG_PATH.read_text(encoding = "utf-8")
    versions = []

    # Match version headers: ## [1.0.1] - 2026-01-26
    version_pattern = r"##\s+\[([^\]]+)\]\s+-\s+(\d{4}-\d{2}-\d{2})"
    version_matches = list(re.finditer(version_pattern, content))

    for i, match in enumerate(version_matches):
        version_num = match.group(1)
        date = match.group(2)

        start = match.end()
        end = version_matches[i + 1].start(
        ) if i + 1 < len(version_matches) else len(content)
        version_content = content[start : end]

        changes = ChangelogSection()
        current_section = None
        items: list[str] = []

        for line in version_content.split("\n"):
            line = line.strip()

            if line.startswith("### Added"):
                if current_section and items:
                    setattr(changes, current_section, items)
                current_section = "added"
                items = []
            elif line.startswith("### Changed"):
                if current_section and items:
                    setattr(changes, current_section, items)
                current_section = "changed"
                items = []
            elif line.startswith("### Deprecated"):
                if current_section and items:
                    setattr(changes, current_section, items)
                current_section = "deprecated"
                items = []
            elif line.startswith("### Removed"):
                if current_section and items:
                    setattr(changes, current_section, items)
                current_section = "removed"
                items = []
            elif line.startswith("### Fixed"):
                if current_section and items:
                    setattr(changes, current_section, items)
                current_section = "fixed"
                items = []
            elif line.startswith("### Security"):
                if current_section and items:
                    setattr(changes, current_section, items)
                current_section = "security"
                items = []

            elif line.startswith("- ") and current_section:
                items.append(line[2 :])

        if current_section and items:
            setattr(changes, current_section, items)

        versions.append(
            ChangelogVersion(
                version = version_num,
                date = date,
                changes = changes,
            )
        )

    return ChangelogResponse(versions = versions)
```

---

## Performance Analysis

### Performance Analysis

**Time Complexity:** The function has a time complexity of \(O(n^2)\) due to the nested loop where `version_content.split("\n")` is iterated over for each version, and `len(version_matches)` can be large.

**Space Complexity:** The space complexity is \(O(m + n)\), where \(m\) is the number of versions and \(n\) is the length of the changelog content. This is due to storing the parsed versions in memory.

**Bottlenecks or Inefficiencies:**
1. **Nested Loops:** The nested loop iterating over each line for different sections can be costly, especially if there are many lines per version.
2. **Redundant Operations:** `current_section` and `items` are reset multiple times within the same loop, which is redundant.

**Optimization Opportunities:**
1. **Use a Dictionary:** Store section names in a dictionary to map them directly instead of using `if-elif` statements.
2. **Early Exit:** If no sections are found for a version, exit early from the inner loop to avoid unnecessary operations.
3. **Memoization:** Cache results if parsing is done frequently with the same changelog content.

**Resource Usage Concerns:**
1. **File Handling:** The `CHANGELOG_PATH.read_text()` call reads the entire file into memory at once, which could be inefficient for large files.
2. **Memory Leaks:** Ensure that all objects are properly garbage collected and no unclosed resources exist.

By optimizing the nested loops and using data structures like dictionaries, you can significantly reduce the time complexity and improve overall performance.

---

*Generated by CodeWorm on 2026-02-21 21:43*
