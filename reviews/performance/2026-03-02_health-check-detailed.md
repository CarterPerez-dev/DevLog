# health_check_detailed

**Type:** Performance Analysis
**Repository:** my-portfolio
**File:** v1/backend/app/core/health_routes.py
**Language:** python
**Lines:** 49-80
**Complexity:** 5.0

---

## Source Code

```python
async def health_check_detailed() -> HealthDetailedResponse:
    """
    Detailed health check including database connectivity
    """
    db_status = HealthStatus.UNHEALTHY
    redis_status = None

    try:
        async with sessionmanager.connect() as conn:
            await conn.execute(text("SELECT 1"))
            db_status = HealthStatus.HEALTHY
    except Exception:
        db_status = HealthStatus.UNHEALTHY

    if settings.REDIS_URL:
        try:
            r = redis.from_url(str(settings.REDIS_URL))
            await r.ping()
            redis_status = HealthStatus.HEALTHY
            await r.close()
        except Exception:
            redis_status = HealthStatus.UNHEALTHY

    overall = HealthStatus.HEALTHY if db_status == HealthStatus.HEALTHY else HealthStatus.DEGRADED

    return HealthDetailedResponse(
        status = overall,
        environment = settings.ENVIRONMENT.value,
        version = settings.APP_VERSION,
        database = db_status,
        redis = redis_status,
    )
```

---

## Performance Analysis

### Performance Analysis

#### Time Complexity
The time complexity of `health_check_detailed` is O(1), as the operations are constant-time, involving database and Redis checks.

#### Space Complexity
Space complexity is also O(1) since no additional space scales with input size. The primary variables (`db_status`, `redis_status`) do not grow with the input data.

#### Bottlenecks or Inefficiencies
- **Redundant Exception Handling**: Both database and Redis connection attempts are wrapped in try-except blocks, which can be costly if exceptions are frequent.
- **Unclosed Connections**: The Redis connection is closed explicitly, but this could be handled by using a context manager to ensure proper closure.

#### Optimization Opportunities
1. **Use `async with` for Redis**: Ensure the Redis connection is properly managed:
   ```python
   async def health_check_detailed() -> HealthDetailedResponse:
       db_status = HealthStatus.UNHEALTHY
       redis_status = None

       try:
           async with sessionmanager.connect() as conn:
               await conn.execute(text("SELECT 1"))
               db_status = HealthStatus.HEALTHY
       except Exception:
           db_status = HealthStatus.UNHEALTHY

       if settings.REDIS_URL:
           try:
               r = redis.from_url(str(settings.REDIS_URL))
               async with r as redis_client:
                   await redis_client.ping()
                   redis_status = HealthStatus.HEALTHY
           except Exception:
               redis_status = HealthStatus.UNHEALTHY

       overall = HealthStatus.HEALTHY if db_status == HealthStatus.HEALTHY else HealthStatus.DEGRADED

       return HealthDetailedResponse(
           status=overall,
           environment=settings.ENVIRONMENT.value,
           version=settings.APP_VERSION,
           database=db_status,
           redis=redis_status,
       )
   ```

2. **Reduce Exception Handling**: Consider logging exceptions instead of catching them broadly to avoid performance hits.

3. **Caching**: If this function is called frequently, consider caching the results using a library like `functools.lru_cache`.

#### Resource Usage Concerns
- Ensure that database and Redis connections are properly managed to prevent resource leaks.
- Use context managers (`async with`) for automatic cleanup of resources.

---

*Generated by CodeWorm on 2026-03-02 08:01*
