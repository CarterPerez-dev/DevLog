# git

**Type:** Code Evolution
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/source/git.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: 294169a2
Message: feat: Complete Go secrets scanner - Portia
Author: CarterPerez-dev
File: PROJECTS/intermediate/secrets-scanner/internal/source/git.go
Change type: new file

Diff:
@@ -0,0 +1,313 @@
+// Â©AngelaMos | 2026
+// git.go
+
+package source
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"path/filepath"
+	"strings"
+	"time"
+
+	"github.com/go-git/go-git/v5"
+	"github.com/go-git/go-git/v5/plumbing"
+	"github.com/go-git/go-git/v5/plumbing/object"
+	"github.com/go-git/go-git/v5/plumbing/storer"
+
+	"github.com/CarterPerez-dev/portia/pkg/types"
+)
+
+type Git struct {
+	RepoPath   string
+	Branch     string
+	Since      string
+	Depth      int
+	StagedOnly bool
+	MaxSize    int64
+	Excludes   []string
+}
+
+func NewGit(
+	repoPath string,
+	branch string,
+	since string,
+	depth int,
+	stagedOnly bool,
+	maxSize int64,
+	excludes []string,
+) *Git {
+	if maxSize <= 0 {
+		maxSize = defaultMaxFileSize
+	}
+	return &Git{
+		RepoPath:   repoPath,
+		Branch:     branch,
+		Since:      since,
+		Depth:      depth,
+		StagedOnly: stagedOnly,
+		MaxSize:    maxSize,
+		Excludes:   excludes,
+	}
+}
+
+func (g *Git) String() string {
+	return "git:" + g.RepoPath
+}
+
+func (g *Git) Chunks(
+	ctx context.Context, out chan<- types.Chunk,
+) error {
+	repo, err := git.PlainOpen(g.RepoPath)
+	if err != nil {
+		return fmt.Errorf("open repository: %w", err)
+	}
+
+	if g.StagedOnly {
+		return g.scanStaged(ctx, repo, out)
+	}
+
+	return g.scanHistory(ctx, repo, out)
+}
+
+func (g *Git) scanStaged(
+	ctx context.Context,
+	repo *git.Repository,
+	out chan<- types.Chunk,
+) error {
+	wt, err := repo.Worktree()
+	if err != nil {
+		return fmt.Errorf("worktree: %w", err)
+	}
+
+	status, err := wt.Status()
+	if err != nil {
+		return fmt.Errorf("status: %w", err)
+	}
+
+	idx, err := repo.Storer.Index()
+	if err != nil {
+		return fmt.Errorf("index: %w", err)
+	}
+
+	for _, entry := range idx.Entries {
+		if ctx.Err() != nil {
+			return ctx.Err()
+		}
+
+		fileStatus := status.File(entry.Name)
+		if fileStatus.Staging == git.Unmodified &&
+			fileStatus.Worktree == git.Unmodified {
+			continue
+		}
+
+		if g.isExcluded(entry.Name) || isBinaryExt(entry.Name) {
+			continue
+		}
+
+		blob, blobErr := repo.BlobObject(entry.Hash)
+		if blobErr != nil {
+			continue
+		}
+
+		if blob.Size > g.MaxSize {
+			continue
+		}
+
+		content, readErr := readBlob(blob)
+		if readErr != nil {
+			continue
+		}
+
+		chunks := splitIntoChunks(
+			content, entry.Name, "", "", time.Time{},
+		)
+		for _, chunk := range chunks {
+			select {
+			case <-ctx.Done():
+				return ctx.Err()
+			case out <- chunk:
+			}
+		}
+	}
+
+	return nil
+}
+
+func (g *Git) scanHistory( //nolint:gocognit
+	ctx context.Context,
+	repo *git.Repository,
+	out chan<- types.Chunk,
+) error {
+	ref, err := g.resolveRef(repo)
+	if err != nil {
+		return err
+	}
+
+	logOpts := &git.LogOptions{
+		From:  ref.Hash(),
+		Order: git.LogOrderCommitterTime,
+	}
+
+	if g.Since != "" {
+		sinceTime, parseErr :=
```

---

## Code Evolution

### Change Analysis for `git.go`

**What was Changed:**
The commit introduces a new file, `git.go`, within the `internal/source` package of the `secrets-scanner` project. This file defines a `Git` struct and its associated methods to scan Git repositories for secrets. The code handles both staged changes and historical commits, with filtering based on size, exclusions, and branch/commit depth.

**Why it was Likely Changed:**
This change likely aims to enhance the `secrets-scanner` tool by adding comprehensive support for scanning Git repositories. By implementing methods to scan both staged and historical changes, the tool can detect secrets at various points in a repository's history, improving its effectiveness.

**Impact on Behavior:**
The new functionality allows the scanner to analyze not only current staged changes but also historical commits up to a specified depth. This increases the likelihood of detecting secret leaks that might have occurred in the past. The inclusion of size and exclusion filters ensures that large or irrelevant files are ignored, optimizing performance.

**Risks or Concerns:**
- **Complexity**: The `scanHistory` function is complex due to its nested loops and error handling. This could lead to maintenance challenges.
- **Resource Usage**: Scanning historical commits can be resource-intensive, especially for large repositories with many commits.
- **Error Handling**: While the code handles some errors gracefully by ignoring certain files, it may miss important issues if not all error paths are properly managed.

Overall, this change significantly enhances the tool's capabilities but requires careful testing and monitoring to ensure robustness.

---

*Generated by CodeWorm on 2026-02-22 21:51*
