# performance

**Type:** Code Evolution
**Repository:** kill-pr0cess.inc
**File:** backend/src/routes/performance.rs
**Language:** rust
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```rust
Commit: cd9fb0c6
Message: holy moly its a masterpeice
Author: CarterPerez-dev
File: backend/src/routes/performance.rs
Change type: modified

Diff:
@@ -113,10 +113,21 @@ pub async fn get_current_metrics(
         active_processes: system.processes().len() as u32,
     };
 
+    let cpu_threads = system.cpus().len() as u32;
+    let cpu_cores = system.physical_core_count()
+        .map(|c| c as u32)
+        .unwrap_or_else(|| {
+            if cpu_threads > 0 { (cpu_threads / 2).max(1) } else { 1 }
+        });
+
     let hardware_info = HardwareInfo {
-        cpu_model: system.global_cpu_info().brand().to_string(),
-        cpu_cores: system.physical_core_count().unwrap_or(0) as u32,
-        cpu_threads: system.cpus().len() as u32,
+        cpu_model: if system.global_cpu_info().brand().is_empty() {
+            "Unknown CPU".to_string()
+        } else {
+            system.global_cpu_info().brand().to_string()
+        },
+        cpu_cores,
+        cpu_threads,
         architecture: std::env::consts::ARCH.to_string(),
         total_memory_gb: system.total_memory() as f64 / (1024.0 * 1024.0 * 1024.0),
     };
@@ -201,12 +212,14 @@ pub async fn run_benchmark(
         serde_json::json!({
             "single_thread": {
                 "primes_found": single_thread_primes,
-                "duration_ms": single_thread_time.as_millis(),
+                "duration_ms": single_thread_time.as_secs_f64() * 1000.0,
+                "duration_us": single_thread_time.as_micros(),
                 "primes_per_second": single_thread_primes as f64 / single_thread_time.as_secs_f64()
             },
             "multi_thread": {
                 "primes_found": multi_thread_primes,
-                "duration_ms": multi_thread_time.as_millis(),
+                "duration_ms": multi_thread_time.as_secs_f64() * 1000.0,
+                "duration_us": multi_thread_time.as_micros(),
                 "primes_per_second": multi_thread_primes as f64 / multi_thread_time.as_secs_f64()
             },
             "parallel_efficiency": (multi_thread_primes as f64 / multi_thread_time.as_secs_f64()) /
@@ -234,17 +247,20 @@ pub async fn run_benchmark(
 
         serde_json::json!({
             "allocation": {
-                "duration_ms": allocation_time.as_millis(),
+                "duration_ms": allocation_time.as_secs_f64() * 1000.0,
+                "duration_us": allocation_time.as_micros(),
                 "mb_allocated": (data_size * 8) as f64 / (1024.0 * 1024.0),
                 "mb_per_second": (data_size * 8) as f64 / (1024.0 * 1024.0) / allocation_time.as_secs_f64()
             },
             "sequential_read": {
-                "duration_ms": read_time.as_millis(),
+                "duration_ms": read_time.as_secs_f64() * 1000.0,
+                "duration_us": read_time.as_micros(),
                 "sum_result": sum,
                 "mb_per_second": (data_size * 8) as f64 / (1024.0 * 1024.0) / read_time.as_secs_f64()
             },
       
```

---

## Code Evolution

### Change Analysis

**What was Changed:**
The code added and modified several lines to improve handling of CPU-related data, benchmark results, and memory operations. Specifically:
- Added `cpu_threads` and `cpu_cores` calculations.
- Updated the `HardwareInfo` struct with conditional logic for the CPU model.
- Adjusted time measurements in benchmarks from milliseconds to seconds for more precise reporting.

**Why it was Likely Changed:**
These changes likely aim to provide more accurate and detailed performance metrics. The new handling of CPU information ensures that "Unknown CPU" is used when necessary, improving user experience. Time measurements now use `as_secs_f64()` for better precision, especially in multi-threaded operations.

**Impact on Behavior:**
The updated code will report more precise durations and handle unknown CPUs gracefully. This could lead to more reliable performance analysis, particularly in environments with multiple CPU cores or when the exact CPU model is not known.

**Risks or Concerns:**
- The introduction of `unwrap_or_else` might introduce a risk if the physical core count cannot be determined.
- The use of floating-point arithmetic for time measurements could lead to precision issues if not handled carefully. However, this seems mitigated by using `as_secs_f64()`.

Overall, these changes enhance the robustness and accuracy of performance metrics reporting.

---

*Generated by CodeWorm on 2026-02-22 17:03*
