# proc

**Type:** Code Evolution
**Repository:** docksec
**File:** internal/proc/proc.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: 5a7c48c4
Message: Initial release
Author: CarterPerez-dev
File: internal/proc/proc.go
Change type: new file

Diff:
@@ -0,0 +1,335 @@
+/*
+CarterPerez-dev | 2025
+proc.go
+*/
+
+package proc
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+)
+
+type ProcessInfo struct {
+	PID          int
+	Name         string
+	State        string
+	PPID         int
+	UID          int
+	GID          int
+	Threads      int
+	VmSize       int64
+	VmRSS        int64
+	Cmdline      []string
+	Cgroups      []CgroupEntry
+	Namespaces   map[string]uint64
+	Capabilities *CapabilitySet
+	SeccompMode  string
+	NoNewPrivs   bool
+}
+
+type CgroupEntry struct {
+	HierarchyID int
+	Controllers []string
+	Path        string
+}
+
+func GetProcessInfo(pid int) (*ProcessInfo, error) {
+	procPath := fmt.Sprintf("/proc/%d", pid)
+
+	if _, err := os.Stat(procPath); os.IsNotExist(err) {
+		return nil, fmt.Errorf("process %d does not exist", pid)
+	}
+
+	info := &ProcessInfo{
+		PID:        pid,
+		Namespaces: make(map[string]uint64),
+	}
+
+	if err := info.readStatus(procPath); err != nil {
+		return nil, fmt.Errorf("reading status: %w", err)
+	}
+
+	//nolint:staticcheck // graceful degradation - errors intentionally ignored
+	if err := info.readCmdline(procPath); err != nil {
+	}
+
+	//nolint:staticcheck // graceful degradation - errors intentionally ignored
+	if err := info.readCgroups(procPath); err != nil {
+	}
+
+	//nolint:staticcheck // graceful degradation - errors intentionally ignored
+	if err := info.readNamespaces(procPath); err != nil {
+	}
+
+	return info, nil
+}
+
+func (p *ProcessInfo) readStatus(procPath string) error {
+	file, err := os.Open(filepath.Join(procPath, "status"))
+	if err != nil {
+		return err
+	}
+	defer func() { _ = file.Close() }()
+
+	scanner := bufio.NewScanner(file)
+	for scanner.Scan() {
+		line := scanner.Text()
+		parts := strings.SplitN(line, ":", 2)
+		if len(parts) != 2 {
+			continue
+		}
+
+		key := strings.TrimSpace(parts[0])
+		value := strings.TrimSpace(parts[1])
+
+		switch key {
+		case "Name":
+			p.Name = value
+		case "State":
+			p.State = strings.Split(value, " ")[0]
+		case "PPid":
+			p.PPID, _ = strconv.Atoi(value)
+		case "Uid":
+			fields := strings.Fields(value)
+			if len(fields) > 0 {
+				p.UID, _ = strconv.Atoi(fields[0])
+			}
+		case "Gid":
+			fields := strings.Fields(value)
+			if len(fields) > 0 {
+				p.GID, _ = strconv.Atoi(fields[0])
+			}
+		case "Threads":
+			p.Threads, _ = strconv.Atoi(value)
+		case "VmSize":
+			p.VmSize = parseMemValue(value)
+		case "VmRSS":
+			p.VmRSS = parseMemValue(value)
+		case "CapInh":
+			if p.Capabilities == nil {
+				p.Capabilities = &CapabilitySet{}
+			}
+			p.Capabilities.Inheritable, _ = strconv.ParseUint(value, 16, 64)
+		case "CapPrm":
+			if p.Capabilities == nil {
+				p.Capabilities = &CapabilitySet{}
+			}
+			p.Capabilities.Permitted, _ = strconv.ParseUint(value, 16, 64)
+		case "CapEff":
+			if p.Capabilities == nil {
+				p.
```

---

## Code Evolution

### Change Analysis

**What was Changed:**
The commit introduces `proc.go`, a new file in the `internal/proc` package, defining a `ProcessInfo` struct and methods to retrieve process information from `/proc`. The code reads various attributes like PID, name, state, memory usage, capabilities, seccomp mode, namespaces, and command line arguments.

**Why it was Likely Changed:**
This change likely aims to provide a structured way to gather detailed process metadata. It supports parsing `/proc` filesystem data, which is commonly used in Linux for introspection of running processes. The `GetProcessInfo` function serves as an entry point, making the information easily accessible and reusable.

**Impact on Behavior:**
The new functionality allows the application to dynamically retrieve comprehensive details about any process by its PID. This can be useful for monitoring, debugging, or security purposes. The error handling is designed to gracefully degrade if some fields cannot be read.

**Risks or Concerns:**
- **Error Handling:** While errors are handled with `nolint` comments, this could lead to silent failures where critical information might not be retrieved.
- **Resource Usage:** Opening and reading files for each process can introduce performance overhead, especially in scenarios with many processes.
- **Security:** Accessing `/proc` requires appropriate permissions. Improper handling of PIDs or sensitive data could pose security risks.

Overall, this change enhances the application's capability to introspect processes but should be used carefully to avoid potential issues.

---

*Generated by CodeWorm on 2026-02-23 15:59*
