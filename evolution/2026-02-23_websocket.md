# websocket

**Type:** Code Evolution
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/api/websocket.py
**Language:** python
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```python
Commit: 7f35fbd8
Message: feat: complete Phase 1 — rule-based detection pipeline, API, Docker E2E

Phase 1 delivers end-to-end threat detection from nginx log ingestion
through rule-based scoring to REST API and WebSocket alerts.

- API layer: /threats, /stats, /models/status, /ws/alerts, /health, /ready
- Alert dispatcher with Redis pub/sub + PostgreSQL persistence
- Typer CLI: vigil serve, config, health
- Integration tests (tailer -> pipeline -> DB round-trip)
- Docker E2E verified: dev.compose.yml stack with all services healthy
- Linting clean: ruff, mypy strict (0 issues), pylint 10/10
- 75 tests passing across 8 test modules
Author: CarterPerez-dev
File: PROJECTS/advanced/ai-threat-detection/backend/app/api/websocket.py
Change type: new file

Diff:
@@ -0,0 +1,63 @@
+"""
+©AngelaMos | 2026
+websocket.py
+"""
+
+import asyncio
+import logging
+
+from fastapi import APIRouter, WebSocket, WebSocketDisconnect
+
+from app.core.alerts import ALERTS_CHANNEL
+from app.core.redis_manager import redis_manager
+
+logger = logging.getLogger(__name__)
+
+router = APIRouter()
+
+
+@router.websocket("/ws/alerts")
+async def ws_alerts(websocket: WebSocket) -> None:
+    """
+    Stream real time threat alerts to connected WebSocket clients
+    via Redis pub/sub relay.
+
+    Each client gets its own Redis subscriber so this works correctly
+    across multiple FastAPI workers.
+    """
+    await websocket.accept()
+
+    redis = redis_manager.client
+    if redis is None:
+        await websocket.close(code=1011, reason="Redis not available")
+        return
+
+    pubsub = redis.pubsub()
+    await pubsub.subscribe(ALERTS_CHANNEL)
+
+    async def _relay() -> None:
+        async for message in pubsub.listen():
+            if message["type"] == "message":
+                await websocket.send_text(message["data"])
+
+    async def _receive() -> None:
+        try:
+            while True:
+                await websocket.receive()
+        except WebSocketDisconnect:
+            pass
+
+    relay_task = asyncio.create_task(_relay())
+    receive_task = asyncio.create_task(_receive())
+
+    try:
+        done, pending = await asyncio.wait(
+            [relay_task, receive_task],
+            return_when=asyncio.FIRST_COMPLETED,
+        )
+        for task in pending:
+            task.cancel()
+    finally:
+        await pubsub.unsubscribe(ALERTS_CHANNEL)
+        await pubsub.aclose()  # type: ignore[attr-defined]
+        logger.debug("WebSocket client disconnected")

```

---

## Code Evolution

### Change Analysis

**What was Changed:**
A new file `websocket.py` was added to the project, implementing WebSocket support for real-time threat alerts. The code defines an API endpoint `/ws/alerts` using FastAPI, which streams threat alerts from Redis pub/sub to connected clients.

**Why it Was Likely Changed:**
This change likely addresses a requirement for real-time alerting in the threat detection pipeline. By integrating with Redis for pub/sub and PostgreSQL for persistence, the system can efficiently handle multiple WebSocket connections without blocking other services.

**Impact on Behavior:**
The addition of WebSocket support allows the backend to provide live updates to clients about detected threats. This is crucial for security analysts who need immediate notifications. The use of asynchronous tasks ensures that each client has its own Redis subscriber, making it scalable and robust across multiple FastAPI workers.

**Risks or Concerns:**
- **Resource Management:** Properly closing the Redis pub/sub connection in `finally` ensures resources are released even if an error occurs.
- **Error Handling:** The code handles `WebSocketDisconnect` gracefully but could benefit from more detailed logging or reconnection logic for transient issues.
- **Performance:** While asynchronous handling is efficient, excessive WebSocket connections might impact server performance. Monitoring and optimization will be necessary.

Overall, this change significantly enhances the system's real-time capabilities while maintaining a clean and robust design.

---

*Generated by CodeWorm on 2026-02-23 07:07*
