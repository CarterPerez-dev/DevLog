# useWebSocket

**Type:** Code Evolution
**Repository:** CodeWorm
**File:** dashboard/frontend/src/api/hooks/useWebSocket.ts
**Language:** typescript
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```typescript
Commit: ca3ce30d
Message: v1.0.2: add doc type system, Docker infrastructure, and web dashboard

- Add 11 documentation types (function, class, file, security review, TIL, etc.)
  with weighted random selection so the same codebase generates 10x more unique content
- Add Docker Compose for Ollama (GPU passthrough) + Redis + Dashboard + Nginx
- Add FastAPI backend with REST API, WebSocket live events, and Redis pub/sub
- Add React dashboard with stats, live log, commit feed, repo list, and worm viz
- Add next_scheduled_run logging after each cycle completes
- Update repos config and README for v1.0.2
Author: CarterPerez-dev
File: dashboard/frontend/src/api/hooks/useWebSocket.ts
Change type: new file

Diff:
@@ -0,0 +1,197 @@
+// Â©AngelaMos | 2026
+// useWebSocket.ts
+
+import { useCallback, useEffect, useRef } from 'react'
+import { useQueryClient } from '@tanstack/react-query'
+import {
+  isValidDaemonEvent,
+  isValidWsMessage,
+  type LogEntry,
+} from '@/api/types'
+import { QUERY_KEYS, WS_CONFIG } from '@/config'
+import { useDashboardStore } from '@/core/lib'
+
+const FINGERPRINT_CLEAR_MS = 30_000
+const FINGERPRINT_MAX = 200
+
+function logFingerprint(entry: Record<string, unknown>): string {
+  return `${entry.event ?? ''}:${entry.timestamp ?? ''}:${entry.component ?? ''}`
+}
+
+function parseLogEntry(logData: Record<string, unknown>): LogEntry {
+  return {
+    id: crypto.randomUUID(),
+    timestamp: (logData.timestamp as string) ?? new Date().toISOString(),
+    level: (logData.log_level as string) ?? 'info',
+    component: logData.component as string | undefined,
+    event: logData.event as string | undefined,
+    ...logData,
+  }
+}
+
+export function useWebSocket(): void {
+  const wsRef = useRef<WebSocket | null>(null)
+  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout>>(undefined)
+  const recentFingerprints = useRef<Set<string>>(new Set())
+  const cleanupTimerRef = useRef<ReturnType<typeof setInterval>>(undefined)
+  const {
+    setConnected,
+    addLog,
+    addLogs,
+    setActivity,
+    setNextCycleTime,
+    setLastEvent,
+  } = useDashboardStore()
+  const queryClient = useQueryClient()
+
+  const isDuplicate = useCallback((fp: string): boolean => {
+    if (recentFingerprints.current.has(fp)) return true
+    recentFingerprints.current.add(fp)
+    if (recentFingerprints.current.size > FINGERPRINT_MAX) {
+      const entries = [...recentFingerprints.current]
+      recentFingerprints.current = new Set(entries.slice(-FINGERPRINT_MAX / 2))
+    }
+    return false
+  }, [])
+
+  const connect = useCallback(() => {
+    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
+    const wsUrl = `${protocol}//${window.location.host}/api/ws`
+
+    const ws = new WebSocket(wsUrl)
+    wsRef.current = ws
+
+    ws.onopen = () => {
+      setConnected(true)
+    }
+
+    ws.onclose = () => {
+      setConnected(false)
+      wsRef.current = null
+
+      reconnectTimerRef.current = setTimeout(()
```

---

## Code Evolution

### Change Analysis

**What was Changed:**
A new file `useWebSocket.ts` was added to the repository, which introduces WebSocket functionality for real-time communication between the dashboard and backend services. This includes handling log entries, event messages, and managing reconnection logic.

**Why it was Likely Changed:**
The addition of WebSocket support is crucial for enabling live updates in the React dashboard, such as displaying logs and events in near-real time. This feature enhances user experience by providing immediate feedback on system activities.

**Impact on Behavior:**
This change significantly improves the responsiveness of the dashboard, allowing users to see live log entries and event notifications without needing to refresh the page. The use of WebSocket ensures that updates are delivered instantly, improving overall usability.

**Risks or Concerns:**
There is a risk of increased latency if the WebSocket connection fails frequently due to network issues. Additionally, managing reconnection logic could introduce complexity in handling edge cases like persistent disconnections or slow reconnect times. Ensuring robust error handling and fallback mechanisms will be important to maintain system reliability.

---

*Generated by CodeWorm on 2026-02-23 21:09*
