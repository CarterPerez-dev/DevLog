# parser

**Type:** Code Evolution
**Repository:** angela
**File:** internal/requirements/parser.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: ea4cc501
Message: Create canonical module source location - release v1.0.0
Author: CarterPerez-dev
File: internal/requirements/parser.go
Change type: new file

Diff:
@@ -0,0 +1,91 @@
+// Â©AngelaMos | 2026
+// parser.go
+
+package requirements
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"strings"
+
+	"github.com/CarterPerez-dev/angela/pkg/types"
+)
+
+// ParseFile reads a requirements.txt and extracts all dependency declarations
+func ParseFile(path string) ([]types.Dependency, error) {
+	f, err := os.Open(path) //nolint:gosec
+	if err != nil {
+		if os.IsNotExist(err) {
+			return nil, fmt.Errorf(
+				"open %s: file not found", path,
+			)
+		}
+		return nil, fmt.Errorf("read %s: %w", path, err)
+	}
+	defer func() { _ = f.Close() }() //nolint:errcheck
+
+	var deps []types.Dependency
+	scanner := bufio.NewScanner(f)
+
+	for scanner.Scan() {
+		line := strings.TrimSpace(scanner.Text())
+
+		if line == "" ||
+			strings.HasPrefix(line, "#") ||
+			strings.HasPrefix(line, "-") {
+			continue
+		}
+
+		if idx := strings.Index(line, " #"); idx >= 0 {
+			line = strings.TrimSpace(line[:idx])
+		}
+
+		dep := parseLine(line)
+		if dep.Name != "" {
+			deps = append(deps, dep)
+		}
+	}
+
+	if err := scanner.Err(); err != nil {
+		return nil, fmt.Errorf("read %s: %w", path, err)
+	}
+
+	if len(deps) == 0 {
+		return nil, fmt.Errorf(
+			"%s: no dependencies found", path,
+		)
+	}
+	return deps, nil
+}
+
+func parseLine(s string) types.Dependency {
+	var dep types.Dependency
+
+	if idx := strings.Index(s, ";"); idx >= 0 {
+		dep.Markers = strings.TrimSpace(s[idx+1:])
+		s = strings.TrimSpace(s[:idx])
+	}
+
+	if start := strings.Index(s, "["); start >= 0 {
+		end := strings.Index(s, "]")
+		if end > start {
+			for _, e := range strings.Split(s[start+1:end], ",") {
+				dep.Extras = append(
+					dep.Extras,
+					strings.TrimSpace(e),
+				)
+			}
+			s = s[:start] + s[end+1:]
+		}
+	}
+
+	if idx := strings.IndexAny(s, "><=!~"); idx >= 0 {
+		dep.Name = strings.TrimSpace(s[:idx])
+		dep.Spec = strings.TrimSpace(s[idx:])
+	} else {
+		dep.Name = strings.TrimSpace(s)
+	}
+
+	return dep
+}

```

---

## Code Evolution

### Change Analysis for `internal/requirements/parser.go`

**What was Changed:**
A new file, `parser.go`, was added to the `internal/requirements` package. This file introduces two functions: `ParseFile` and `parseLine`. The `ParseFile` function reads a `requirements.txt` file, extracts dependency declarations, and returns them as a slice of `types.Dependency` structs. The `parseLine` function processes each line from the file to create individual dependency objects.

**Why it was Likely Changed:**
This change likely aims to provide a structured way to parse and manage dependencies for projects using `requirements.txt`. It follows common practices in Go by handling errors gracefully, using buffered I/O for reading files, and leveraging string manipulation functions. The addition of comments and copyright headers suggests this is part of a larger release or refactoring effort.

**Impact on Behavior:**
The new functionality allows the application to read and parse `requirements.txt` files, making it easier to manage dependencies programmatically. This could be particularly useful for automation scripts, dependency management tools, or CI/CD pipelines that need to process these files.

**Risks or Concerns:**
- The use of `nolint:gosec` in `os.Open(path)` might indicate a potential security risk if the path is not sanitized.
- Error handling could be improved by returning specific error types instead of generic `error`.
- The function does not validate the format of dependencies, which could lead to unexpected behavior or errors during parsing.

---

*Generated by CodeWorm on 2026-02-23 14:31*
