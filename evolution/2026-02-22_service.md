# service

**Type:** Code Evolution
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/auth/service.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: bf95949c
Message: go backend to react-go stack
Author: CarterPerez-dev
File: stacks/go-react/go-backend/internal/auth/service.go
Change type: new file

Diff:
@@ -0,0 +1,411 @@
+// AngelaMos | 2026
+// service.go
+
+package auth
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"time"
+
+	"github.com/google/uuid"
+	"github.com/redis/go-redis/v9"
+
+	"github.com/carterperez-dev/templates/go-backend/internal/core"
+)
+
+var (
+	ErrInvalidCredentials = errors.New("invalid credentials")
+	ErrTokenReuse         = errors.New("token reuse detected")
+	ErrEmailExists        = errors.New("email already exists")
+)
+
+type UserInfo struct {
+	ID           string
+	Email        string
+	Name         string
+	PasswordHash string
+	Role         string
+	Tier         string
+	TokenVersion int
+}
+
+type UserProvider interface {
+	GetByEmail(ctx context.Context, email string) (*UserInfo, error)
+	GetByID(ctx context.Context, id string) (*UserInfo, error)
+	Create(
+		ctx context.Context,
+		email, passwordHash, name string,
+	) (*UserInfo, error)
+	IncrementTokenVersion(ctx context.Context, userID string) error
+	UpdatePassword(ctx context.Context, userID, passwordHash string) error
+}
+
+type Service struct {
+	repo         Repository
+	jwt          *JWTManager
+	userProvider UserProvider
+	redis        *redis.Client
+	blacklistTTL time.Duration
+}
+
+func NewService(
+	repo Repository,
+	jwt *JWTManager,
+	userProvider UserProvider,
+	redisClient *redis.Client,
+) *Service {
+	return &Service{
+		repo:         repo,
+		jwt:          jwt,
+		userProvider: userProvider,
+		redis:        redisClient,
+		blacklistTTL: 15 * time.Minute,
+	}
+}
+
+func (s *Service) Login(
+	ctx context.Context,
+	req LoginRequest,
+	userAgent, ipAddress string,
+) (*AuthResponse, error) {
+	user, err := s.userProvider.GetByEmail(ctx, req.Email)
+	if err != nil {
+		if errors.Is(err, core.ErrNotFound) {
+			//nolint:errcheck // timing attack prevention - always verify to prevent enumeration
+			_, _, _ = core.VerifyPasswordTimingSafe(req.Password, nil)
+			return nil, ErrInvalidCredentials
+		}
+		return nil, fmt.Errorf("get user: %w", err)
+	}
+
+	valid, newHash, err := core.VerifyPasswordTimingSafe(
+		req.Password,
+		&user.PasswordHash,
+	)
+	if err != nil {
+		return nil, fmt.Errorf("verify password: %w", err)
+	}
+
+	if !valid {
+		return nil, ErrInvalidCredentials
+	}
+
+	if newHash != "" {
+		//nolint:errcheck // best-effort rehash upgrade
+		_ = s.userProvider.UpdatePassword(ctx, user.ID, newHash)
+	}
+
+	return s.createAuthResponse(ctx, user, userAgent, ipAddress, "", nil)
+}
+
+func (s *Service) Register(
+	ctx context.Context,
+	req RegisterRequest,
+	userAgent, ipAddress string,
+) (*AuthResponse, error) {
+	passwordHash, err := core.HashPassword(req.Password)
+	if err != nil {
+		return nil, fmt.Errorf("hash password: %w", err)
+	}
+
+	user, err := s.userProvider.Create(ctx, req.Email, passwordHash, req.Name)
+	if err != nil {
+		if errors.Is(err, core.ErrDuplicateKe
```

---

## Code Evolution

### Change Analysis

**What was Changed:**
The code introduces a new `service.go` file in the Go backend for the React-Go stack, implementing authentication services including login, registration, token refresh, and logout functionalities. The service uses interfaces like `UserProvider`, integrates with Redis for token management, and leverages JWT for generating tokens.

**Why it was Likely Changed:**
This change likely aims to centralize authentication logic in a reusable Service struct, improving modularity and separation of concerns. It also introduces security measures such as timing-safe password verification and token revocation mechanisms.

**Impact on Behavior:**
The new service provides robust user authentication and management capabilities, ensuring secure handling of credentials and tokens. The implementation supports various scenarios like login, registration, refreshing access tokens, and logging out users or all their sessions.

**Risks or Concerns:**
- **Error Handling:** Best-effort error handling (e.g., `nolint:errcheck`) could lead to potential issues if not properly managed.
- **Timing Attacks:** The use of timing-safe password verification is a good practice, but it should be consistently applied throughout the codebase.
- **Token Management:** Ensuring tokens are correctly revoked and stored in Redis can be complex; any failure here could expose security vulnerabilities.

Overall, this change significantly enhances the authentication layer's functionality and security.

---

*Generated by CodeWorm on 2026-02-22 13:54*
