# security

**Type:** Code Evolution
**Repository:** social-media-notes
**File:** backend/app/core/security.py
**Language:** python
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```python
Commit: 8c757802
Message: easy peasy
Author: CarterPerez-dev
File: backend/app/core/security.py
Change type: new file

Diff:
@@ -0,0 +1,194 @@
+"""
+â’¸AngelaMos | 2025
+security.py
+"""
+
+import asyncio
+import hashlib
+import secrets
+from datetime import (
+    UTC,
+    datetime,
+    timedelta,
+)
+from typing import Any
+from uuid import UUID
+
+import jwt
+from fastapi import Response
+from pwdlib import PasswordHash
+
+from config import (
+    API_PREFIX,
+    settings,
+    TokenType,
+)
+
+
+password_hasher = PasswordHash.recommended()
+
+
+async def hash_password(password: str) -> str:
+    """
+    Hash password using Argon2id
+
+    Runs in thread pool to avoid blocking the async event loop
+    since Argon2 is CPU intensive by design
+    """
+    return await asyncio.to_thread(password_hasher.hash, password)
+
+
+async def verify_password(plain_password: str,
+                          hashed_password: str) -> tuple[bool,
+                                                         str | None]:
+    """
+    Verify password and check if rehash is needed
+
+    Returns:
+        Tuple of (is_valid, new_hash_if_needs_rehash)
+        If password is valid but hash params are outdated, returns new hash
+    """
+    try:
+        return await asyncio.to_thread(
+            password_hasher.verify_and_update,
+            plain_password,
+            hashed_password
+        )
+    except Exception:
+        return False, None
+
+
+DUMMY_HASH = password_hasher.hash(
+    "dummy_password_for_timing_attack_prevention"
+)
+
+
+async def verify_password_with_timing_safety(
+    plain_password: str,
+    hashed_password: str | None,
+) -> tuple[bool,
+           str | None]:
+    """
+    Verify password with constant time behavior to prevent user enumeration
+
+    If no hash is provided (user doesn't exist), still performs a dummy
+    hash operation to prevent timing attacks
+    """
+    if hashed_password is None:
+        await asyncio.to_thread(
+            password_hasher.verify,
+            plain_password,
+            DUMMY_HASH
+        )
+        return False, None
+    return await verify_password(plain_password, hashed_password)
+
+
+def create_access_token(
+    user_id: UUID,
+    token_version: int,
+    extra_claims: dict[str,
+                       Any] | None = None,
+) -> str:
+    """
+    Create a short lived access token
+    """
+    now = datetime.now(UTC)
+    payload = {
+        "sub": str(user_id),
+        "type": TokenType.ACCESS.value,
+        "token_version": token_version,
+        "iat": now,
+        "exp":
+        now + timedelta(minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES),
+    }
+    if extra_claims:
+        payload.update(extra_claims)
+
+    return jwt.encode(
+        payload,
+        settings.SECRET_KEY.get_secret_value(),
+        algorithm = settings.JWT_ALGORITHM,
+    )
+
+
+def create_refresh_token(
+    user_id: UUID,
+    family_id: UUID,
+) -> tuple[str,
+           str,
+          
```

---

## Code Evolution

### Change Analysis for `security.py`

**What was Changed:**
The commit introduces a new file, `security.py`, which contains various security-related functions and utilities for hashing passwords, creating JWT tokens, and managing refresh tokens. The code includes functions like `hash_password`, `verify_password`, `create_access_token`, `create_refresh_token`, and more.

**Why it was Likely Changed:**
This change likely aims to centralize security logic in a single file to improve maintainability and ensure consistent security practices across the application. The introduction of asynchronous operations for password hashing and token creation ensures that these CPU-intensive tasks do not block the main event loop, enhancing performance.

**Impact on Behavior:**
The new functions provide robust mechanisms for secure user authentication and authorization. For instance:
- `hash_password` and `verify_password` ensure strong password handling.
- `create_access_token` and `create_refresh_token` generate JWTs with appropriate expiration times.
- The timing-safe verification in `verify_password_with_timing_safety` mitigates potential timing attacks.

**Risks or Concerns:**
While the code is well-structured, there are a few risks:
1. **Timing Attacks:** Although `verify_password_with_timing_safety` uses constant-time operations, it's crucial to ensure that all password verification functions behave similarly.
2. **JWT Security:** The use of `jwt.encode` and `jwt.decode` should be carefully managed to avoid common pitfalls like token replay attacks.
3. **Environment-Specific Settings:** Ensure that environment-specific settings (e.g., `settings.SECRET_KEY`) are securely managed, especially in production.

Overall, the changes significantly enhance security practices while maintaining a clean and modular codebase.

---

*Generated by CodeWorm on 2026-02-23 18:11*
