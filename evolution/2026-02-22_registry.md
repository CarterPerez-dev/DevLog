# registry

**Type:** Code Evolution
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/rules/registry.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: 294169a2
Message: feat: Complete Go secrets scanner - Portia
Author: CarterPerez-dev
File: PROJECTS/intermediate/secrets-scanner/internal/rules/registry.go
Change type: new file

Diff:
@@ -0,0 +1,167 @@
+// Â©AngelaMos | 2026
+// registry.go
+
+package rules
+
+import (
+	"fmt"
+	"regexp"
+	"sort"
+	"strings"
+
+	"github.com/CarterPerez-dev/portia/pkg/types"
+)
+
+type Registry struct {
+	rules    map[string]*types.Rule
+	disabled map[string]bool
+}
+
+func NewRegistry() *Registry {
+	return &Registry{
+		rules:    make(map[string]*types.Rule),
+		disabled: make(map[string]bool),
+	}
+}
+
+func (r *Registry) Register(rule *types.Rule) {
+	if _, exists := r.rules[rule.ID]; exists {
+		panic(fmt.Sprintf(
+			"duplicate rule ID: %s", rule.ID,
+		))
+	}
+	r.rules[rule.ID] = rule
+}
+
+func (r *Registry) Get(
+	id string,
+) (*types.Rule, bool) {
+	rule, ok := r.rules[id]
+	if !ok || r.disabled[id] {
+		return nil, false
+	}
+	return rule, true
+}
+
+func (r *Registry) All() []*types.Rule {
+	result := make([]*types.Rule, 0, len(r.rules))
+	for _, rule := range r.rules {
+		if !r.disabled[rule.ID] {
+			result = append(result, rule)
+		}
+	}
+	sort.Slice(result, func(i, j int) bool {
+		return result[i].ID < result[j].ID
+	})
+	return result
+}
+
+func (r *Registry) Disable(ids ...string) {
+	for _, id := range ids {
+		r.disabled[id] = true
+	}
+}
+
+func (r *Registry) MatchKeywords(
+	content string,
+) []*types.Rule {
+	lower := strings.ToLower(content)
+	var matched []*types.Rule
+
+	for _, rule := range r.rules {
+		if r.disabled[rule.ID] {
+			continue
+		}
+		for _, kw := range rule.Keywords {
+			if strings.Contains(lower, strings.ToLower(kw)) {
+				matched = append(matched, rule)
+				break
+			}
+		}
+	}
+	return matched
+}
+
+func (r *Registry) Len() int {
+	count := 0
+	for id := range r.rules {
+		if !r.disabled[id] {
+			count++
+		}
+	}
+	return count
+}
+
+func (r *Registry) Replace(rule *types.Rule) {
+	r.rules[rule.ID] = rule
+}
+
+var GlobalPathAllowlist = []*regexp.Regexp{
+	regexp.MustCompile(
+		`go\.(?:mod|sum|work(?:\.sum)?)$`,
+	),
+	regexp.MustCompile(
+		`(?:^|/)(?:package-lock\.json|pnpm-lock\.yaml|` +
+			`yarn\.lock|npm-shrinkwrap\.json|deno\.lock|` +
+			`Cargo\.lock|composer\.lock|Gemfile\.lock|` +
+			`poetry\.lock|Pipfile\.lock|mix\.lock|` +
+			`pubspec\.lock|Podfile\.lock|flake\.lock|` +
+			`bun\.lockb)$`,
+	),
+	regexp.MustCompile(`(?:^|/)node_modules/`),
+	regexp.MustCompile(`(?:^|/)vendor/`),
+	regexp.MustCompile(`(?:^|/)\.git/`),
+	regexp.MustCompile(`(?:^|/)\.svn/`),
+	regexp.MustCompile(`(?:^|/)\.hg/`),
+	regexp.MustCompile(
+		`(?:^|/)(?:__pycache__|\.venv|venv|\.tox|` +
+			`\.mypy_cache|\.pytest_cache|\.ruff_cache|` +
+			`\.eggs|.*\.egg-info)/`,
+	),
+	regexp.MustCompile(
+		`(?:^|/)(?:\.next|\.nuxt|\.svelte-kit|` +
+			`\.terraform|\.gradle|\.mvn|\.bundle|` +
+			`Pods|coverage|\.nyc_output)/`,
+	),
+	regexp.MustCompile(
+		`(?:^|/)(?:target|build|dist|out)/`,
+	),
+	regexp.MustCompile(
+		`\.min
```

---

## Code Evolution

### Change Analysis for `registry.go`

**What was Changed:**
The commit introduces a new file, `registry.go`, which implements a rules registry for the Go secrets scanner. This includes methods to register, retrieve, and manage rules, as well as utilities like keyword matching and allowlisting.

**Why it was Likely Changed:**
This change likely aims to centralize rule management in the secrets scanner, providing a structured way to handle different security rules. The introduction of `GlobalPathAllowlist` and `GlobalValueAllowlist` helps filter out false positives by ignoring certain file paths or values that are known to be non-sensitive.

**Impact on Behavior:**
The new registry allows for dynamic rule registration and retrieval, enabling the scanner to adapt based on predefined rules. Keyword matching ensures that specific patterns in code or configuration files can trigger security alerts. The allowlists help reduce noise by excluding common, non-sensitive paths and values from scanning.

**Risks or Concerns:**
- **False Negatives:** Overly restrictive allowlists might miss actual sensitive data.
- **Maintenance:** Regular updates to the allowlists are necessary to keep up with evolving best practices.
- **Performance:** Keyword matching could impact performance if not optimized, especially for large codebases.

---

*Generated by CodeWorm on 2026-02-22 21:40*
