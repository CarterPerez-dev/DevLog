# parser_test

**Type:** Code Evolution
**Repository:** angela
**File:** internal/requirements/parser_test.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: ea4cc501
Message: Create canonical module source location - release v1.0.0
Author: CarterPerez-dev
File: internal/requirements/parser_test.go
Change type: new file

Diff:
@@ -0,0 +1,122 @@
+// Â©AngelaMos | 2026
+// parser_test.go
+
+package requirements
+
+import (
+	"os"
+	"path/filepath"
+	"testing"
+)
+
+func TestParseFile(t *testing.T) {
+	t.Parallel()
+
+	content := `# Core deps
+django>=3.2.0
+requests==2.28.1
+flask>=2.0,<3.0
+numpy  # pinned
+click[extra]>=8.0.0; python_version>="3.8"
+
+# Options to skip
+-r other.txt
+-e ./local-pkg
+--index-url https://pypi.org/simple/
+`
+
+	path := filepath.Join(t.TempDir(), "requirements.txt")
+	os.WriteFile(path, []byte(content), 0o600) //nolint:errcheck
+
+	deps, err := ParseFile(path)
+	if err != nil {
+		t.Fatalf("ParseFile: %v", err)
+	}
+
+	if len(deps) != 5 {
+		t.Fatalf("len = %d, want 5", len(deps))
+	}
+
+	tests := []struct {
+		name string
+		spec string
+	}{
+		{"django", ">=3.2.0"},
+		{"requests", "==2.28.1"},
+		{"flask", ">=2.0,<3.0"},
+		{"numpy", ""},
+		{"click", ">=8.0.0"},
+	}
+
+	for i, tt := range tests {
+		if deps[i].Name != tt.name {
+			t.Errorf("deps[%d].Name = %q, want %q", i, deps[i].Name, tt.name)
+		}
+		if deps[i].Spec != tt.spec {
+			t.Errorf("deps[%d].Spec = %q, want %q", i, deps[i].Spec, tt.spec)
+		}
+	}
+}
+
+func TestParseFileExtras(t *testing.T) {
+	t.Parallel()
+
+	content := "requests[security,socks]>=2.28.0\n"
+	path := filepath.Join(t.TempDir(), "requirements.txt")
+	os.WriteFile(path, []byte(content), 0o600) //nolint:errcheck
+
+	deps, err := ParseFile(path)
+	if err != nil {
+		t.Fatalf("ParseFile: %v", err)
+	}
+
+	if len(deps) != 1 {
+		t.Fatalf("len = %d, want 1", len(deps))
+	}
+
+	if len(deps[0].Extras) != 2 {
+		t.Fatalf("extras len = %d, want 2", len(deps[0].Extras))
+	}
+	if deps[0].Extras[0] != "security" || deps[0].Extras[1] != "socks" {
+		t.Errorf("extras = %v, want [security socks]", deps[0].Extras)
+	}
+}
+
+func TestParseFileMarkers(t *testing.T) {
+	t.Parallel()
+
+	content := "pywin32>=300; sys_platform==\"win32\"\n"
+	path := filepath.Join(t.TempDir(), "requirements.txt")
+	os.WriteFile(path, []byte(content), 0o600) //nolint:errcheck
+
+	deps, err := ParseFile(path)
+	if err != nil {
+		t.Fatalf("ParseFile: %v", err)
+	}
+
+	if deps[0].Markers != `sys_platform=="win32"` {
+		t.Errorf("markers = %q, want sys_platform==\"win32\"", deps[0].Markers)
+	}
+}
+
+func TestParseFileEmpty(t *testing.T) {
+	t.Parallel()
+
+	content := "# just comments\n\n-r other.txt\n"
+	path := filepath.Join(t.TempDir(), "requirements.txt")
+	os.WriteFile(path, []byte(content), 0o600) //nolint:errcheck
+
+	_, err := ParseFile(path)
+	if err == nil {
+		t.Error("expected error for empty requirements")
+	}
+}
+
+func TestParseFileNotFound(t *testing.T) {
+	t.Parallel()
+
+	_, err := ParseFile("/nonexistent/requirements.txt")
+	if err == nil {
+		t.Error("expected error for missing file")
+	}
+}

```

---

## Code Evolution

### Change Analysis

**What was Changed:** 
The commit introduces four new test functions in `parser_test.go` to validate the `ParseFile` function of the `requirements` package. These tests cover various scenarios including parsing standard dependencies, extras, markers, and handling empty or non-existent files.

**Why it Was Likely Changed:**
This change likely aims to ensure that the parser correctly handles different types of requirements file contents, thereby improving the robustness and reliability of the `ParseFile` function. The introduction of these tests helps in maintaining a high standard of code quality by covering edge cases and typical use cases.

**Impact on Behavior:**
The new test functions will now be run during testing to validate that the parser behaves as expected under various conditions, such as parsing dependencies with markers or extras, handling comments and directives like `-r` and `--index-url`, and correctly reporting errors for non-existent files. This ensures that the requirements parser is thoroughly tested.

**Risks or Concerns:**
While these tests are beneficial, there's a risk that they might not cover all possible edge cases in real-world scenarios. Additionally, ensuring that the test content accurately reflects actual use cases will be crucial to maintaining their effectiveness.

---

*Generated by CodeWorm on 2026-02-23 14:33*
