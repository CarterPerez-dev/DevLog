# main

**Type:** Code Evolution
**Repository:** timer-go
**File:** main.go
**Language:** go
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```go
Commit: 6bf004c8
Message: my timer
Author: CarterPerez-dev
File: main.go
Change type: new file

Diff:
@@ -0,0 +1,238 @@
+/*
+â’¸AngelaMos | 2025
+main.go
+*/
+
+package main
+
+import (
+	"embed"
+	"encoding/json"
+	"log/slog"
+	"net/http"
+	"os"
+	"sync"
+	"time"
+)
+
+//go:embed static/index.html
+var staticFiles embed.FS
+
+type TimerState struct {
+	StartTime     int64 `json:"start_time"`
+	StoppedAt     int64 `json:"stopped_at"`
+	OffsetSeconds int64 `json:"offset_seconds"`
+	IsRunning     bool  `json:"is_running"`
+}
+
+type TimerResponse struct {
+	IsRunning        bool   `json:"is_running"`
+	ElapsedSeconds   int64  `json:"elapsed_seconds"`
+	ElapsedFormatted string `json:"elapsed_formatted"`
+}
+
+type StartRequest struct {
+	OffsetHours float64 `json:"offset_hours"`
+}
+
+var (
+	state     TimerState
+	stateMu   sync.RWMutex
+	stateFile = "timer.json"
+)
+
+func loadState() error {
+	stateMu.Lock()
+	defer stateMu.Unlock()
+
+	data, err := os.ReadFile(stateFile)
+	if os.IsNotExist(err) {
+		state = TimerState{}
+		return nil
+	}
+	if err != nil {
+		return err
+	}
+	return json.Unmarshal(data, &state)
+}
+
+func saveState() error {
+	data, err := json.MarshalIndent(state, "", "  ")
+	if err != nil {
+		return err
+	}
+	return os.WriteFile(stateFile, data, 0644)
+}
+
+func getElapsed() int64 {
+	if !state.IsRunning && state.StartTime == 0 {
+		return state.OffsetSeconds
+	}
+
+	var elapsed int64
+	if state.IsRunning {
+		elapsed = time.Now().Unix() - state.StartTime
+	} else {
+		elapsed = state.StoppedAt - state.StartTime
+	}
+	return elapsed + state.OffsetSeconds
+}
+
+func formatElapsed(seconds int64) string {
+	hours := seconds / 3600
+	minutes := (seconds % 3600) / 60
+	secs := seconds % 60
+
+	result := ""
+	if hours > 0 {
+		result = string(rune('0'+hours/100)) + string(rune('0'+hours/10%10)) + string(rune('0'+hours%10))
+		for len(result) > 1 && result[0] == '0' {
+			result = result[1:]
+		}
+		result += ":"
+	}
+
+	if hours > 0 {
+		result += string(rune('0'+minutes/10)) + string(rune('0'+minutes%10))
+	} else {
+		result += string(rune('0'+minutes/10)) + string(rune('0'+minutes%10))
+	}
+	result += ":"
+	result += string(rune('0'+secs/10)) + string(rune('0'+secs%10))
+
+	return result
+}
+
+func handleGetTimer(w http.ResponseWriter, r *http.Request) {
+	stateMu.RLock()
+	elapsed := getElapsed()
+	running := state.IsRunning
+	stateMu.RUnlock()
+
+	resp := TimerResponse{
+		IsRunning:        running,
+		ElapsedSeconds:   elapsed,
+		ElapsedFormatted: formatElapsed(elapsed),
+	}
+
+	w.Header().Set("Content-Type", "application/json")
+	_ = json.NewEncoder(w).Encode(resp)
+}
+
+func handleStart(w http.ResponseWriter, r *http.Request) {
+	var req StartRequest
+	if r.ContentLength > 0 {
+		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
+			http.Error(w, "invalid json", http.StatusBadRequest)
+			return
+		}
+	}
+
+	stateMu.Lock()
+	defer stateMu.Unlock()
+
+	if state.IsRunning {
+		w.Header().Set("Content-Type", "applicat
```

---

## Code Evolution

### Change Analysis for Commit 6bf004c8

**What was Changed:**
The commit introduces a new `main.go` file that implements a timer API using Go's standard library and embedded assets. The code defines structs for state management, request handling, and response formatting. It includes functions to load/save the timer state from a JSON file, handle HTTP requests (GET, POST), and format time durations.

**Why it was Likely Changed:**
This change likely aims to create a RESTful API for managing a running timer application. The implementation supports starting, stopping, resetting, and retrieving the current state of the timer. By embedding static files and using JSON for data exchange, the developer ensures a clean separation between frontend and backend logic.

**Impact on Behavior:**
The new functionality allows users to interact with the timer via HTTP requests. Users can start or stop the timer, reset it to zero, and retrieve the current state (running status and elapsed time). This provides flexibility in managing the timer from various clients.

**Risks or Concerns:**
- **Error Handling:** The code could benefit from more robust error handling, especially for file operations.
- **Security:** Ensure that the API is secure, particularly if it will be exposed publicly. Consider implementing rate limiting and authentication mechanisms.
- **Concurrency:** While the `sync.RWMutex` is used to protect state access, ensure no race conditions exist in concurrent environments.

Overall, this change significantly enhances the functionality of the timer application by providing a flexible and accessible API interface.

---

*Generated by CodeWorm on 2026-02-23 15:12*
