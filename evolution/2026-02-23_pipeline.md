# pipeline

**Type:** Code Evolution
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/core/ingestion/pipeline.py
**Language:** python
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```python
Commit: 7f35fbd8
Message: feat: complete Phase 1 â€” rule-based detection pipeline, API, Docker E2E

Phase 1 delivers end-to-end threat detection from nginx log ingestion
through rule-based scoring to REST API and WebSocket alerts.

- API layer: /threats, /stats, /models/status, /ws/alerts, /health, /ready
- Alert dispatcher with Redis pub/sub + PostgreSQL persistence
- Typer CLI: vigil serve, config, health
- Integration tests (tailer -> pipeline -> DB round-trip)
- Docker E2E verified: dev.compose.yml stack with all services healthy
- Linting clean: ruff, mypy strict (0 issues), pylint 10/10
- 75 tests passing across 8 test modules
Author: CarterPerez-dev
File: PROJECTS/advanced/ai-threat-detection/backend/app/core/ingestion/pipeline.py
Change type: modified

Diff:
@@ -26,6 +26,7 @@ class EnrichedRequest:
     """
     A parsed log entry enriched with extracted features and GeoIP data.
     """
+
     entry: ParsedLogEntry
     features: dict[str, int | float | bool | str]
     feature_vector: list[float]
@@ -37,6 +38,7 @@ class ScoredRequest:
     """
     A fully scored request ready for dispatch.
     """
+
     entry: ParsedLogEntry
     features: dict[str, int | float | bool | str]
     feature_vector: list[float]
@@ -56,7 +58,7 @@ class Pipeline:
 
     def __init__(
         self,
-        redis_client: aioredis.Redis,
+        redis_client: aioredis.Redis[bytes],
         rule_engine: RuleEngine,
         geoip: GeoIPService | None = None,
         on_result: Callable[[ScoredRequest], Awaitable[None]] | None = None,
@@ -82,7 +84,7 @@ class Pipeline:
         self._rule_engine = rule_engine
         self._geoip = geoip
         self._on_result = on_result
-        self._tasks: list[asyncio.Task] = []
+        self._tasks: list[asyncio.Task[None]] = []
 
     async def start(self) -> None:
         """
@@ -147,7 +149,7 @@ class Pipeline:
                     ip=entry.ip,
                     request_id=uuid.uuid4().hex,
                     path=entry.path,
-                    path_depth=per_request["path_depth"],
+                    path_depth=int(per_request["path_depth"]),
                     method=entry.method,
                     status_code=entry.status_code,
                     user_agent=entry.user_agent,
@@ -182,7 +184,8 @@ class Pipeline:
                 break
             try:
                 rule_result = self._rule_engine.score_request(
-                    enriched.features, enriched.entry,
+                    enriched.features,
+                    enriched.entry,
                 )
                 await self._alert_queue.put(
                     ScoredRequest(

```

---

## Code Evolution

### Change Analysis for Commit 7f35fbd8

**What was Changed:**
In `pipeline.py`, the type hint for `redis_client` was updated to `aioredis.Redis[bytes]`. Additionally, the type of `_tasks` in the `Pipeline` class was changed from `list[asyncio.Task]` to `list[asyncio.Task[None]]`. The method `score_request` call in `__init__` was modified to remove an unnecessary argument.

**Why it was Likely Changed:**
1. **Type Hint Update:** The change likely ensures that the Redis client is correctly typed as returning bytes, which aligns with typical usage and improves type safety.
2. **Task Type Hint:** Changing `_tasks` to `asyncio.Task[None]` clarifies that each task is expected to return `None`, making the code more explicit and easier to understand.

**Impact on Behavior:**
- The behavior of the pipeline remains unchanged, but the type hints now accurately reflect the types used.
- The removal of an unnecessary argument in `score_request` ensures cleaner code without altering functionality.

**Risks or Concerns:**
- Ensuring that all tasks are indeed expected to return `None` is crucial. If any task returns a value, this change could lead to runtime errors.
- Verifying that the Redis client correctly handles byte data is important for compatibility with other parts of the system.

Overall, these changes improve code clarity and type safety without impacting functionality.

---

*Generated by CodeWorm on 2026-02-23 08:14*
