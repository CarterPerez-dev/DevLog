# scaler

**Type:** Code Evolution
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/ml/scaler.py
**Language:** python
**Lines:** 1-1
**Complexity:** 0.0

---

## Source Code

```python
Commit: 9397b12a
Message: add learn folder, move hidden files, update root readme, add learn folder, add clang tidy, and format
Author: CarterPerez-dev
File: PROJECTS/advanced/ai-threat-detection/backend/ml/scaler.py
Change type: new file

Diff:
@@ -0,0 +1,91 @@
+"""
+©AngelaMos | 2026
+scaler.py
+"""
+
+import json
+from pathlib import Path
+
+import numpy as np
+from sklearn.preprocessing import RobustScaler
+
+
+class FeatureScaler:
+    """
+    IQR-based feature scaler persisted as JSON (not pickle).
+
+    Wraps sklearn RobustScaler for outlier-robust normalization.
+    Used only for autoencoder input — tree models are scale-invariant.
+    """
+
+    def __init__(self) -> None:
+        self._scaler: RobustScaler | None = None
+        self._fitted = False
+
+    @property
+    def n_features(self) -> int:
+        """
+        Number of features the scaler was fitted on.
+        """
+        if not self._fitted or self._scaler is None:
+            raise RuntimeError("Scaler has not been fitted")
+        return int(self._scaler.n_features_in_)
+
+    def fit(self, X: np.ndarray) -> FeatureScaler:
+        """
+        Fit the scaler on training data.
+        """
+        self._scaler = RobustScaler()
+        self._scaler.fit(X)
+        self._fitted = True
+        return self
+
+    def transform(self, X: np.ndarray) -> np.ndarray:
+        """
+        Transform features using the fitted scaler parameters.
+        """
+        if not self._fitted or self._scaler is None:
+            raise RuntimeError("Scaler has not been fitted")
+        return self._scaler.transform(X).astype(np.float32)
+
+    def inverse_transform(self, X: np.ndarray) -> np.ndarray:
+        """
+        Reverse the scaling transformation.
+        """
+        if not self._fitted or self._scaler is None:
+            raise RuntimeError("Scaler has not been fitted")
+        return self._scaler.inverse_transform(X).astype(np.float32)
+
+    def fit_transform(self, X: np.ndarray) -> np.ndarray:
+        """
+        Fit and transform in one step.
+        """
+        self.fit(X)
+        return self.transform(X)
+
+    def save_json(self, path: Path | str) -> None:
+        """
+        Serialize scaler parameters to a human-readable JSON file.
+        """
+        if not self._fitted or self._scaler is None:
+            raise RuntimeError("Scaler has not been fitted")
+        data = {
+            "center": self._scaler.center_.tolist(),
+            "scale": self._scaler.scale_.tolist(),
+            "n_features": int(self._scaler.n_features_in_),
+        }
+        Path(path).write_text(json.dumps(data, indent=2))
+
+    @classmethod
+    def load_json(cls, path: Path | str) -> FeatureScaler:
+        """
+        Reconstruct a fitted scaler from a JSON file.
+        """
+        data = json.loads(Path(path).read_text())
+        scaler = cls()
+        scaler._scaler = RobustScaler()
+        scaler._scaler.center_ = np.array(data["center"], dtype=n
```

---

## Code Evolution

### Change Analysis for `scaler.py`

**What was Changed:**
A new file, `scaler.py`, was added to the project. This file introduces a custom class `FeatureScaler` that wraps `sklearn.RobustScaler`. The class provides methods for fitting, transforming, and inverse transforming data, as well as saving and loading scaler parameters in JSON format.

**Why it was Likely Changed:**
The change likely aims to standardize feature scaling within the project. By using a custom wrapper around `RobustScaler`, the code can enforce specific behaviors (like not using pickle for serialization) and ensure consistency across different parts of the project, particularly where autoencoders are used but tree models are scale-invariant.

**Impact on Behavior:**
- The class provides robust scaling with outlier resistance.
- It ensures that scaler parameters are saved and loaded as JSON, making them human-readable and portable.
- Methods like `fit_transform` simplify common workflows.

**Risks or Concerns:**
- **Serialization Risk:** While using JSON for serialization is safer than pickle, it might not capture all the internal state of `RobustScaler`.
- **Performance Impact:** The custom class adds a layer of abstraction, which could introduce minor performance overhead.
- **Maintenance Complexity:** Adding new methods and properties increases code complexity, requiring careful maintenance.

Overall, this change enhances the project's robustness and maintainability by standardizing feature scaling practices.

---

*Generated by CodeWorm on 2026-02-26 01:43*
