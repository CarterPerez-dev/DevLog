# EventPublisher

**Type:** Class Documentation
**Repository:** CodeWorm
**File:** codeworm/core/events.py
**Language:** python
**Lines:** 17-76
**Complexity:** 0.0

---

## Source Code

```python
class EventPublisher:
    CHANNEL_LOGS = "codeworm:logs"
    CHANNEL_EVENTS = "codeworm:events"
    CHANNEL_STATS = "codeworm:stats"

    def __init__(self, redis_url: str) -> None:
        import redis as redis_lib

        self._client = redis_lib.Redis.from_url(
            redis_url,
            decode_responses = False,
            socket_connect_timeout = 2,
            socket_timeout = 2,
        )
        self._lock = threading.Lock()
        self._connected = False
        self._check_connection()

    def _check_connection(self) -> bool:
        try:
            self._client.ping()
            self._connected = True
            return True
        except Exception:
            self._connected = False
            return False

    def _publish(self, channel: str, data: dict) -> None:
        if not self._connected and not self._check_connection():
            return
        try:
            payload = orjson.dumps(data, default = str)
            with self._lock:
                self._client.publish(channel, payload)
        except Exception:
            self._connected = False

    def publish_log(self, event_dict: dict) -> None:
        self._publish(self.CHANNEL_LOGS, event_dict)

    def publish_event(self, event_type: str, data: dict | None = None) -> None:
        payload = {
            "type": event_type,
            "timestamp": datetime.now().isoformat(),
            "data": data or {},
        }
        self._publish(self.CHANNEL_EVENTS, payload)

    def publish_stats(self, stats: dict) -> None:
        payload = {
            "timestamp": datetime.now().isoformat(),
            **stats,
        }
        self._publish(self.CHANNEL_STATS, payload)

    def close(self) -> None:
        try:  # noqa: SIM105
            self._client.close()
        except Exception:  # noqa: S110
            pass
```

---

## Class Documentation

### EventPublisher Documentation

**Class Responsibility and Purpose:**
The `EventPublisher` class is responsible for publishing events, logs, and stats to Redis channels. It ensures that messages are published only when the connection to Redis is active.

**Public Interface (Key Methods):**
- **`__init__(self, redis_url: str) -> None`:** Initializes the `EventPublisher` with a Redis URL.
- **`publish_log(self, event_dict: dict) -> None`:** Publishes log events to the "codeworm:logs" channel.
- **`publish_event(self, event_type: str, data: dict | None = None) -> None`:** Publishes generic event types with optional data to the "codeworm:events" channel.
- **`publish_stats(self, stats: dict) -> None`:** Publishes statistical data to the "codeworm:stats" channel.
- **`close(self) -> None`:** Closes the Redis connection.

**Design Patterns Used:**
The class uses a combination of:
- **Factory Pattern:** Implicitly through the `__init__` method, ensuring that an instance is created with proper configuration.
- **Observer Pattern:** By publishing events to different channels based on their type.
- **Strategy Pattern:** Through the `_publish` method, which handles the actual publishing logic.

**How it Fits in the Architecture:**
The `EventPublisher` class acts as a central hub for event management within the CodeWorm application. It ensures that all logging, event notifications, and statistical data are consistently published to Redis channels, facilitating real-time monitoring and analysis. The use of Redis provides low-latency performance, making it suitable for high-frequency events in the system.

---

*Generated by CodeWorm on 2026-02-28 14:58*
