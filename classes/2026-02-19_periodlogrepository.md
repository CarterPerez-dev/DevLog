# PeriodLogRepository

**Type:** Class Documentation
**Repository:** ios-test
**File:** fastapi/app/period_log/repository.py
**Language:** python
**Lines:** 17-120
**Complexity:** 0.0

---

## Source Code

```python
class PeriodLogRepository(BaseRepository[PeriodLog]):
    """
    Database operations for PeriodLog model
    """
    model = PeriodLog

    @classmethod
    async def get_by_partner_id(
        cls,
        session: AsyncSession,
        partner_id: UUID,
        skip: int = 0,
        limit: int = 100,
    ) -> Sequence[PeriodLog]:
        """
        Get period logs for a partner, ordered by start_date descending
        """
        result = await session.execute(
            select(PeriodLog)
            .where(PeriodLog.partner_id == partner_id)
            .order_by(PeriodLog.start_date.desc())
            .offset(skip)
            .limit(limit)
        )
        return result.scalars().all()

    @classmethod
    async def get_by_partner_and_date(
        cls,
        session: AsyncSession,
        partner_id: UUID,
        start_date: date,
    ) -> PeriodLog | None:
        """
        Get period log by partner and start date (unique constraint)
        """
        result = await session.execute(
            select(PeriodLog)
            .where(
                PeriodLog.partner_id == partner_id,
                PeriodLog.start_date == start_date,
            )
        )
        return result.scalars().first()

    @classmethod
    async def get_latest_for_partner(
        cls,
        session: AsyncSession,
        partner_id: UUID,
    ) -> PeriodLog | None:
        """
        Get most recent period log for a partner
        """
        result = await session.execute(
            select(PeriodLog)
            .where(PeriodLog.partner_id == partner_id)
            .order_by(PeriodLog.start_date.desc())
            .limit(1)
        )
        return result.scalars().first()

    @classmethod
    async def get_actual_logs(
        cls,
        session: AsyncSession,
        partner_id: UUID,
        limit: int = 12,
    ) -> Sequence[PeriodLog]:
        """
        Get actual (non-predicted) period logs for cycle calculations
        """
        result = await session.execute(
            select(PeriodLog)
            .where(
                PeriodLog.partner_id == partner_id,
                PeriodLog.is_predicted == False,
            )
            .order_by(PeriodLog.start_date.desc())
            .limit(limit)
        )
        return result.scalars().all()

    @classmethod
    async def delete_predicted_after_date(
        cls,
        session: AsyncSession,
        partner_id: UUID,
        after_date: date,
    ) -> int:
        """
        Delete predicted period logs after a given date (cleanup after new actual log)
        """
        from sqlalchemy import delete

        result = await session.execute(
            delete(PeriodLog)
            .where(
                PeriodLog.partner_id == partner_id,
                PeriodLog.is_predicted == True,
                PeriodLog.start_date > after_date,
            )
        )
        return result.rowcount
```

---

## Class Documentation

### PeriodLogRepository Documentation

**Class Responsibility and Purpose:**
The `PeriodLogRepository` class is responsible for managing database operations related to the `PeriodLog` model. It provides a clean, abstracted interface for interacting with period logs stored in a PostgreSQL database.

**Public Interface (Key Methods):**
- **get_by_partner_id:** Fetches period logs for a specific partner, ordered by start date.
- **get_by_partner_and_date:** Retrieves a unique period log based on partner ID and start date.
- **get_latest_for_partner:** Returns the most recent period log for a given partner.
- **get_actual_logs:** Fetches non-predicted period logs for cycle calculations.
- **delete_predicted_after_date:** Deletes predicted period logs after a specified date.

**Design Patterns Used:**
This class leverages the Repository pattern to encapsulate data access logic, ensuring that business logic remains separate from database interactions. The use of `async` methods and SQLAlchemy's ORM supports asynchronous operations and object-relational mapping.

**How it Fits in the Architecture:**
The `PeriodLogRepository` acts as a central hub for all database-related operations on `PeriodLog`. It is designed to be used by other components, such as services or controllers, which can rely on this repository to perform CRUD-like operations without needing to know the underlying database details. This separation enhances testability and maintainability of the application.

---

*Generated by CodeWorm on 2026-02-19 09:24*
