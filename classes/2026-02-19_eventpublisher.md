# EventPublisher

**Type:** Class Documentation
**Repository:** CodeWorm
**File:** codeworm/core/events.py
**Language:** python
**Lines:** 17-77
**Complexity:** 0.0

---

## Source Code

```python
class EventPublisher:
    CHANNEL_LOGS = "codeworm:logs"
    CHANNEL_EVENTS = "codeworm:events"
    CHANNEL_STATS = "codeworm:stats"

    def __init__(self, redis_url: str) -> None:
        import redis as redis_lib

        self._client = redis_lib.Redis.from_url(
            redis_url,
            decode_responses = False,
            socket_connect_timeout = 2,
            socket_timeout = 2,
        )
        self._lock = threading.Lock()
        self._connected = False
        self._check_connection()

    def _check_connection(self) -> bool:
        try:
            self._client.ping()
            self._connected = True
            return True
        except Exception:
            self._connected = False
            return False

    def _publish(self, channel: str, data: dict) -> None:
        if not self._connected:
            if not self._check_connection():
                return
        try:
            payload = orjson.dumps(data, default = str)
            with self._lock:
                self._client.publish(channel, payload)
        except Exception:
            self._connected = False

    def publish_log(self, event_dict: dict) -> None:
        self._publish(self.CHANNEL_LOGS, event_dict)

    def publish_event(self, event_type: str, data: dict | None = None) -> None:
        payload = {
            "type": event_type,
            "timestamp": datetime.now().isoformat(),
            "data": data or {},
        }
        self._publish(self.CHANNEL_EVENTS, payload)

    def publish_stats(self, stats: dict) -> None:
        payload = {
            "timestamp": datetime.now().isoformat(),
            **stats,
        }
        self._publish(self.CHANNEL_STATS, payload)

    def close(self) -> None:
        try:
            self._client.close()
        except Exception:
            pass
```

---

## Class Documentation

### EventPublisher Documentation

**Class Responsibility and Purpose**: 
The `EventPublisher` class is responsible for publishing events to different Redis channels, ensuring reliable communication between components within a distributed system. It abstracts the interaction with Redis, handling connection checks and data serialization.

**Public Interface (Key Methods)**:
- **`__init__(self, redis_url: str) -> None`**: Initializes the `EventPublisher` instance with a Redis URL.
- **`publish_log(self, event_dict: dict) -> None`**: Publishes log events to the "codeworm:logs" channel.
- **`publish_event(self, event_type: str, data: dict | None = None) -> None`**: Publishes generic event types with associated data to the "codeworm:events" channel.
- **`publish_stats(self, stats: dict) -> None`**: Publishes statistical data to the "codeworm:stats" channel.
- **`close(self) -> None`**: Closes the Redis connection gracefully.

**Design Patterns Used**:
- **Singleton Pattern**: Although not explicitly implemented, the class ensures a single instance for managing connections and publishing events.
- **Factory Method Pattern**: The `__init__` method acts as a factory to initialize the publisher with specific configurations.

**How It Fits in the Architecture**:
The `EventPublisher` is part of the core event handling module in CodeWorm. It integrates with other components by providing a reliable mechanism for publishing events, which can be consumed by various subscribers. The class ensures that connection issues are handled gracefully, maintaining system resilience.

---

*Generated by CodeWorm on 2026-02-19 13:29*
