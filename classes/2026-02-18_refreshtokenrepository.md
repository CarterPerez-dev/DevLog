# RefreshTokenRepository

**Type:** Class Documentation
**Repository:** my-portfolio
**File:** v1/backend/app/auth/repository.py
**Language:** python
**Lines:** 16-176
**Complexity:** 0.0

---

## Source Code

```python
class RefreshTokenRepository(BaseRepository[RefreshToken]):
    """
    Repository for RefreshToken model database operations
    """
    model = RefreshToken

    @classmethod
    async def get_by_hash(
        cls,
        session: AsyncSession,
        token_hash: str,
    ) -> RefreshToken | None:
        """
        Get refresh token by its hash
        """
        result = await session.execute(
            select(RefreshToken).where(RefreshToken.token_hash == token_hash)
        )
        return result.scalars().first()

    @classmethod
    async def get_valid_by_hash(
        cls,
        session: AsyncSession,
        token_hash: str,
    ) -> RefreshToken | None:
        """
        Get valid (not revoked, not expired) refresh token by hash
        """
        result = await session.execute(
            select(RefreshToken).where(
                RefreshToken.token_hash == token_hash,
                RefreshToken.is_revoked == False,
                RefreshToken.expires_at > datetime.now(UTC),
            )
        )
        return result.scalars().first()

    @classmethod
    async def create_token(
        cls,
        session: AsyncSession,
        user_id: UUID,
        token_hash: str,
        family_id: UUID,
        expires_at: datetime,
        device_id: str | None = None,
        device_name: str | None = None,
        ip_address: str | None = None,
    ) -> RefreshToken:
        """
        Create a new refresh token
        """
        token = RefreshToken(
            user_id = user_id,
            token_hash = token_hash,
            family_id = family_id,
            expires_at = expires_at,
            device_id = device_id,
            device_name = device_name,
            ip_address = ip_address,
        )
        session.add(token)
        await session.flush()
        await session.refresh(token)
        return token

    @classmethod
    async def revoke_token(
        cls,
        session: AsyncSession,
        token: RefreshToken,
    ) -> RefreshToken:
        """
        Revoke a single token
        """
        token.revoke()
        await session.flush()
        await session.refresh(token)
        return token

    @classmethod
    async def revoke_family(
        cls,
        session: AsyncSession,
        family_id: UUID,
    ) -> int:
        """
        Revoke all tokens in a family (for replay attack response)

        Returns count of revoked tokens
        """
        result = await session.execute(
            update(RefreshToken).where(
                RefreshToken.family_id == family_id,
                RefreshToken.is_revoked == False,
            ).values(is_revoked = True,
                     revoked_at = datetime.now(UTC))
        )
        await session.flush()
        return result.rowcount or 0

    @classmethod
    async def revoke_all_user_tokens(
        cls,
        session: AsyncSession,
        user_id: UUID,
    ) -> int:
        """
        Revoke all tokens for a user (logout all
```

---

## Class Documentation

### RefreshTokenRepository Documentation

**Class Responsibility and Purpose:**
The `RefreshTokenRepository` class is responsible for managing database operations related to the `RefreshToken` model. It provides a structured way to interact with refresh tokens, including creating, revoking, and cleaning up tokens.

**Public Interface (Key Methods):**
- `get_by_hash`: Retrieves a refresh token by its hash.
- `get_valid_by_hash`: Fetches valid (not revoked or expired) refresh tokens by their hash.
- `create_token`: Creates a new refresh token for a given user with optional device and IP information.
- `revoke_token`: Revokes a single specified token.
- `revoke_family`: Revoke all tokens in a family to prevent replay attacks.
- `revoke_all_user_tokens`: Logs out all devices associated with a user by revoking their tokens.
- `get_user_active_sessions`: Lists active sessions for a specific user.
- `cleanup_expired`: Cleans up expired tokens as part of maintenance tasks.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, which encapsulates data access logic and provides a clean interface to interact with the database. It also uses **SQLAlchemy ORM** for database operations, ensuring type safety and ease of use.

**How it Fits in the Architecture:**
`RefreshTokenRepository` acts as a central hub for all refresh token-related database interactions within the application. By providing a consistent and structured API, it ensures that other parts of the system can reliably manage tokens without needing to know the underlying database details. This separation of concerns enhances maintainability and testability.

---

*Generated by CodeWorm on 2026-02-18 19:34*
