# NoteRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/notes/repository.py
**Language:** python
**Lines:** 104-205
**Complexity:** 0.0

---

## Source Code

```python
class NoteRepository(BaseRepository[Note]):
    """
    Repository for Note operations
    """
    model = Note

    @classmethod
    async def get_all(
        cls,
        session: AsyncSession,
        folder_id: UUID | None = None,
    ) -> Sequence[Note]:
        """
        Get all non-deleted notes, optionally filtered by folder
        """
        query = select(Note).where(Note.deleted_at.is_(None)
                                   ).order_by(Note.sort_order,
                                              Note.title)
        if folder_id is not None:
            query = query.where(Note.folder_id == folder_id)
        result = await session.execute(query)
        return result.scalars().all()

    @classmethod
    async def get_root_notes(
        cls,
        session: AsyncSession,
    ) -> Sequence[Note]:
        """
        Get non-deleted notes without a folder
        """
        result = await session.execute(
            select(Note).where(Note.folder_id.is_(None)).where(
                Note.deleted_at.is_(None)
            ).order_by(Note.sort_order,
                       Note.title)
        )
        return result.scalars().all()

    @classmethod
    async def get_deleted(
        cls,
        session: AsyncSession,
    ) -> Sequence[Note]:
        """
        Get all soft-deleted notes
        """
        result = await session.execute(
            select(Note).where(Note.deleted_at.is_not(None)).order_by(
                Note.deleted_at.desc()
            )
        )
        return result.scalars().all()

    @classmethod
    async def soft_delete(
        cls,
        session: AsyncSession,
        note: Note,
    ) -> Note:
        """
        Soft delete a note
        """
        from datetime import datetime
        note.deleted_at = datetime.now(UTC)
        await session.flush()
        await session.refresh(note)
        return note

    @classmethod
    async def restore(
        cls,
        session: AsyncSession,
        note: Note,
    ) -> Note:
        """
        Restore a soft-deleted note
        """
        note.deleted_at = None
        await session.flush()
        await session.refresh(note)
        return note

    @classmethod
    async def bulk_soft_delete(
        cls,
        session: AsyncSession,
        note_ids: list[UUID],
    ) -> int:
        """
        Bulk soft delete multiple notes by their IDs
        """
        from datetime import datetime
        from sqlalchemy import update

        result = await session.execute(
            update(Note).where(Note.id.in_(note_ids)).where(
                Note.deleted_at.is_(None)
            ).values(deleted_at = datetime.now(UTC))
        )
        await session.flush()
        return result.rowcount
```

---

## Class Documentation

### NoteRepository Documentation

**Class Responsibility and Purpose:**
The `NoteRepository` class is responsible for managing CRUD operations on `Note` entities, specifically focusing on soft deletion and restoration of notes. It provides a clean interface to interact with the database using SQLAlchemy's asynchronous session.

**Public Interface (Key Methods):**
- `get_all`: Retrieves all non-deleted notes optionally filtered by folder.
- `get_root_notes`: Fetches non-deleted notes without a folder.
- `get_deleted`: Fetches all soft-deleted notes.
- `soft_delete`: Soft deletes a note by setting its `deleted_at` timestamp to the current UTC time.
- `restore`: Restores a soft-deleted note by setting its `deleted_at` to `None`.
- `bulk_soft_delete`: Soft deletes multiple notes by their IDs.

**Design Patterns Used:**
- **Repository Pattern**: The class encapsulates data access logic, providing a clean interface for interacting with the database.
- **Factory Method (Implicit)**: Methods like `get_all`, `get_root_notes`, and `get_deleted` are factory methods that return collections of notes based on certain criteria.

**How it Fits in the Architecture:**
The `NoteRepository` is part of the data access layer, ensuring that business logic remains separate from database interactions. It interacts with other classes through its public interface, such as services or controllers, which use these methods to manage note operations. This design promotes loose coupling and easier maintenance by abstracting the underlying database operations.

---

*Generated by CodeWorm on 2026-02-22 18:50*
