# BaseRepository

**Type:** Class Documentation
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/app/core/base_repository.py
**Language:** python
**Lines:** 23-106
**Complexity:** 0.0

---

## Source Code

```python
class BaseRepository(Generic[ModelT]):
    """
    Generic repository with common CRUD operations
    """
    model: type[ModelT]

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> ModelT | None:
        """
        Get a single record by ID
        """
        return await session.get(cls.model, id)

    @classmethod
    async def get_multi(
        cls,
        session: AsyncSession,
        skip: int = 0,
        limit: int = 100,
    ) -> Sequence[ModelT]:
        """
        Get multiple records with pagination
        """
        result = await session.execute(
            select(cls.model).offset(skip).limit(limit)
        )
        return result.scalars().all()

    @classmethod
    async def count(cls, session: AsyncSession) -> int:
        """
        Count total records
        """
        result = await session.execute(
            select(func.count()).select_from(cls.model)
        )
        return result.scalar_one()

    @classmethod
    async def create(
        cls,
        session: AsyncSession,
        **kwargs: Any,
    ) -> ModelT:
        """
        Create a new record
        """
        instance = cls.model(**kwargs)
        session.add(instance)
        await session.flush()
        await session.refresh(instance)
        return instance

    @classmethod
    async def update(
        cls,
        session: AsyncSession,
        instance: ModelT,
        **kwargs: Any,
    ) -> ModelT:
        """
        Update an existing record
        """
        for key, value in kwargs.items():
            setattr(instance, key, value)
        await session.flush()
        await session.refresh(instance)
        return instance

    @classmethod
    async def delete(
        cls,
        session: AsyncSession,
        instance: ModelT,
    ) -> None:
        """
        Delete a record
        """
        await session.delete(instance)
        await session.flush()
```

---

## Class Documentation

### BaseRepository Documentation

**Class Responsibility and Purpose:**
The `BaseRepository` class serves as a generic base for repositories, providing common CRUD operations (`get_by_id`, `get_multi`, `count`, `create`, `update`, `delete`). This class ensures consistency across different model-specific repositories by abstracting database interactions.

**Public Interface (Key Methods):**
- **`get_by_id(session: AsyncSession, id: UUID) -> ModelT | None`:** Retrieves a single record by its ID.
- **`get_multi(session: AsyncSession, skip: int = 0, limit: int = 100) -> Sequence[ModelT]`:** Fetches multiple records with pagination support.
- **`count(session: AsyncSession) -> int`:** Counts the total number of records in the database.
- **`create(session: AsyncSession, **kwargs: Any) -> ModelT`:** Creates a new record using keyword arguments.
- **`update(session: AsyncSession, instance: ModelT, **kwargs: Any) -> ModelT`:** Updates an existing record with provided keyword arguments.
- **`delete(session: AsyncSession, instance: ModelT) -> None`:** Deletes a specified record.

**Design Patterns Used:**
The class leverages the **Factory Method pattern** for creating and managing repository instances. It also implicitly uses the **Strategy pattern** through its generic type parameter `ModelT`, allowing different model-specific repositories to implement these methods with their own logic.

**How it Fits in the Architecture:**
`BaseRepository` is a crucial component of the backend architecture, providing a standardized interface for database operations. By using this base class, developers can focus on implementing specific business logic without worrying about boilerplate code. This promotes code reuse and maintainability across different models. The repository pattern ensures that data access logic is separated from business logic, adhering to the Single Responsibility Principle.

---

*Generated by CodeWorm on 2026-02-18 10:26*
