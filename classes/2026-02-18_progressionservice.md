# ProgressionService

**Type:** Class Documentation
**Repository:** CertGames-Core
**File:** backend/api/domains/progression/services/progression_ops.py
**Language:** python
**Lines:** 14-86
**Complexity:** 0.0

---

## Source Code

```python
class ProgressionService:
    """
    Service class for user progression operations (XP, levels, coins)
    """
    @staticmethod
    def update_xp(user: User, xp_amount: float) -> dict[str, int | float]:
        """
        Update user XP and level using atomic operations
        """
        old_level = user.level
        old_xp = user.xp
        new_xp = old_xp + xp_amount

        new_level = old_level
        while new_xp >= xp_required_for_level(new_level + 1):
            new_level += 1

        user.update(inc__xp = xp_amount, set__level = new_level)
        user.reload()

        return {"xp": user.xp, "level": user.level}

    @staticmethod
    def update_coins(user: User, amount: float) -> float:
        """
        Update user coins using atomic operations
        """
        if amount < 0 and user.coins + amount < 0:
            raise InsufficientFundsError(
                required_amount = abs(amount),
                current_balance = user.coins
            )

        new_coins = user.coins + amount

        user.update(set__coins = new_coins)
        user.reload()

        return user.coins

    @staticmethod
    def update_xp_and_coins(
        user: User,
        xp_amount: float,
        coin_amount: float
    ) -> dict[str,
              Any]:
        """
        Update user XP and coins in single atomic operation for performance
        """
        old_level = user.level
        old_xp = user.xp
        new_xp = old_xp + xp_amount

        new_level = old_level
        while new_xp >= xp_required_for_level(new_level + 1):
            new_level += 1

        new_coins = user.coins + coin_amount
        if new_coins < 0:
            raise InsufficientFundsError(
                required_amount = abs(coin_amount),
                current_balance = user.coins
            )

        user.update(
            inc__xp = xp_amount,
            set__level = new_level,
            set__coins = new_coins
        )
        user.reload()

        return {"xp": user.xp, "level": user.level, "coins": user.coins}
```

---

## Class Documentation

### ProgressionService Documentation

**Class Responsibility and Purpose:**
The `ProgressionService` class is a service layer responsible for managing user progression operations, including updating XP, levels, and coins. It ensures atomic updates to maintain data integrity.

**Public Interface (Key Methods):**
- `update_xp(user: User, xp_amount: float) -> dict[str, int | float]`: Updates the user's XP and level.
- `update_coins(user: User, amount: float) -> float`: Updates the user's coins with atomic operations.
- `update_xp_and_coins(user: User, xp_amount: float, coin_amount: float) -> dict[str, Any]`: Updates both XP and coins in a single atomic operation for performance.

**Design Patterns Used:**
The class uses static methods to encapsulate functionality without requiring an instance. It leverages Django's ORM (`user.update()` and `user.reload()`) for database operations, ensuring that updates are performed atomically.

**Relationship to Other Classes:**
- **User Model**: The `ProgressionService` interacts with the `User` model to update attributes such as XP, level, and coins.
- **InsufficientFundsError**: This custom exception is used to handle cases where a user does not have enough coins for an operation.

**State Management Approach:**
The class manages state by directly updating the `User` object's fields using Django's ORM methods. It ensures that all updates are performed atomically, preventing race conditions and maintaining data consistency.

This class fits into the architecture as part of the service layer, handling business logic operations related to user progression in a clean and maintainable manner.

---

*Generated by CodeWorm on 2026-02-18 14:52*
