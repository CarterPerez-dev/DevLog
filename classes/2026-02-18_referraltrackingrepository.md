# ReferralTrackingRepository

**Type:** Class Documentation
**Repository:** stripe-referral
**File:** src/stripe_referral/repositories/referral_repo.py
**Language:** python
**Lines:** 61-127
**Complexity:** 0.0

---

## Source Code

```python
class ReferralTrackingRepository(BaseRepository[ReferralTracking]):
    """
    Repository for ReferralTracking database operations
    """
    def __init__(self, db: Session) -> None:
        """
        Initialize with ReferralTracking model
        """
        super().__init__(db, ReferralTracking)

    def get_by_referrer(self, user_id: str) -> list[ReferralTracking]:
        """
        Get all referral conversions for a referrer
        """
        stmt = select(ReferralTracking).where(
            ReferralTracking.referrer_user_id == user_id
        )
        return list(self.db.execute(stmt).scalars().all())

    def get_pending_payouts(self,
                            program_id: int | None = None
                            ) -> list[ReferralTracking]:
        """
        Get all tracking records with pending payouts
        """
        stmt = select(ReferralTracking).where(
            ReferralTracking.payout_status ==
            ReferralTrackingStatus.PENDING.value
        )
        if program_id:
            stmt = stmt.where(ReferralTracking.program_id == program_id)
        return list(self.db.execute(stmt).scalars().all())

    def get_user_earnings(self, user_id: str) -> dict[str, float]:
        """
        Calculate total earnings for a user
        """
        stmt = select(
            func.sum(ReferralTracking.amount_earned).label("total"),
            func.sum(
                case(
                    (
                        ReferralTracking.payout_status
                        == ReferralTrackingStatus.PENDING.value,
                        ReferralTracking.amount_earned,
                    ),
                    else_ = 0,
                )
            ).label("pending"),
            func.sum(
                case(
                    (
                        ReferralTracking.payout_status
                        == ReferralTrackingStatus.PAID.value,
                        ReferralTracking.amount_earned,
                    ),
                    else_ = 0,
                )
            ).label("paid"),
        ).where(ReferralTracking.referrer_user_id == user_id)

        result = self.db.execute(stmt).one()
        return {
            "total": float(result.total or 0),
            "pending": float(result.pending or 0),
            "paid": float(result.paid or 0),
        }
```

---

## Class Documentation

### ReferralTrackingRepository Documentation

**Class Responsibility and Purpose:**
The `ReferralTrackingRepository` class is responsible for managing database operations related to referral tracking records. It provides methods to fetch referral conversions, pending payouts, and user earnings.

**Public Interface (Key Methods):**
- **`__init__(self, db: Session) -> None`:** Initializes the repository with a database session.
- **`get_by_referrer(self, user_id: str) -> list[ReferralTracking]`:** Retrieves all referral conversions for a specific referrer.
- **`get_pending_payouts(self, program_id: int | None = None) -> list[ReferralTracking]`:** Fetches tracking records with pending payouts, optionally filtered by program ID.
- **`get_user_earnings(self, user_id: str) -> dict[str, float]`:** Calculates total earnings for a user, including pending and paid amounts.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, which abstracts data access operations. It also uses SQL Alchemy's ORM to interact with the database, ensuring type safety and query construction.

**How it Fits in the Architecture:**
`ReferralTrackingRepository` is part of the data layer in the `stripe-referral` application. It interacts directly with the database through SQLAlchemy sessions (`Session`). This class ensures that business logic related to referral tracking remains separate from the database operations, promoting a clean separation of concerns and making the codebase more maintainable.

---

*Generated by CodeWorm on 2026-02-18 23:14*
