# FileTargetFinder

**Type:** Class Documentation
**Repository:** CodeWorm
**File:** codeworm/analysis/targets.py
**Language:** python
**Lines:** 41-113
**Complexity:** 0.0

---

## Source Code

```python
class FileTargetFinder:
    """
    Finds files worth documenting at the file level
    """
    def __init__(self, scanner: RepoScanner) -> None:
        self.scanner = scanner

    def find(
        self,
        repo: RepoEntry,
        limit: int = 20,
    ) -> list[DocumentationTarget]:
        targets: list[DocumentationTarget] = []

        for scanned_file in self.scanner.scan_repo(repo.path, repo.name):
            try:
                source = scanned_file.path.read_text(encoding = "utf-8")
            except Exception:  # noqa: S112
                continue

            line_count = source.count("\n") + 1
            if line_count < 20:
                continue

            extractor = CodeExtractor(source, scanned_file.language)
            func_count = sum(1 for _ in extractor.extract_functions())

            score = min(
                100.0,
                (
                    min(line_count / 200,
                        1.0) * 30 + min(func_count / 8,
                                        1.0) * 30 +
                    min(scanned_file.size_bytes / 5000,
                        1.0) * 20 + min(source.count("import ") / 10,
                                        1.0) * 20
                )
            )

            if score < 20:
                continue

            snippet = CodeSnippet(
                repo = repo.name,
                file_path = scanned_file.path,
                function_name = None,
                class_name = None,
                language = scanned_file.language,
                source = source[: 4000],
                start_line = 1,
                end_line = line_count,
                interest_score = score,
                doc_type = DocType.FILE_DOC,
            )

            targets.append(
                DocumentationTarget(
                    doc_type = DocType.FILE_DOC,
                    snippet = snippet,
                    source_context = source[: 6000],
                    metadata = {
                        "line_count": line_count,
                        "function_count": func_count,
                        "relative_path": str(scanned_file.relative_path),
                    },
                )
            )

            if len(targets) >= limit * 2:
                break

        targets.sort(key = lambda t: t.score, reverse = True)
        return targets[: limit]
```

---

## Class Documentation

### FileTargetFinder

**Class Responsibility and Purpose:**  
The `FileTargetFinder` class is responsible for identifying files within a repository that are worth documenting based on specific criteria such as file size, function count, and import statements.

**Public Interface:**
- **Method**: `find(repo: RepoEntry, limit: int = 20) -> list[DocumentationTarget]`
  - **Purpose**: Scans the specified repository for files meeting the documentation criteria and returns a list of `DocumentationTarget` objects.
  - **Parameters**:
    - `repo`: A `RepoEntry` object representing the repository to be scanned.
    - `limit`: The maximum number of targets to return (default is 20).
  - **Returns**: A list of `DocumentationTarget` objects, each containing metadata and a snippet of the file.

**Design Patterns Used:**
- **Strategy Pattern**: The class uses an `extractor` object from the `CodeExtractor` class to extract functions from source code snippets.
- **Factory Method**: Implicitly used through the instantiation of `CodeExtractor`.

**Relationship to Other Classes:**
- **RepoScanner**: Provides the method to scan the repository and retrieve file entries.
- **DocumentationTarget**: Represents a target for documentation, containing metadata and a snippet.
- **CodeSnippet**: Holds the source code snippet along with other relevant details.

**State Management Approach:**  
The class maintains state through its instance variables (`self.scanner`), but does not expose any mutable state directly. The `find` method processes each file independently to determine if it meets the criteria, ensuring that the logic is encapsulated within the method.

---

*Generated by CodeWorm on 2026-02-28 18:33*
