# NoteFolderRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/notes/repository.py
**Language:** python
**Lines:** 16-100
**Complexity:** 0.0

---

## Source Code

```python
class NoteFolderRepository(BaseRepository[NoteFolder]):
    """
    Repository for NoteFolder operations
    """
    model = NoteFolder

    @classmethod
    async def get_all(
        cls,
        session: AsyncSession,
    ) -> Sequence[NoteFolder]:
        """
        Get all non-deleted folders ordered by sort_order and name
        """
        result = await session.execute(
            select(NoteFolder)
            .where(NoteFolder.deleted_at.is_(None))
            .order_by(NoteFolder.sort_order, NoteFolder.name)
        )
        return result.scalars().all()

    @classmethod
    async def get_deleted(
        cls,
        session: AsyncSession,
    ) -> Sequence[NoteFolder]:
        """
        Get all soft-deleted folders
        """
        result = await session.execute(
            select(NoteFolder)
            .where(NoteFolder.deleted_at.is_not(None))
            .order_by(NoteFolder.deleted_at.desc())
        )
        return result.scalars().all()

    @classmethod
    async def soft_delete(
        cls,
        session: AsyncSession,
        folder: NoteFolder,
    ) -> NoteFolder:
        """
        Soft delete a folder
        """
        from datetime import datetime, timezone
        folder.deleted_at = datetime.now(timezone.utc)
        await session.flush()
        await session.refresh(folder)
        return folder

    @classmethod
    async def restore(
        cls,
        session: AsyncSession,
        folder: NoteFolder,
    ) -> NoteFolder:
        """
        Restore a soft-deleted folder
        """
        folder.deleted_at = None
        await session.flush()
        await session.refresh(folder)
        return folder

    @classmethod
    async def bulk_soft_delete(
        cls,
        session: AsyncSession,
        folder_ids: list[UUID],
    ) -> int:
        """
        Bulk soft delete multiple folders by their IDs
        """
        from datetime import datetime, timezone
        from sqlalchemy import update

        result = await session.execute(
            update(NoteFolder)
            .where(NoteFolder.id.in_(folder_ids))
            .where(NoteFolder.deleted_at.is_(None))
            .values(deleted_at=datetime.now(timezone.utc))
        )
        await session.flush()
        return result.rowcount
```

---

## Class Documentation

### NoteFolderRepository Documentation

**Class Responsibility and Purpose:**
The `NoteFolderRepository` class is responsible for managing operations related to `NoteFolder` entities, including fetching all non-deleted folders, retrieving soft-deleted folders, performing soft deletes, restorations, and bulk soft deletions. This class acts as a data access layer, adhering to the repository pattern.

**Public Interface (Key Methods):**
- **get_all(session: AsyncSession) -> Sequence[NoteFolder]:** Fetches all non-deleted `NoteFolder` instances ordered by `sort_order` and `name`.
- **get_deleted(session: AsyncSession) -> Sequence[NoteFolder]:** Retrieves soft-deleted `NoteFolder` instances.
- **soft_delete(session: AsyncSession, folder: NoteFolder) -> NoteFolder:** Soft deletes a specified `NoteFolder` instance.
- **restore(session: AsyncSession, folder: NoteFolder) -> NoteFolder:** Restores a previously soft-deleted `NoteFolder`.
- **bulk_soft_delete(session: AsyncSession, folder_ids: list[UUID]) -> int:** Bulk soft deletes multiple `NoteFolder` instances by their IDs.

**Design Patterns Used:**
The class employs the **Repository Pattern**, which abstracts data access operations. It also uses **SQLAlchemy ORM** for database interactions and leverages Pythonâ€™s **asyncio** for asynchronous operations, ensuring efficient and non-blocking data handling.

**How it Fits in the Architecture:**
`NoteFolderRepository` is part of a broader architecture where it interacts with other components such as business logic handlers or user interfaces. It ensures that all `NoteFolder` operations are encapsulated within this class, promoting separation of concerns and making the codebase more maintainable and testable.

---

*Generated by CodeWorm on 2026-02-18 17:16*
