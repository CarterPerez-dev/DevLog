# UserRepository

**Type:** Class Documentation
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/app/user/repository.py
**Language:** python
**Lines:** 15-111
**Complexity:** 0.0

---

## Source Code

```python
class UserRepository(BaseRepository[User]):
    """
    Repository for User model database operations
    """
    model = User

    @classmethod
    async def get_by_email(
        cls,
        session: AsyncSession,
        email: str,
    ) -> User | None:
        """
        Get user by email address
        """
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalars().first()

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> User | None:
        """
        Get user by ID
        """
        return await session.get(User, id)

    @classmethod
    async def email_exists(
        cls,
        session: AsyncSession,
        email: str,
    ) -> bool:
        """
        Check if email is already registered
        """
        result = await session.execute(
            select(User.id).where(User.email == email)
        )
        return result.scalars().first() is not None

    @classmethod
    async def create_user(
        cls,
        session: AsyncSession,
        email: str,
        hashed_password: str,
        full_name: str | None = None,
        role: UserRole = UserRole.USER,
    ) -> User:
        """
        Create a new user
        """
        user = User(
            email = email,
            hashed_password = hashed_password,
            full_name = full_name,
            role = role,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def update_password(
        cls,
        session: AsyncSession,
        user: User,
        hashed_password: str,
    ) -> User:
        """
        Update user password and increment token version
        """
        user.hashed_password = hashed_password
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def increment_token_version(
        cls,
        session: AsyncSession,
        user: User,
    ) -> User:
        """
        Invalidate all user tokens
        """
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user
```

---

## Class Documentation

### UserRepository Documentation

**Class Responsibility and Purpose**
The `UserRepository` class is responsible for managing database operations related to the `User` model. It abstracts common CRUD operations, ensuring that user data can be efficiently retrieved, created, updated, and validated.

**Public Interface (Key Methods)**
- **get_by_email**: Retrieves a user by their email address.
- **get_by_id**: Fetches a user by their unique ID.
- **email_exists**: Checks if an email is already registered in the database.
- **create_user**: Adds a new user to the database with specified details.
- **update_password**: Updates a user's password and increments their token version.
- **increment_token_version**: Invalidates all tokens associated with a user by incrementing their token version.

**Design Patterns Used**
The class leverages the **Repository Pattern**, which encapsulates data access logic, ensuring that business logic remains separate from database operations. Additionally, it uses **AsyncIO** for asynchronous operations to handle database interactions efficiently without blocking the event loop.

**How It Fits in the Architecture**
`UserRepository` serves as a central point of interaction with the `User` model's database representation. By providing a clean interface and handling complex operations like password updates and token version increments, it enables other parts of the application (e.g., user authentication services) to interact with users without needing to know the underlying database details. This separation enhances maintainability and testability.

---

*Generated by CodeWorm on 2026-02-18 09:59*
