# UserRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/auth/repositories/user.py
**Language:** python
**Lines:** 14-108
**Complexity:** 0.0

---

## Source Code

```python
class UserRepository(BaseRepository[User]):
    """
    Repository for User model database operations
    """
    model = User

    @classmethod
    async def get_by_email(
        cls,
        session: AsyncSession,
        email: str,
    ) -> User | None:
        """
        Get user by email address
        """
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalars().first()

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> User | None:
        """
        Get user by ID
        """
        return await session.get(User, id)

    @classmethod
    async def email_exists(
        cls,
        session: AsyncSession,
        email: str,
    ) -> bool:
        """
        Check if email is already registered
        """
        result = await session.execute(
            select(User.id).where(User.email == email)
        )
        return result.scalars().first() is not None

    @classmethod
    async def create_user(
        cls,
        session: AsyncSession,
        email: str,
        hashed_password: str,
        full_name: str | None = None,
    ) -> User:
        """
        Create a new user
        """
        user = User(
            email = email,
            hashed_password = hashed_password,
            full_name = full_name,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def update_password(
        cls,
        session: AsyncSession,
        user: User,
        hashed_password: str,
    ) -> User:
        """
        Update user password and increment token version
        """
        user.hashed_password = hashed_password
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def increment_token_version(
        cls,
        session: AsyncSession,
        user: User,
    ) -> User:
        """
        Invalidate all user tokens
        """
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user
```

---

## Class Documentation

### UserRepository Documentation

**Class Responsibility and Purpose:**
The `UserRepository` class is responsible for handling database operations related to the `User` model. It provides a clean, abstracted layer over SQLAlchemy sessions to perform common CRUD (Create, Read, Update, Delete) operations on user entities.

**Public Interface:**
- **get_by_email(session: AsyncSession, email: str) -> User | None**: Retrieves a user by their email address.
- **get_by_id(session: AsyncSession, id: UUID) -> User | None**: Fetches a user by their unique identifier (ID).
- **email_exists(session: AsyncSession, email: str) -> bool**: Checks if an email is already registered in the database.
- **create_user(session: AsyncSession, email: str, hashed_password: str, full_name: str | None = None) -> User**: Creates a new user with specified details and saves it to the database.
- **update_password(session: AsyncSession, user: User, hashed_password: str) -> User**: Updates a user's password and increments their token version.
- **increment_token_version(session: AsyncSession, user: User) -> User**: Invalidates all of a userâ€™s tokens by incrementing their token version.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, which encapsulates data access logic. It also uses SQLAlchemy's ORM capabilities for database interactions in an asynchronous context.

**How it Fits in the Architecture:**
`UserRepository` acts as a central point of interaction with the `User` model, ensuring that all user-related operations are consistent and follow best practices. This class is likely part of a larger authentication system or user management module within the application architecture, providing a clear separation between business logic and data access layers.

---

*Generated by CodeWorm on 2026-02-18 16:58*
