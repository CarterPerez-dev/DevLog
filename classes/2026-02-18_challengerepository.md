# ChallengeRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/challenge/facets/tracker/repository.py
**Language:** python
**Lines:** 18-107
**Complexity:** 0.0

---

## Source Code

```python
class ChallengeRepository(BaseRepository[Challenge]):
    """
    Repository for Challenge operations
    """
    model = Challenge

    @classmethod
    async def get_active(
        cls,
        session: AsyncSession,
    ) -> Challenge | None:
        """
        Get the currently active challenge
        """
        result = await session.execute(
            select(Challenge)
            .where(Challenge.is_active == True)
            .options(selectinload(Challenge.logs))
        )
        return result.scalar_one_or_none()

    @classmethod
    async def get_history(
        cls,
        session: AsyncSession,
        skip: int = 0,
        limit: int = 10,
    ) -> Sequence[Challenge]:
        """
        Get past challenges (inactive)
        """
        result = await session.execute(
            select(Challenge)
            .where(Challenge.is_active == False)
            .order_by(Challenge.start_date.desc())
            .offset(skip)
            .limit(limit)
        )
        return result.scalars().all()

    @classmethod
    async def count_history(
        cls,
        session: AsyncSession,
    ) -> int:
        """
        Count past challenges
        """
        result = await session.execute(
            select(func.count())
            .select_from(Challenge)
            .where(Challenge.is_active == False)
        )
        return result.scalar_one()

    @classmethod
    async def deactivate_all(
        cls,
        session: AsyncSession,
    ) -> None:
        """
        Deactivate all active challenges
        """
        await session.execute(
            update(Challenge)
            .where(Challenge.is_active == True)
            .values(is_active = False)
        )
        await session.flush()

    @classmethod
    async def create_challenge(
        cls,
        session: AsyncSession,
        start_date: date,
        content_goal: int = 1500,
        jobs_goal: int = 1000,
    ) -> Challenge:
        """
        Create a new challenge with calculated end date
        """
        end_date = start_date + timedelta(days = 29)
        return await cls.create(
            session,
            start_date = start_date,
            end_date = end_date,
            content_goal = content_goal,
            jobs_goal = jobs_goal,
            is_active = True,
        )
```

---

## Class Documentation

### ChallengeRepository Documentation

**Class Responsibility and Purpose:**
The `ChallengeRepository` class is responsible for managing operations related to challenges, including retrieving active and historical challenges, deactivating all active challenges, and creating new challenges. It acts as a data access layer, providing methods to interact with the database in a structured manner.

**Public Interface (Key Methods):**
- `get_active(session: AsyncSession) -> Challenge | None`: Retrieves the currently active challenge.
- `get_history(session: AsyncSession, skip: int = 0, limit: int = 10) -> Sequence[Challenge]`: Fetches past challenges that are inactive, ordered by start date in descending order.
- `count_history(session: AsyncSession) -> int`: Counts the number of historical challenges.
- `deactivate_all(session: AsyncSession) -> None`: Deactivates all active challenges.
- `create_challenge(session: AsyncSession, start_date: date, content_goal: int = 1500, jobs_goal: int = 1000) -> Challenge`: Creates a new challenge with a calculated end date and specified goals.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, which encapsulates data access logic to provide a clean interface for interacting with the database. The use of `AsyncSession` from SQLAlchemy ensures that all operations are performed asynchronously, making it suitable for modern web applications.

**How It Fits in the Architecture:**
`ChallengeRepository` is part of the data layer in the architecture, specifically designed to interact with the challenge domain model (`Challenge`). It provides a standardized way to perform CRUD (Create, Read, Update, Delete) operations on challenges. The class methods are called by higher-level services or controllers to manage challenges, ensuring that business logic and database interactions remain decoupled.

---

*Generated by CodeWorm on 2026-02-18 17:15*
