# UserFactory

**Type:** Class Documentation
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/conftest.py
**Language:** python
**Lines:** 125-160
**Complexity:** 0.0

---

## Source Code

```python
class UserFactory:
    """
    Factory for creating test users
    """
    _counter = 0

    @classmethod
    async def create(
        cls,
        session: AsyncSession,
        *,
        email: str | None = None,
        password: str = "TestPass123",
        full_name: str | None = None,
        role: UserRole = UserRole.USER,
        is_active: bool = True,
        is_verified: bool = True,
    ) -> User:
        cls._counter += 1

        user = User(
            email = email or f"user{cls._counter}@test.com",
            hashed_password = await hash_password(password),
            full_name = full_name or f"Test User {cls._counter}",
            role = role,
            is_active = is_active,
            is_verified = is_verified,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    def reset(cls) -> None:
        cls._counter = 0
```

---

## Class Documentation

### UserFactory Documentation

**Class Responsibility and Purpose:**
The `UserFactory` class is a factory for creating test users in an asynchronous context. It ensures that each user has unique attributes such as email, full name, and role while maintaining state through a counter.

**Public Interface (Key Methods):**
- **`create(session: AsyncSession, *, email: str | None = None, password: str = "TestPass123", full_name: str | None = None, role: UserRole = UserRole.USER, is_active: bool = True, is_verified: bool = True) -> User:`** 
  - Asynchronously creates a new user with specified or default attributes. The method uses an asynchronous session to add the user and flush changes to the database.
- **`reset() -> None:`**
  - Resets the internal counter used for generating unique user identifiers.

**Design Patterns Used:**
The `UserFactory` class employs the **Factory Method** pattern, which is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. This ensures flexibility and adherence to the Single Responsibility Principle by keeping user creation logic encapsulated.

**How It Fits in the Architecture:**
`UserFactory` fits into the testing architecture, specifically within the `conftest.py` file for test setup and teardown. It is used to create consistent and predictable test users across various tests, ensuring that each test starts with a clean slate by resetting the factory counter after use. This approach simplifies test case management and reduces boilerplate code in test fixtures.

---

*Generated by CodeWorm on 2026-02-18 12:30*
