# GeneratedDocumentation

**Type:** Class Documentation
**Repository:** CodeWorm
**File:** codeworm/llm/generator.py
**Language:** python
**Lines:** 49-140
**Complexity:** 0.0

---

## Source Code

```python
class GeneratedDocumentation:
    """
    Generated documentation for a code snippet
    """
    content: str
    commit_message: str
    snippet_filename: str
    generated_at: datetime
    tokens_used: int
    generation_time_ms: int
    doc_type: DocType = DocType.FUNCTION_DOC

    @property
    def word_count(self) -> int:
        return len(self.content.split())

    def to_markdown(self, candidate: AnalysisCandidate) -> str:
        """
        Format as markdown file content for AnalysisCandidate (legacy)
        """
        return self._format_markdown(
            display_name = candidate.snippet.display_name,
            repo = candidate.snippet.repo,
            file_path = str(candidate.scanned_file.relative_path),
            language = candidate.snippet.language.value,
            start_line = candidate.snippet.start_line,
            end_line = candidate.snippet.end_line,
            complexity = candidate.snippet.complexity,
            source = candidate.snippet.source,
        )

    def to_markdown_from_target(self, target: DocumentationTarget) -> str:
        """
        Format as markdown file content for DocumentationTarget
        """
        return self._format_markdown(
            display_name = target.display_name,
            repo = target.snippet.repo,
            file_path = target.metadata.get(
                "relative_path",
                str(target.snippet.file_path)
            ),
            language = target.snippet.language.value,
            start_line = target.snippet.start_line,
            end_line = target.snippet.end_line,
            complexity = target.snippet.complexity,
            source = target.source_context[: 3000],
        )

    def _format_markdown(
        self,
        display_name: str,
        repo: str,
        file_path: str,
        language: str,
        start_line: int,
        end_line: int,
        complexity: float,
        source: str,
    ) -> str:
        label = DOC_TYPE_LABELS.get(self.doc_type, "Documentation")

        header = f"""# {display_name}

**Type:** {label}
**Repository:** {repo}
**File:** {file_path}
**Language:** {language}
**Lines:** {start_line}-{end_line}
**Complexity:** {complexity}

---

"""
        code_block = f"""## Source Code

```{language}
{source}
```

---

"""
        doc_section = f"""## {label}

{self.content}

---

*Generated by CodeWorm on {self.generated_at.strftime('%Y-%m-%d %H:%M')}*
"""
        return header + code_block + doc_section
```

---

## Class Documentation

### GeneratedDocumentation Class Documentation

**Class Responsibility and Purpose:**
The `GeneratedDocumentation` class is responsible for generating and formatting documentation for code snippets based on their analysis results. It encapsulates metadata such as content, commit message, generation timestamp, and tokens used during the documentation process.

**Public Interface (Key Methods):**
- **`word_count`:** A property that calculates the number of words in the generated documentation.
- **`to_markdown(candidate: AnalysisCandidate) -> str`:** Formats the documentation for an `AnalysisCandidate`, producing a legacy markdown file content.
- **`to_markdown_from_target(target: DocumentationTarget) -> str`:** Produces markdown content based on a `DocumentationTarget`.

**Design Patterns Used:**
The class leverages property decorators to provide read-only access to calculated values. The `_format_markdown` method is used internally to generate the markdown content, adhering to the template method pattern.

**How It Fits in the Architecture:**
This class plays a crucial role in the CodeWorm architecture by handling the generation and formatting of documentation for code snippets. It interfaces with `AnalysisCandidate` and `DocumentationTarget`, providing formatted outputs that can be used for various purposes such as legacy systems or new documentation formats. The class is designed to be flexible, allowing it to adapt to different types of targets through its polymorphic behavior.

---

*Generated by CodeWorm on 2026-02-19 14:31*
