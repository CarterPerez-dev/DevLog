# TelegramService

**Type:** Class Documentation
**Repository:** CertGames-Core
**File:** backend/app/clients/telegram.py
**Language:** python
**Lines:** 16-142
**Complexity:** 0.0

---

## Source Code

```python
class TelegramService:

    def __init__(
        self,
        bot_token: str,
        admin_chat_id: str,
        webhook_secret: str | None = None
    ):
        self.bot_token = bot_token
        self.admin_chat_id = admin_chat_id
        self.webhook_secret = webhook_secret
        self.enabled = bool(bot_token and admin_chat_id)

    def _api_url(self, method: str) -> str:
        return TELEGRAM_API.format(token=self.bot_token, method=method)

    def send_message(
        self,
        text: str,
        reply_to_message_id: int | None = None
    ) -> int | None:
        if not self.enabled:
            return None

        payload: dict[str, Any] = {
            "chat_id": self.admin_chat_id,
            "text": text,
            "parse_mode": "HTML",
        }

        if reply_to_message_id:
            payload["reply_parameters"] = {
                "message_id": reply_to_message_id
            }

        try:
            response = requests.post(
                self._api_url("sendMessage"),
                json=payload,
                timeout=5
            )
            data = response.json()
            if data.get("ok"):
                return int(data["result"]["message_id"])

            current_app.logger.error(
                "Telegram API error: %s",
                data.get("description", "Unknown error")
            )
            return None
        except Exception as e:  # pylint: disable=broad-exception-caught
            current_app.logger.error(
                "Failed to send Telegram message: %s",
                str(e)
            )
            return None

    def register_webhook(self, webhook_url: str) -> bool:
        if not self.enabled:
            return False

        payload: dict[str, Any] = {
            "url": webhook_url,
            "allowed_updates": ["message"],
        }

        if self.webhook_secret:
            payload["secret_token"] = self.webhook_secret

        try:
            response = requests.post(
                self._api_url("setWebhook"),
                json=payload,
                timeout=10
            )
            data = response.json()
            if data.get("ok"):
                current_app.logger.info(
                    "Telegram webhook registered: %s",
                    webhook_url
                )
                return True

            current_app.logger.error(
                "Failed to register Telegram webhook: %s",
                data.get("description", "Unknown error")
            )
            return False
        except Exception as e:  # pylint: disable=broad-exception-caught
            current_app.logger.error(
                "Failed to register Telegram webhook: %s",
                str(e)
            )
            return False

    def notify_new_thread(
        self,
        thread_id: str,
        username: str,
        subject: str
    ) -> int | None:
        text = (
            "<b>New Support Thread</b>\n\n"
            f"User: {_escape_ht
```

---

## Class Documentation

### TelegramService Documentation

**Class Responsibility and Purpose**
The `TelegramService` class is responsible for interacting with a Telegram bot to send messages and register webhooks. It encapsulates the logic needed to communicate with the Telegram API, ensuring that only enabled services can perform actions.

**Public Interface (Key Methods)**
- **send_message**: Sends a message to an admin chat ID.
- **register_webhook**: Registers a webhook URL for receiving updates from Telegram.
- **notify_new_thread**: Notifies users about new support threads.
- **notify_user_message**: Notifies users about new messages in existing threads.

**Design Patterns Used**
The class uses the **Strategy Pattern** implicitly through its methods, which handle different types of messaging tasks. It also employs the **Facade Pattern**, as it provides a simplified interface to interact with the Telegram API.

**Relationship to Other Classes**
`TelegramService` interacts with other classes in the application by logging errors and warnings using `current_app.logger`. It is part of the broader client management system, handling external communication for the backend service. The class also depends on the `requests` library for making HTTP requests to the Telegram API.

**State Management Approach**
The state of `TelegramService` is managed through instance variables like `bot_token`, `admin_chat_id`, and `webhook_secret`. These values determine whether the service can perform actions, ensuring that only enabled services send messages or register webhooks.

---

*Generated by CodeWorm on 2026-02-18 14:04*
