# ChallengeRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/challenge/facets/tracker/repository.py
**Language:** python
**Lines:** 18-104
**Complexity:** 0.0

---

## Source Code

```python
class ChallengeRepository(BaseRepository[Challenge]):
    """
    Repository for Challenge operations
    """
    model = Challenge

    @classmethod
    async def get_active(
        cls,
        session: AsyncSession,
    ) -> Challenge | None:
        """
        Get the currently active challenge
        """
        result = await session.execute(
            select(Challenge).where(Challenge.is_active == True).options(
                selectinload(Challenge.logs)
            )
        )
        return result.scalar_one_or_none()

    @classmethod
    async def get_history(
        cls,
        session: AsyncSession,
        skip: int = 0,
        limit: int = 10,
    ) -> Sequence[Challenge]:
        """
        Get past challenges (inactive)
        """
        result = await session.execute(
            select(Challenge).where(Challenge.is_active == False).order_by(
                Challenge.start_date.desc()
            ).offset(skip).limit(limit)
        )
        return result.scalars().all()

    @classmethod
    async def count_history(
        cls,
        session: AsyncSession,
    ) -> int:
        """
        Count past challenges
        """
        result = await session.execute(
            select(func.count()).select_from(Challenge).where(
                Challenge.is_active == False
            )
        )
        return result.scalar_one()

    @classmethod
    async def deactivate_all(
        cls,
        session: AsyncSession,
    ) -> None:
        """
        Deactivate all active challenges
        """
        await session.execute(
            update(Challenge).where(Challenge.is_active == True
                                    ).values(is_active = False)
        )
        await session.flush()

    @classmethod
    async def create_challenge(
        cls,
        session: AsyncSession,
        start_date: date,
        content_goal: int = 1500,
        jobs_goal: int = 1000,
    ) -> Challenge:
        """
        Create a new challenge with calculated end date
        """
        end_date = start_date + timedelta(days = 29)
        return await cls.create(
            session,
            start_date = start_date,
            end_date = end_date,
            content_goal = content_goal,
            jobs_goal = jobs_goal,
            is_active = True,
        )
```

---

## Class Documentation

### ChallengeRepository Documentation

**Class Responsibility and Purpose:**
The `ChallengeRepository` class is responsible for managing operations related to challenges within a database, ensuring that CRUD-like operations are encapsulated and abstracted away from higher-level services.

**Public Interface (Key Methods):**
- **get_active(session)**: Retrieves the currently active challenge.
- **get_history(session, skip=0, limit=10)**: Fetches past inactive challenges with pagination support.
- **count_history(session)**: Counts the number of past challenges.
- **deactivate_all(session)**: Deactivates all currently active challenges.
- **create_challenge(session, start_date, content_goal=1500, jobs_goal=1000)**: Creates a new challenge with predefined goals and end date.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, which encapsulates data access logic. It also uses SQLAlchemy's ORM for database interactions, ensuring that all operations are performed within an asynchronous session context.

**How it Fits in the Architecture:**
`ChallengeRepository` acts as a central hub for challenge-related database operations, providing a clean interface to other services or components. By abstracting away direct database interactions, it promotes loose coupling and easier maintenance. The class interacts with `AsyncSession` from SQLAlchemy, ensuring that all database operations are performed asynchronously, which is crucial in modern web applications.

This design ensures that the repository can be easily replaced or extended without affecting dependent parts of the application, adhering to the Single Responsibility Principle.

---

*Generated by CodeWorm on 2026-02-22 02:55*
