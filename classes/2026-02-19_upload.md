# Upload

**Type:** Class Documentation
**Repository:** vuemantics
**File:** backend/models/Upload.py
**Language:** python
**Lines:** 42-877
**Complexity:** 0.0

---

## Source Code

```python
class Upload(BaseModel):
    """
    Upload model for media files

    Attributes:
        id: Unique identifier (UUID)
        user_id: Owner's user ID
        filename: Original filename
        file_path: Local storage path
        file_type: 'image' or 'video'
        file_size: Size in bytes
        mime_type: MIME type of file
        processing_status: Current processing state
        description: AI-generated description
        embedding_local: 1024-dimensional vector from bge-m3
        thumbnail_path: Path to generated thumbnail
        error_message: Error details if processing failed
        metadata: Additional file metadata (JSON)
        created_at: Upload timestamp
        updated_at: Last update timestamp
    """
    __tablename__ = "uploads"

    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize upload instance.
        """
        super().__init__(**kwargs)
        self.id: UUID = kwargs["id"]  # Uploads from DB always have IDs
        self.user_id: UUID = kwargs["user_id"]
        self.batch_id: UUID | None = kwargs.get("batch_id")
        self.filename: str = kwargs.get("filename", "")
        self.file_path: str = kwargs.get("file_path", "")
        self.file_type: str = kwargs.get("file_type", "")
        self.file_size: int = kwargs.get("file_size", 0)
        self.mime_type: str = kwargs.get("mime_type", "")
        self.processing_status: str = kwargs.get(
            "processing_status",
            ProcessingStatus.PENDING
        )
        self.description: str | None = kwargs.get("description")
        self.description_audit_score: int | None = kwargs.get(
            "description_audit_score"
        )

        # Handle embedding (1024-dim from bge-m3)
        embedding_local_raw = kwargs.get("embedding_local")
        if isinstance(embedding_local_raw, str):
            try:
                if embedding_local_raw.startswith(
                        "[") and embedding_local_raw.endswith("]"):
                    self.embedding_local: list[float] | None = list(
                        map(float,
                            embedding_local_raw[1 :-1].split(","))
                    )
                else:
                    self.embedding_local = None
            except (ValueError, AttributeError):
                self.embedding_local = None
        else:
            self.embedding_local = embedding_local_raw

        self.thumbnail_path: str | None = kwargs.get("thumbnail_path")
        self.video_codec: str | None = kwargs.get("video_codec")
        self.error_message: str | None = kwargs.get("error_message")
        self.hidden: bool = kwargs.get("hidden", False)
        self.regeneration_count: int = kwargs.get("regeneration_count", 0)
        self.last_regenerated_at: datetime | None = kwargs.get(
            "last_regenerated_at"
        )

        # Handle metadata - could be dict or JSON string from database
        metadata = kwargs.get("metadata")
        if isinstance(metadata, st
```

---

## Class Documentation

### Upload Class Documentation

**Class Responsibility and Purpose:**
The `Upload` class models a media file upload, handling attributes such as user ownership, file metadata, processing status, and AI-generated descriptions. It ensures that each uploaded file has a unique identifier, storage path, and associated metadata.

**Public Interface (Key Methods):**
- **__init__(self, **kwargs: Any) -> None**: Initializes an `Upload` instance with provided keyword arguments.
- **create_table(cls) -> None**: Class method to create the database table for storing uploads. Utilizes PostgreSQL's `vector` extension and JSONB columns.

**Design Patterns Used:**
The class leverages Pythonâ€™s dynamic typing and uses a factory pattern implicitly through its constructor, allowing flexible initialization from various data sources. It also employs type hints for better code readability and maintainability.

**Relationship to Other Classes:**
- **User**: Each upload is associated with a user via the `user_id` foreign key.
- **UploadBatch**: An optional batch ID links an upload to a specific processing batch, useful in bulk operations or tracking.
- **Metadata Handling**: The class uses JSONB for flexible metadata storage and handles string-to-list conversion for embeddings.

**State Management Approach:**
The class manages the state of each file through attributes like `processing_status`, `description`, and `metadata`. It ensures that the database schema is robust by creating necessary indexes, making it efficient for querying and updating.

---

*Generated by CodeWorm on 2026-02-19 02:24*
