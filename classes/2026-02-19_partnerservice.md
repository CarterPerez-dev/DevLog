# PartnerService

**Type:** Class Documentation
**Repository:** ios-test
**File:** fastapi/app/partner/service.py
**Language:** python
**Lines:** 16-114
**Complexity:** 0.0

---

## Source Code

```python
class PartnerService:
    """
    Business logic for partner operations
    """
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def create_partner(
        self,
        user_id: UUID,
        data: PartnerCreate,
    ) -> PartnerResponse:
        """
        Create partner profile for user (enforces one per user)
        """
        if await PartnerRepository.exists_for_user(self.session, user_id):
            raise PartnerAlreadyExists(str(user_id))

        partner = await PartnerRepository.create(
            self.session,
            user_id = user_id,
            name = data.name,
            average_cycle_length = data.average_cycle_length,
            average_period_length = data.average_period_length,
            cycle_regularity = data.cycle_regularity,
            last_period_start = data.last_period_start,
            notification_period_reminder = data.notification_period_reminder,
            notification_pms_alert = data.notification_pms_alert,
            notification_ovulation_alert = data.notification_ovulation_alert,
            reminder_days_before = data.reminder_days_before,
            timezone = data.timezone,
        )
        return PartnerResponse.model_validate(partner)

    async def get_partner(
        self,
        user_id: UUID,
    ) -> PartnerResponse:
        """
        Get partner profile for user
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))
        return PartnerResponse.model_validate(partner)

    async def get_partner_model(
        self,
        user_id: UUID,
    ) -> Partner:
        """
        Get partner model for internal use
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))
        return partner

    async def update_partner(
        self,
        user_id: UUID,
        data: PartnerUpdate,
    ) -> PartnerResponse:
        """
        Update partner profile
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        update_dict = data.model_dump(exclude_unset = True)
        updated = await PartnerRepository.update(
            self.session,
            partner,
            **update_dict,
        )
        return PartnerResponse.model_validate(updated)

    async def delete_partner(
        self,
        user_id: UUID,
    ) -> None:
        """
        Delete partner profile
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        await PartnerRepository.delete(self.session, partner)

    async def has_partner(
        self,
        user_id: UUID,
    ) -> bool:
        """
        Check if us
```

---

## Class Documentation

### PartnerService Documentation

**Class Responsibility and Purpose:**
The `PartnerService` class encapsulates business logic for managing partner profiles within a user's account. It ensures that each user can have only one partner profile, handles creation, retrieval, updating, and deletion of these profiles, and provides utility methods to check the existence of a partner.

**Public Interface (Key Methods):**
- `create_partner`: Creates a new partner profile for a given user.
- `get_partner`: Retrieves an existing partner profile by user ID.
- `get_partner_model`: Returns the internal model of the partner profile for internal use.
- `update_partner`: Updates an existing partner profile with provided data.
- `delete_partner`: Deletes a partner profile associated with a user.
- `has_partner`: Checks if a user has a partner profile.

**Design Patterns Used:**
The class leverages the **Repository Pattern** to abstract database operations, ensuring that business logic remains separate from data access. This separation enhances maintainability and testability.

**How it Fits in the Architecture:**
`PartnerService` acts as a service layer, providing high-level operations for managing partner profiles. It interacts with `PartnerRepository` to perform CRUD (Create, Read, Update, Delete) operations on the database. The class ensures that each user can only have one partner profile by enforcing unique constraints through repository methods. This design aligns with the **Single Responsibility Principle**, focusing solely on business logic related to partners, while leaving data persistence concerns to the repository layer.

---

*Generated by CodeWorm on 2026-02-19 09:17*
