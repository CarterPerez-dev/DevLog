# BaseModel

**Type:** Class Documentation
**Repository:** vuemantics
**File:** backend/models/Base.py
**Language:** python
**Lines:** 19-229
**Complexity:** 0.0

---

## Source Code

```python
class BaseModel:
    """
    Base class for all database models

    Provides:
    - Common fields: id, created_at, updated_at
    - CRUD operations: create, save, delete
    - Query helpers: find_by_id, find_all
    - Serialization: to_dict, from_record
    """
    __tablename__: str = ""
    __table_created__: bool = False

    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize model instance with field values
        """
        self.id: UUID | None = kwargs.get("id")
        self.created_at: datetime | None = kwargs.get("created_at")
        self.updated_at: datetime | None = kwargs.get("updated_at")

    @classmethod
    async def create_table(cls) -> None:
        """
        Create the table if it doesn't exist.

        Must be implemented by subclasses with their specific schema.
        """
        raise NotImplementedError(
            "Subclasses must implement create_table()"
        )

    @classmethod
    async def ensure_table_exists(cls) -> None:
        """
        Ensure table exists, create if not
        """
        if not cls.__table_created__:
            await cls.create_table()
            cls.__table_created__ = True

    @classmethod
    def from_record(cls: type[T], record: Record | None) -> T | None:
        """
        Create model instance from asyncpg Record
        """
        if record is None:
            return None

        return cls(**dict(record))

    @classmethod
    def from_records(cls: type[T], records: list[Record]) -> list[T]:
        """
        Create multiple model instances from asyncpg Records
        """
        result: list[T] = []
        for record in records:
            if record is not None:
                instance = cls.from_record(record)
                if instance is not None:
                    result.append(instance)
        return result

    def to_dict(self, exclude: set[str] | None = None) -> dict[str, Any]:
        """
        Convert model instance to dictionary
        """
        exclude = exclude or set()

        result = {}
        for key, value in self.__dict__.items():
            if key.startswith("_") or key in exclude:
                continue

            if isinstance(value, UUID):
                result[key] = str(value)
            elif isinstance(value, datetime):
                result[key] = value.isoformat()
            else:
                result[key] = value

        return result

    @classmethod
    async def find_by_id(cls: type[T], id: UUID | str) -> T | None:
        """
        Find a record by ID
        """
        await cls.ensure_table_exists()

        if isinstance(id, str):
            id = UUID(id)

        query = f"""
            SELECT * FROM {cls.__tablename__}
            WHERE id = $1
        """

        record = await database.db.fetchrow(query, id)
        return cls.from_record(record)

    @classmethod
    async def find_all(
        cls: type[T],
        limit: int = config.DEFAULT_QUERY_LIMIT,
        o
```

---

## Class Documentation

### BaseModel Documentation

**Class Responsibility and Purpose**
The `BaseModel` class serves as a base class for all database models, providing common fields like `id`, `created_at`, and `updated_at`. It also includes CRUD operations (create, save, delete) and query helpers. This class ensures consistency across different model implementations while abstracting away the underlying database interactions.

**Public Interface**
- **Initialization**: Initializes a model instance with field values.
- **Table Management**: Ensures table existence via `ensure_table_exists` and `create_table`.
- **Query Helpers**: Provides methods like `find_by_id`, `find_all`, and `count` for querying records.
- **Serialization**: Converts instances to dictionaries using `to_dict`.

**Design Patterns Used**
- **Factory Method Pattern**: The class uses factory methods (`from_record` and `from_records`) to create model instances from database records.
- **Strategy Pattern**: The `_insert` and `_update` methods are abstracted, requiring subclasses to implement specific logic for inserting and updating records.

**Relationship to Other Classes**
This base class is intended to be inherited by other models. It provides a standardized interface and behavior that can be extended or customized as needed. Subclasses must implement `create_table`, `_insert`, and `_update` methods.

**State Management Approach**
The class manages state through instance attributes like `id`, `created_at`, and `updated_at`. The `__table_created__` flag ensures that the table is only created once per model.

---

*Generated by CodeWorm on 2026-02-19 02:40*
