# NoteFolderRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/notes/repository.py
**Language:** python
**Lines:** 16-100
**Complexity:** 0.0

---

## Source Code

```python
class NoteFolderRepository(BaseRepository[NoteFolder]):
    """
    Repository for NoteFolder operations
    """
    model = NoteFolder

    @classmethod
    async def get_all(
        cls,
        session: AsyncSession,
    ) -> Sequence[NoteFolder]:
        """
        Get all non-deleted folders ordered by sort_order and name
        """
        result = await session.execute(
            select(NoteFolder).where(
                NoteFolder.deleted_at.is_(None)
            ).order_by(NoteFolder.sort_order,
                       NoteFolder.name)
        )
        return result.scalars().all()

    @classmethod
    async def get_deleted(
        cls,
        session: AsyncSession,
    ) -> Sequence[NoteFolder]:
        """
        Get all soft-deleted folders
        """
        result = await session.execute(
            select(NoteFolder).where(
                NoteFolder.deleted_at.is_not(None)
            ).order_by(NoteFolder.deleted_at.desc())
        )
        return result.scalars().all()

    @classmethod
    async def soft_delete(
        cls,
        session: AsyncSession,
        folder: NoteFolder,
    ) -> NoteFolder:
        """
        Soft delete a folder
        """
        from datetime import datetime, timezone
        folder.deleted_at = datetime.now(timezone.utc)
        await session.flush()
        await session.refresh(folder)
        return folder

    @classmethod
    async def restore(
        cls,
        session: AsyncSession,
        folder: NoteFolder,
    ) -> NoteFolder:
        """
        Restore a soft-deleted folder
        """
        folder.deleted_at = None
        await session.flush()
        await session.refresh(folder)
        return folder

    @classmethod
    async def bulk_soft_delete(
        cls,
        session: AsyncSession,
        folder_ids: list[UUID],
    ) -> int:
        """
        Bulk soft delete multiple folders by their IDs
        """
        from datetime import datetime, timezone
        from sqlalchemy import update

        result = await session.execute(
            update(NoteFolder).where(NoteFolder.id.in_(folder_ids)).where(
                NoteFolder.deleted_at.is_(None)
            ).values(deleted_at = datetime.now(timezone.utc))
        )
        await session.flush()
        return result.rowcount
```

---

## Class Documentation

### NoteFolderRepository Documentation

**Class Responsibility and Purpose:**
The `NoteFolderRepository` class is responsible for managing operations related to `NoteFolder` entities, including fetching, soft-deleting, restoring, and bulk soft-deleting folders. It adheres to the repository pattern, providing a clean interface for database interactions.

**Public Interface (Key Methods):**
- `get_all(session: AsyncSession) -> Sequence[NoteFolder]`: Retrieves all non-deleted folders ordered by sort order and name.
- `get_deleted(session: AsyncSession) -> Sequence[NoteFolder]`: Retrieves all soft-deleted folders, ordered by the time of deletion.
- `soft_delete(session: AsyncSession, folder: NoteFolder) -> NoteFolder`: Soft deletes a single folder by setting its `deleted_at` timestamp.
- `restore(session: AsyncSession, folder: NoteFolder) -> NoteFolder`: Restores a soft-deleted folder by resetting its `deleted_at` attribute to `None`.
- `bulk_soft_delete(session: AsyncSession, folder_ids: list[UUID]) -> int`: Soft deletes multiple folders by their IDs.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, which encapsulates data access logic and provides a clean interface for interacting with the database. It also uses **SQLAlchemy ORM** for database operations, ensuring type safety and leveraging Python's async capabilities.

**How it Fits in the Architecture:**
`NoteFolderRepository` is part of the data layer in the architecture, facilitating interactions between the application services and the database. It ensures that business logic related to folder management remains separate from the database access code, promoting a clean separation of concerns.

---

*Generated by CodeWorm on 2026-02-22 07:16*
