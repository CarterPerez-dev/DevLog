# ChecklistLogRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/checklist/repository.py
**Language:** python
**Lines:** 54-137
**Complexity:** 0.0

---

## Source Code

```python
class ChecklistLogRepository(BaseRepository[ChecklistLog]):
    """
    Repository for ChecklistLog operations
    """
    model = ChecklistLog

    @classmethod
    async def get_by_date(
        cls,
        session: AsyncSession,
        log_date: date,
    ) -> Sequence[ChecklistLog]:
        """
        Get all log entries for a date, joined with item for title/sort
        """
        result = await session.execute(
            select(ChecklistLog).join(ChecklistLog.item).where(
                ChecklistLog.log_date == log_date
            ).order_by(ChecklistItem.sort_order)
        )
        return result.scalars().all()

    @classmethod
    async def get_by_item_and_date(
        cls,
        session: AsyncSession,
        item_id: UUID,
        log_date: date,
    ) -> ChecklistLog | None:
        """
        Get a specific log entry
        """
        result = await session.execute(
            select(ChecklistLog).where(
                ChecklistLog.item_id == item_id,
                ChecklistLog.log_date == log_date,
            )
        )
        return result.scalar_one_or_none()

    @classmethod
    async def get_heatmap_data(
        cls,
        session: AsyncSession,
        start_date: date,
        end_date: date,
    ) -> Sequence[sa.Row]:
        """
        Get (log_date, completed_count, total_count) aggregates for a date range
        """
        result = await session.execute(
            select(
                ChecklistLog.log_date,
                func.sum(sa.cast(ChecklistLog.completed,
                                 sa.Integer)).label("completed_count"),
                func.count(ChecklistLog.id).label("total_count"),
            ).where(
                ChecklistLog.log_date >= start_date,
                ChecklistLog.log_date <= end_date,
            ).group_by(ChecklistLog.log_date).order_by(
                ChecklistLog.log_date
            )
        )
        return result.all()

    @classmethod
    async def get_item_completion_rates(
        cls,
        session: AsyncSession,
    ) -> Sequence[sa.Row]:
        """
        Get (item_id, total_days, completed_days) for all active items
        """
        result = await session.execute(
            select(
                ChecklistLog.item_id,
                func.count(ChecklistLog.id).label("total"),
                func.sum(sa.cast(ChecklistLog.completed,
                                 sa.Integer)).label("completed"),
            ).join(ChecklistLog.item).where(
                ChecklistItem.is_active == sa.true()
            ).group_by(ChecklistLog.item_id)
        )
        return result.all()
```

---

## Class Documentation

### ChecklistLogRepository Documentation

**Class Responsibility and Purpose:**
The `ChecklistLogRepository` class is responsible for managing database operations related to `ChecklistLog` entries. It provides methods to retrieve logs by date, specific item-date pairs, heatmap data over a date range, and completion rates for all active items.

**Public Interface (Key Methods):**
- `get_by_date(session: AsyncSession, log_date: date) -> Sequence[ChecklistLog]`: Retrieves all log entries for a given date.
- `get_by_item_and_date(session: AsyncSession, item_id: UUID, log_date: date) -> ChecklistLog | None`: Fetches a specific log entry by item ID and date.
- `get_heatmap_data(session: AsyncSession, start_date: date, end_date: date) -> Sequence[sa.Row]`: Aggregates logs to generate heatmap data for a specified date range.
- `get_item_completion_rates(session: AsyncSession) -> Sequence[sa.Row]`: Computes completion rates for all active checklist items.

**Design Patterns Used:**
The class leverages the **Repository Pattern**, encapsulating database operations and providing a clean interface for interacting with `ChecklistLog` data. It uses SQLAlchemy's declarative base to interact with the database asynchronously, ensuring efficient and type-safe queries.

**How it Fits in the Architecture:**
This repository acts as a central point of interaction between the application logic and the database. By abstracting database operations, it enables other parts of the system to focus on business logic rather than data retrieval. The use of asynchronous methods ensures that these operations do not block the main thread, making the application more responsive.

---

*Generated by CodeWorm on 2026-02-22 19:09*
