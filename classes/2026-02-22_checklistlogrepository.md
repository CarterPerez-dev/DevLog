# ChecklistLogRepository

**Type:** Class Documentation
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/checklist/repository.py
**Language:** python
**Lines:** 54-139
**Complexity:** 0.0

---

## Source Code

```python
class ChecklistLogRepository(BaseRepository[ChecklistLog]):
    """
    Repository for ChecklistLog operations
    """
    model = ChecklistLog

    @classmethod
    async def get_by_date(
        cls,
        session: AsyncSession,
        log_date: date,
    ) -> Sequence[ChecklistLog]:
        """
        Get all log entries for a date, joined with item for title/sort
        """
        result = await session.execute(
            select(ChecklistLog)
            .join(ChecklistLog.item)
            .where(ChecklistLog.log_date == log_date)
            .order_by(ChecklistItem.sort_order)
        )
        return result.scalars().all()

    @classmethod
    async def get_by_item_and_date(
        cls,
        session: AsyncSession,
        item_id: UUID,
        log_date: date,
    ) -> ChecklistLog | None:
        """
        Get a specific log entry
        """
        result = await session.execute(
            select(ChecklistLog)
            .where(
                ChecklistLog.item_id == item_id,
                ChecklistLog.log_date == log_date,
            )
        )
        return result.scalar_one_or_none()

    @classmethod
    async def get_heatmap_data(
        cls,
        session: AsyncSession,
        start_date: date,
        end_date: date,
    ) -> Sequence[sa.Row]:
        """
        Get (log_date, completed_count, total_count) aggregates for a date range
        """
        result = await session.execute(
            select(
                ChecklistLog.log_date,
                func.sum(sa.cast(ChecklistLog.completed, sa.Integer)).label("completed_count"),
                func.count(ChecklistLog.id).label("total_count"),
            )
            .where(
                ChecklistLog.log_date >= start_date,
                ChecklistLog.log_date <= end_date,
            )
            .group_by(ChecklistLog.log_date)
            .order_by(ChecklistLog.log_date)
        )
        return result.all()

    @classmethod
    async def get_item_completion_rates(
        cls,
        session: AsyncSession,
    ) -> Sequence[sa.Row]:
        """
        Get (item_id, total_days, completed_days) for all active items
        """
        result = await session.execute(
            select(
                ChecklistLog.item_id,
                func.count(ChecklistLog.id).label("total"),
                func.sum(sa.cast(ChecklistLog.completed, sa.Integer)).label("completed"),
            )
            .join(ChecklistLog.item)
            .where(ChecklistItem.is_active == sa.true())
            .group_by(ChecklistLog.item_id)
        )
        return result.all()
```

---

## Class Documentation

### ChecklistLogRepository Documentation

**Class Responsibility and Purpose:**
The `ChecklistLogRepository` class is responsible for managing database operations related to `ChecklistLog` entities, providing a clean abstraction layer over SQLAlchemy queries.

**Public Interface (Key Methods):**
- `get_by_date(session: AsyncSession, log_date: date) -> Sequence[ChecklistLog]`: Retrieves all logs for a specific date.
- `get_by_item_and_date(session: AsyncSession, item_id: UUID, log_date: date) -> ChecklistLog | None`: Fetches a specific log entry by item and date.
- `get_heatmap_data(session: AsyncSession, start_date: date, end_date: date) -> Sequence[sa.Row]`: Aggregates log data for a date range to create heatmap data.
- `get_item_completion_rates(session: AsyncSession) -> Sequence[sa.Row]`: Computes completion rates for all active checklist items.

**Design Patterns Used:**
The class employs the **Repository Pattern**, which encapsulates persistence logic and abstracts database operations. No specific design patterns like Factory, Observer, or Strategy are explicitly used in this implementation.

**How It Fits in the Architecture:**
`ChecklistLogRepository` acts as a central hub for CRUD-like operations on `ChecklistLog`. It is part of the data access layer, ensuring that business logic remains separate from database interactions. This class interacts with other entities like `ChecklistItem` and uses SQLAlchemy to perform complex queries, making it integral to the overall architecture by providing structured and efficient data management capabilities.

---

*Generated by CodeWorm on 2026-02-22 07:18*
