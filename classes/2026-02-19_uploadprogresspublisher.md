# UploadProgressPublisher

**Type:** Class Documentation
**Repository:** vuemantics
**File:** backend/core/websocket/publisher.py
**Language:** python
**Lines:** 19-198
**Complexity:** 0.0

---

## Source Code

```python
class UploadProgressPublisher:
    """
    Publishes upload progress events via Redis pub/sub

    Handles cross instance message delivery and local distribution
    Listens to Redis channels and forwards to connected WebSocket clients
    """
    def __init__(self) -> None:
        """
        Initialize publisher
        """
        self._listener_task: asyncio.Task | None = None
        self._running = False

    async def start(self) -> None:
        """
        Start Redis listener background task
        """
        if self._running:
            return

        self._running = True
        self._listener_task = asyncio.create_task(self._listen_redis())
        logger.info("UploadProgressPublisher started")

    async def stop(self) -> None:
        """
        Stop Redis listener
        """
        self._running = False

        if self._listener_task:
            self._listener_task.cancel()
            try:
                await asyncio.wait_for(self._listener_task, timeout = 2.0)
            except asyncio.CancelledError:
                pass
            except TimeoutError:
                logger.warning(
                    "Redis listener task did not stop within timeout, forcing shutdown"
                )
            except Exception as e:
                logger.error(f"Error stopping Redis listener: {e}")

        logger.info("UploadProgressPublisher stopped")

    async def publish_progress(
        self,
        upload_id: str,
        message: ServerMessage
    ) -> None:
        """
        Publish upload progress to Redis

        Args:
            upload_id: Upload's ID
            message: Progress message to broadcast
        """
        channel = f"upload:{upload_id}"
        payload = message.model_dump_json()

        try:
            await redis_pool.publish(channel, payload)
            logger.debug(f"Published progress for upload {upload_id}")
        except Exception as e:
            logger.error(f"Failed to publish to Redis: {e}")

    async def publish_to_user(
        self,
        user_id: str,
        message: ServerMessage
    ) -> None:
        """
        Publish message directly to a user

        Args:
            user_id: User's ID
            message: Message to broadcast
        """
        channel = f"user:{user_id}"
        payload = message.model_dump_json()

        try:
            await redis_pool.publish(channel, payload)
            logger.debug(f"Published message to user {user_id}")
        except Exception as e:
            logger.error(f"Failed to publish to Redis: {e}")

    async def _listen_redis(self) -> None:
        """
        Background task that listens to Redis pub/sub

        Receives messages from Redis and
        forwards to local WebSocket connections
        """
        pubsub = None
        try:
            pubsub = await redis_pool.psubscribe("upload:*", "user:*")

            logger.info("Redis listener started (patterns: upload:*, user:*)")

            while self._runn
```

---

## Class Documentation

### UploadProgressPublisher Documentation

**Class Responsibility and Purpose:**
The `UploadProgressPublisher` class is responsible for managing upload progress events by publishing them via Redis pub/sub system. It listens to specific channels, forwards messages to WebSocket clients, and handles cross-instance message delivery.

**Public Interface (Key Methods):**
- **start()**: Starts the background task that listens to Redis channels.
- **stop()**: Stops the Redis listener task gracefully.
- **publish_progress(upload_id: str, message: ServerMessage) -> None**: Publishes upload progress messages to Redis.
- **publish_to_user(user_id: str, message: ServerMessage) -> None**: Publishes messages directly to a specific user via Redis.

**Design Patterns Used:**
The class utilizes the **Observer Pattern** for listening and distributing events. It also employs asynchronous programming with `asyncio` tasks and context managers for handling background operations efficiently.

**How it Fits in the Architecture:**
This class is part of the WebSocket publisher module, which is responsible for bridging server-side events to client-side WebSocket connections. By leveraging Redis as a message broker, it ensures that upload progress updates are reliably distributed across multiple instances or clients. The class integrates with other components like `Manager` (presumably handling user connections and subscriptions) and `WebSocket` (for sending messages), making it a crucial component in the overall architecture for real-time communication.

---

*Generated by CodeWorm on 2026-02-19 01:45*
