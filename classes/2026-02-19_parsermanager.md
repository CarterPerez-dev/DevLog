# ParserManager

**Type:** Class Documentation
**Repository:** CodeWorm
**File:** codeworm/analysis/parser.py
**Language:** python
**Lines:** 55-107
**Complexity:** 0.0

---

## Source Code

```python
class ParserManager:
    """
    Thread-safe tree-sitter parser management
    Parsers are not thread-safe so we use thread-local storage
    """
    _languages: ClassVar[dict[CodeLanguage, Language]] = {}
    _local = threading.local()
    _initialized = False

    @classmethod
    def initialize(cls) -> None:
        """
        Initialize language grammars - call once at startup
        """
        if cls._initialized:
            return

        cls._languages = {
            CodeLanguage.PYTHON: Language(tspython.language()),
            CodeLanguage.TYPESCRIPT: Language(tstypescript.language_typescript()),
            CodeLanguage.TSX: Language(tstypescript.language_tsx()),
            CodeLanguage.JAVASCRIPT: Language(tsjs.language()),
            CodeLanguage.GO: Language(tsgo.language()),
            CodeLanguage.RUST: Language(tsrust.language()),
        }
        cls._initialized = True

    @classmethod
    def get_parser(cls, language: CodeLanguage) -> Parser:
        """
        Get a thread local parser for the specified language
        """
        if not cls._initialized:
            cls.initialize()

        if not hasattr(cls._local, "parsers"):
            cls._local.parsers = {}

        if language not in cls._local.parsers:
            parser = Parser(cls._languages[language])
            cls._local.parsers[language] = parser

        return cls._local.parsers[language]

    @classmethod
    def parse(cls, source: str | bytes, language: CodeLanguage) -> Tree:
        """
        Parse source code and return the syntax tree
        """
        parser = cls.get_parser(language)
        if isinstance(source, str):
            source = source.encode("utf-8")
        return parser.parse(source)
```

---

## Class Documentation

### ParserManager Documentation

**Class Responsibility and Purpose**
The `ParserManager` class manages thread-safe tree-sitter parsers for various programming languages, ensuring that each language's parser is initialized only once and shared across threads through thread-local storage.

**Public Interface (Key Methods)**
- **initialize()**: Initializes the language grammars required by the parsers. This method should be called at startup to ensure all necessary grammars are loaded.
- **get_parser(language: CodeLanguage)**: Retrieves a parser for the specified language, ensuring thread safety and efficient reuse of parsers.
- **parse(source: str | bytes, language: CodeLanguage)**: Parses the source code using the appropriate parser and returns the resulting syntax tree.

**Design Patterns Used**
The class employs the **Singleton** pattern through thread-local storage to ensure that each language's parser is shared across threads. It also uses the **Factory Method** pattern for initializing parsers, allowing for dynamic creation based on the specified language.

**How it Fits in the Architecture**
`ParserManager` acts as a central component responsible for managing and providing access to tree-sitter parsers. This class ensures that parsing operations are thread-safe and efficient by leveraging thread-local storage. It integrates into the broader architecture by offering a reliable interface for syntax analysis, which is crucial for code analysis tasks within the CodeWorm application.

---

*Generated by CodeWorm on 2026-02-19 13:57*
