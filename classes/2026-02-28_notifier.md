# Notifier

**Type:** Class Documentation
**Repository:** Telehook
**File:** src/telehook/notifier.py
**Language:** python
**Lines:** 18-72
**Complexity:** 0.0

---

## Source Code

```python
class Notifier:
    def __init__(
        self,
        config: TelehookConfig | None = None,
        middleware: list[Middleware] | None = None,
    ):
        self._config = config or TelehookConfig.from_env()
        self._transport = Transport(self._config)
        self._middleware_list = (
            middleware if middleware is not None else self._default_middleware()
        )
        self._chain: SendFunc = build_chain(
            self._middleware_list,
            self._transport_send
        )

    def _default_middleware(self) -> list[Middleware]:
        from telehook.middleware.rate_limiter import RateLimiter
        from telehook.middleware.retry import Retry

        return [RateLimiter(), Retry()]

    async def _transport_send(self, message: Message) -> None:
        await self._transport.send(message)

    async def send(self, content: str | Message) -> None:
        if isinstance(content, str):
            content = Message(text = content)
        await self._chain(content)

    def send_sync(self, content: str | Message) -> None:
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = None

        if loop and loop.is_running():
            import concurrent.futures

            with concurrent.futures.ThreadPoolExecutor(max_workers = 1) as pool:
                pool.submit(asyncio.run, self.send(content)).result()
        else:
            asyncio.run(self.send(content))

    async def close(self) -> None:
        for mw in self._middleware_list:
            if hasattr(mw, "close"):
                await mw.close()
        await self._transport.close()

    async def __aenter__(self) -> "Notifier":
        return self

    async def __aexit__(self, *exc: object) -> None:
        await self.close()
```

---

## Class Documentation

### Notifier Class Documentation

**Class Responsibility and Purpose:**
The `Notifier` class is responsible for sending messages via a configured transport mechanism, incorporating middleware to handle additional functionalities such as rate limiting and retries. It ensures that messages are sent asynchronously while providing a synchronous fallback.

**Public Interface (Key Methods):**
- **`__init__(self, config: TelehookConfig | None = None, middleware: list[Middleware] | None = None)`**: Initializes the `Notifier` with configuration and optional middleware.
- **`send(self, content: str | Message) -> None`**: Asynchronously sends a message or text content through the configured transport.
- **`send_sync(self, content: str | Message) -> None`**: Sends a message synchronously by running an asynchronous send in a separate thread if necessary.
- **`close(self) -> None`**: Closes all middleware and the transport gracefully.
- **`__aenter__(self) -> "Notifier"`** and **`__aexit__(self, *exc: object) -> None`**: Context manager methods to ensure proper cleanup when used in asynchronous contexts.

**Design Patterns Used:**
The class utilizes the **Strategy pattern** for handling different middleware strategies through a chain of responsibility. It also employs **Factory Method** patterns via `TelehookConfig.from_env()` and `build_chain`.

**How it Fits in the Architecture:**
`Notifier` acts as a central component for message sending, integrating with various transport mechanisms and middleware to provide robust and flexible notification capabilities. It is designed to be used both asynchronously and synchronously, making it suitable for a wide range of use cases within the Telehook architecture.

---

*Generated by CodeWorm on 2026-02-28 21:25*
