# InterestScorer._calculate_pattern_bonus

**Type:** Today I Learned
**Repository:** CodeWorm
**File:** codeworm/analysis/scoring.py
**Language:** python
**Lines:** 208-240
**Complexity:** 11.0

---

## Source Code

```python
def _calculate_pattern_bonus(
        self,
        decorators: list[str] | None,
        is_async: bool,
        source: str,
    ) -> float:
        """
        Calculate bonus points for interesting code patterns
        """
        bonus = 0.0

        if is_async:
            bonus += self.PATTERN_BONUSES["async"]

        if decorators:
            bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]

            decorator_text = " ".join(decorators).lower()
            if "property" in decorator_text:
                bonus += self.PATTERN_BONUSES["property"]
            if "classmethod" in decorator_text or "staticmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["class_method"]
            if "abstractmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["abstract"]
            if "dataclass" in decorator_text:
                bonus += self.PATTERN_BONUSES["dataclass"]

        if "yield" in source:
            bonus += self.PATTERN_BONUSES["generator"]
        if "__enter__" in source or "__exit__" in source:
            bonus += self.PATTERN_BONUSES["context_manager"]

        return bonus
```

---

## Today I Learned

TIL: In `InterestScorer._calculate_pattern_bonus`, the function dynamically calculates bonus points based on code patterns using a combination of conditional statements and string checks. This approach is clever because it allows for flexible and extensible pattern recognition, making the function adaptable to various code structures without needing complex logic or regular expressions.

```python
def _calculate_pattern_bonus(self, decorators: list[str] | None, is_async: bool, source: str) -> float:
    bonus = 0.0
    if is_async: bonus += self.PATTERN_BONUSES["async"]
    if decorators: 
        bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]
        for decorator in ["property", "classmethod", "staticmethod", "abstractmethod", "dataclass"]:
            if decorator in " ".join(decorators).lower(): bonus += self.PATTERN_BONUSES[decorator]
    if "yield" in source: bonus += self.PATTERN_BONUSES["generator"]
    if "__enter__" in source or "__exit__" in source: bonus += self.PATTERN_BONUSES["context_manager"]
    return bonus
```

---

*Generated by CodeWorm on 2026-02-22 12:17*
