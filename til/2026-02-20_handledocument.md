# handleDocument

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** CarterBot-Telegram/src/handlers/document.ts
**Language:** typescript
**Lines:** 143-214
**Complexity:** 17.0

---

## Source Code

```typescript
async function handleDocument(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username || "unknown";
  const chatId = ctx.chat?.id;
  const doc = ctx.message?.document;
  const mediaGroupId = ctx.message?.media_group_id;

  if (!userId || !chatId || !doc) {
    return;
  }

  if (!isAuthorized(userId, ALLOWED_USERS)) {
    await ctx.reply("Unauthorized. Contact the bot owner for access.");
    return;
  }

  if (doc.file_size && doc.file_size > MAX_FILE_SIZE) {
    await ctx.reply("File too large. Maximum size is 10MB.");
    return;
  }

  const fileName = doc.file_name || "";
  const extension = "." + (fileName.split(".").pop() || "").toLowerCase();
  const isPdf = doc.mime_type === "application/pdf" || extension === ".pdf";
  const isText = TEXT_EXTENSIONS.includes(extension) || doc.mime_type?.startsWith("text/");

  if (!isPdf && !isText) {
    await ctx.reply(
      `Unsupported file type: ${extension || doc.mime_type}\n\n` +
        `Supported: PDF, ${TEXT_EXTENSIONS.join(", ")}`
    );
    return;
  }

  let docPath: string;
  try {
    docPath = await downloadDocument(ctx);
  } catch (error) {
    console.error("Failed to download document:", error);
    await ctx.reply("Failed to download document.");
    return;
  }

  if (!mediaGroupId) {
    console.log(`Received document: ${fileName} from @${username}`);

    try {
      const content = await extractText(docPath, doc.mime_type);
      await processDocuments(
        ctx,
        [{ path: docPath, name: fileName, content }],
        ctx.message?.caption,
        userId,
        username,
        chatId
      );
    } catch (error) {
      console.error("Failed to extract document:", error);
      await ctx.reply(`Failed to process document: ${String(error).slice(0, 100)}`);
    }
    return;
  }

  await documentBuffer.addToGroup(
    mediaGroupId,
    docPath,
    ctx,
    userId,
    username,
    processDocumentPaths
  );
}
```

---

## Today I Learned

TIL: This function uses optional chaining (`?.`) to safely access properties like `ctx.from.id` and `ctx.message.document`, preventing potential errors from `undefined` values.

This clever approach ensures that the function can handle various input scenarios without throwing exceptions, making the code more robust and easier to read.

---

*Generated by CodeWorm on 2026-02-20 16:34*
