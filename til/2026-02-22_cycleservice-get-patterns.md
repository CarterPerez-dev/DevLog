# CycleService.get_patterns

**Type:** Today I Learned
**Repository:** ios-test
**File:** fastapi/app/cycle/service.py
**Language:** python
**Lines:** 267-350
**Complexity:** 17.0

---

## Source Code

```python
async def get_patterns(self, user_id: UUID) -> CyclePattern:
        """
        Analyze historical patterns
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        period_logs = await PeriodLogRepository.get_actual_logs(
            self.session,
            partner.id,
            limit = 12,
        )

        cycle_lengths = [
            log.cycle_length for log in period_logs
            if log.cycle_length is not None
        ]

        if cycle_lengths:
            avg_cycle = sum(cycle_lengths) / len(cycle_lengths)
            cycle_range = (min(cycle_lengths), max(cycle_lengths))
        else:
            avg_cycle = float(partner.average_cycle_length)
            cycle_range = (partner.average_cycle_length, partner.average_cycle_length)

        period_lengths = []
        for log in period_logs:
            if log.end_date:
                length = (log.end_date - log.start_date).days + 1
                period_lengths.append(length)

        avg_period = (
            sum(period_lengths) / len(period_lengths)
            if period_lengths
            else float(partner.average_period_length)
        )

        daily_logs = await DailyLogRepository.get_by_partner_id(
            self.session,
            partner.id,
            limit = 90,
        )

        symptoms_by_phase: dict[str, list[str]] = defaultdict(list)
        mood_counts_by_phase: dict[str, dict[str, int]] = defaultdict(lambda: defaultdict(int))

        for log in daily_logs:
            if not partner.last_period_start:
                continue

            days_since = (log.log_date - partner.last_period_start).days + 1
            if days_since <= 0:
                continue

            cycle_day = ((days_since - 1) % partner.average_cycle_length) + 1
            phase = self._get_phase(cycle_day, partner.average_cycle_length)
            phase_key = phase.value

            for symptom in log.symptoms:
                if symptom not in symptoms_by_phase[phase_key]:
                    symptoms_by_phase[phase_key].append(symptom)

            if log.mood:
                mood_counts_by_phase[phase_key][log.mood.value] += 1

        common_symptoms = {
            phase: symptoms[:5] for phase, symptoms in symptoms_by_phase.items()
        }

        mood_trends: dict[str, str | None] = {}
        for phase, counts in mood_counts_by_phase.items():
            if counts:
                mood_trends[phase] = max(counts, key = counts.get)
            else:
                mood_trends[phase] = None

        return CyclePattern(
            average_cycle_length = round(avg_cycle, 1),
            cycle_length_range = cycle_range,
            average_period_length = round(avg_period, 1),
            common_symptoms_by_phase = common_symptoms,
            mood_trends_by_phase = mood_trends,
        )
```

---

## Today I Learned

TIL: In `get_patterns`, defaultdict is cleverly used to initialize nested dictionaries for symptoms and mood counts, making the code more concise and readable. This pattern simplifies handling dynamic keys and default values, ensuring that each phase has its own list of symptoms and mood counts without explicit initialization.

```python
symptoms_by_phase: dict[str, list[str]] = defaultdict(list)
mood_counts_by_phase: dict[str, dict[str, int]] = defaultdict(lambda: defaultdict(int))
```

This technique reduces boilerplate and makes the logic cleaner.

---

*Generated by CodeWorm on 2026-02-22 10:38*
