# RefreshTokenFactory.create

**Type:** Today I Learned
**Repository:** my-portfolio
**File:** v1/backend/conftest.py
**Language:** python
**Lines:** 160-182
**Complexity:** 4.0

---

## Source Code

```python
async def create(
        cls,
        session: AsyncSession,
        user: User,
        *,
        is_revoked: bool = False,
        expires_delta: timedelta = timedelta(days = 7),
    ) -> tuple[RefreshToken,
               str]:
        raw_token = secrets.token_urlsafe(32)
        token_hash = hashlib.sha256(raw_token.encode()).hexdigest()

        token = RefreshToken(
            user_id = user.id,
            token_hash = token_hash,
            family_id = uuid4(),
            expires_at = datetime.now(UTC) + expires_delta,
            is_revoked = is_revoked,
        )
        session.add(token)
        await session.flush()
        await session.refresh(token)
        return token, raw_token
```

---

## Today I Learned

TIL: This async function cleverly uses `flush` and `refresh` to ensure the database object is up-to-date before returning, making it safe to access properties like `token.id`. This pattern ensures consistency between the in-memory object and the database state.

```python
async def create(
    cls,
    session: AsyncSession,
    user: User,
    *,
    is_revoked: bool = False,
    expires_delta: timedelta = timedelta(days=7),
) -> tuple[RefreshToken, str]:
    raw_token = secrets.token_urlsafe(32)
    token_hash = hashlib.sha256(raw_token.encode()).hexdigest()

    token = RefreshToken(
        user_id=user.id,
        token_hash=token_hash,
        family_id=uuid4(),
        expires_at=datetime.now(UTC) + expires_delta,
        is_revoked=is_revoked,
    )
    session.add(token)
    await session.flush()  # Ensure the object is written to the DB
    await session.refresh(token)  # Refresh the token object from the DB
    return token, raw_token
```

---

*Generated by CodeWorm on 2026-02-21 19:48*
