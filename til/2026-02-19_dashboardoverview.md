# DashboardOverview

**Type:** Today I Learned
**Repository:** CertGames-Core
**File:** frontend/admin-app/src/modules/analytics/components/dashboard/DashboardOverview.tsx
**Language:** tsx
**Lines:** 15-203
**Complexity:** 50.0

---

## Source Code

```tsx
function DashboardOverview(): React.JSX.Element {
  const { data, isLoading, error, isRefetching } = useDashboardOverview();
  const { data: errorTrends } = useErrorTrends({
    days: 1,
    interval: 'hourly',
  });

  if (isLoading && !isRefetching) {
    return (
      <div className={styles.loadingContainer}>
        <div className={styles.spinner} />
        <p>Loading dashboard metrics...</p>
      </div>
    );
  }

  if (error !== null && error !== undefined) {
    return (
      <div className={styles.errorContainer}>
        <FiAlertCircle className={styles.errorIcon} />
        <h3>Failed to Load Dashboard</h3>
        <p>Unable to fetch analytics data. Please try again later.</p>
      </div>
    );
  }

  if (data === null || data === undefined) {
    return (
      <div className={styles.emptyContainer}>
        <p>No analytics data available</p>
      </div>
    );
  }

  const calculateHealthScore = (): number => {
    if (data === null || data === undefined) return 0;

    let score = 100;

    if (data.errors !== null && data.errors !== undefined) {
      const errorRate = data.errors.unresolved / Math.max(data.errors.total, 1);
      score -= errorRate * 30;
    }

    if (
      data.performance?.slow_endpoints !== null &&
      data.performance?.slow_endpoints !== undefined &&
      data.performance.slow_endpoints > 0
    ) {
      score -= Math.min(data.performance.slow_endpoints * 2, 20);
    }

    if (
      data.database?.slow_query_collections !== null &&
      data.database?.slow_query_collections !== undefined &&
      data.database.slow_query_collections > 0
    ) {
      score -= Math.min(data.database.slow_query_collections * 3, 20);
    }

    return Math.max(Math.round(score), 0);
  };

  const healthScore = calculateHealthScore();

  const getErrorSparklineData = (): number[] | undefined => {
    if (errorTrends?.trends === null || errorTrends?.trends === undefined)
      return undefined;

    const trendData = Object.entries(errorTrends.trends)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([_, data]: [string, unknown]) => {
        const trendData = data as { total?: number };
        return trendData.total ?? 0;
      });

    return trendData.length > 0 ? trendData : undefined;
  };

  const metrics = [
    {
      id: 'errors',
      title: 'Errors',
      icon: FiAlertCircle,
      value: data.errors?.unresolved ?? 0,
      total: data.errors?.total ?? 0,
      label: 'unresolved',
      trend:
        data.errors?.resolution_rate !== null &&
        data.errors?.resolution_rate !== undefined &&
        data.errors.resolution_rate > 0
          ? `${(data.errors.resolution_rate * 100).toFixed(1)}% resolved`
          : undefined,
      status: (() => {
        const unresolved = data.errors?.unresolved ?? 0;
        if (unresolved === 0) return 'excellent' as const;
        if (unresolved < 5) return 'good' as const;
        if (unresolved < 10) return 'warning' as const;
        return 'critic
```

---

## Today I Learned

TIL: In `DashboardOverview`, I learned how to calculate and display dynamic health scores using conditional logic. The `calculateHealthScore` function intelligently adjusts the score based on error rates, slow endpoints, and slow queries, providing a clear health status that updates as data changes.

```tsx
const calculateHealthScore = (): number => {
  // ... complex logic ...
  return Math.max(Math.round(score), 0);
};
```

This pattern ensures real-time feedback, making it easier to understand the system's overall health at a glance.

---

*Generated by CodeWorm on 2026-02-19 15:02*
