# run

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** Docker-Kentros/cmd/server/main.go
**Language:** go
**Lines:** 80-189
**Complexity:** 10.0

---

## Source Code

```go
func run(ctx context.Context, cfg *config.Config, logger *slog.Logger) error {
	logger.Info("starting holophyly",
		"version", version,
		"address", cfg.Address(),
	)

	dockerClient, err := docker.NewClient()
	if err != nil {
		return fmt.Errorf("creating docker client: %w", err)
	}
	defer func() { _ = dockerClient.Close() }()

	if err := dockerClient.Ping(ctx); err != nil {
		return fmt.Errorf("docker daemon not available: %w", err)
	}
	logger.Info("connected to docker daemon")

	if !docker.IsComposeInstalled(ctx) {
		logger.Warn("docker compose not found - compose operations will fail")
	}

	dataDir := cfg.DataDir
	if dataDir == "" {
		home, _ := os.UserHomeDir()
		dataDir = filepath.Join(home, ".config", "holophyly")
	}

	prefStore, err := store.New(dataDir)
	if err != nil {
		logger.Warn("failed to initialize preferences store", "error", err)
	} else {
		defer func() { _ = prefStore.Close() }()
		logger.Info("preferences store initialized", "path", dataDir)
	}

	fileScanner := scanner.NewScanner(cfg.Scanner.Paths, cfg.Scanner.Exclude)

	protection := project.NewProtectionConfig(
		cfg.Protection.Patterns,
		cfg.Protection.Projects,
	)

	manager := project.NewManager(dockerClient, fileScanner, protection, prefStore)

	if err := manager.Refresh(ctx); err != nil {
		logger.Warn("initial project scan failed", "error", err)
	} else {
		projects := manager.ListProjects()
		logger.Info("initial scan complete", "projects_found", len(projects))
	}

	hub := websocket.NewHub(logger)
	go hub.Run(ctx)

	router := api.NewRouter(api.RouterConfig{
		Manager:        manager,
		Hub:            hub,
		Logger:         logger,
		AllowedOrigins: cfg.Server.AllowedOrigins,
	})

	api.MountStatic(router, web.FS())

	server := &http.Server{
		Addr:         cfg.Address(),
		Handler:      router,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 10 * time.Minute,
		IdleTimeout:  60 * time.Second,
	}

	go runPeriodicScanner(ctx, manager, cfg.Scanner.ScanInterval, logger)

	go hub.StartStatsStreamer(ctx, createStatsGetter(manager))

	serverErr := make(chan error, 1)
	go func() {
		logger.Info("server listening",
			"host", cfg.Server.Host,
			"port", cfg.Server.Port,
			"url", fmt.Sprintf("http://%s", cfg.Address()),
		)
		if err := server.ListenAndServe(); err != http.ErrServerClosed {
			serverErr <- err
		}
		close(serverErr)
	}()

	select {
	case err := <-serverErr:
		return fmt.Errorf("server error: %w", err)
	case <-ctx.Done():
		logger.Info("shutdown signal received")
	}

	shutdownCtx, cancel := context.WithTimeout(
		context.Background(),
		30*time.Second,
	)
	defer cancel()

	logger.Info("shutting down server")
	if err := server.Shutdown(shutdownCtx); err != nil {
		logger.Error("server shutdown error", "error", err)
		return fmt.Errorf("shutdown error: %w", err)
	}

	logger.Info("server stopped gracefully")
	return nil
}
```

---

## Today I Learned

TIL: In the `run` function, error handling is elegantly managed using deferred functions and context cancellation. For instance, when closing Docker clients and preference stores, `defer func() { _ = dockerClient.Close() }()` ensures resources are cleaned up even if errors occur earlier in the function. This pattern promotes robust resource management and clean code.

```go
if err := dockerClient.Ping(ctx); err != nil {
    return fmt.Errorf("docker daemon not available: %w", err)
}
logger.Info("connected to docker daemon")

defer func() { _ = dockerClient.Close() }()
```

This technique ensures that resources are properly closed, making the code more reliable and easier to maintain.

---

*Generated by CodeWorm on 2026-02-20 19:18*
