# run

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/cmd/api/main.go
**Language:** go
**Lines:** 46-192
**Complexity:** 11.0

---

## Source Code

```go
func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	_ = godotenv.Load()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	mongoClient, err := mongodb.NewClient(ctx, cfg.Mongo)
	if err != nil {
		return err
	}
	logger.Info("mongodb connected",
		"database", cfg.Mongo.Database,
		"max_pool_size", cfg.Mongo.MaxPoolSize,
	)

	sqliteClient, err := sqlite.NewClient(cfg.SQLite)
	if err != nil {
		return err
	}
	logger.Info("sqlite connected",
		"path", cfg.SQLite.Path,
	)

	healthHandler := health.NewHandler(mongoClient, sqliteClient)

	metricsRepo := mongodb.NewMetricsRepository(mongoClient)
	metricsSvc := metrics.NewService(metricsRepo, cfg.Mongo.Database)
	metricsHandler := handler.NewMetricsHandler(metricsSvc)

	backupRepo := sqlite.NewBackupRepository(sqliteClient)
	backupExecutor := backup.NewExecutor(cfg.Backup, cfg.Mongo.URI)
	backupScheduler := backup.NewScheduler(logger)
	backupSvc := backup.NewService(backupExecutor, backupScheduler, backupRepo, cfg.Backup.RetentionDays, logger)
	backupsHandler := handler.NewBackupsHandler(backupSvc, cfg.Mongo.Database)

	collectionsRepo := mongodb.NewCollectionsRepository(mongoClient)
	collectionsHandler := handler.NewCollectionsHandler(collectionsRepo, cfg.Mongo.Database)

	cleanupSvc := cleanup.NewService(mongoClient.Client(), cfg.Mongo.Database, 30, logger)

	wsHub := websocket.NewHub(logger)
	go wsHub.Run(ctx)

	wsHandler := websocket.NewHandler(wsHub, logger)

	metricsGetter := func(ctx context.Context) (any, error) {
		return metricsSvc.GetDashboardMetrics(ctx)
	}
	broadcaster := websocket.NewMetricsBroadcaster(wsHub, metricsGetter, 2000, logger)
	broadcaster.Start(ctx)
	logger.Info("websocket broadcaster started", "interval_ms", 2000)

	srv := server.New(server.Config{
		ServerConfig:  cfg.Server,
		HealthHandler: healthHandler,
		Logger:        logger,
	})

	router := srv.Router()

	router.Use(middleware.RequestID)
	router.Use(middleware.Logger(logger))
	router.Use(middleware.SecurityHeaders(cfg.App.Environment == "production"))
	router.Use(middleware.CORS(cfg.CORS))

	healthHandler.RegisterRoutes(router)
	metricsHandler.RegisterRoutes(router)
	backupsHandler.RegisterRoutes(router)
	collectionsHandler.RegisterRoutes(router)
	router.Handle("/ws", wsHandler)

	backupSvc.StartScheduler()
	if err := backupSvc.SetupDailyBackup(cfg.Mongo.Database); err != nil {
		logger.Warn("failed to setup daily backup", "error", err)
	}

	_, err = backupScheduler.Cron().AddFunc("0 20 21 * * *", func() {
		cleanupCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
		defer cancel()

		logger.Info("starting scheduled cleanup task")
		_, cleanupErr := cleanupSvc.CleanOldDocuments(cleanupCtx)
		i
```

---

## Today I Learned

TIL: In the `run` function, error handling is elegantly managed using deferred calls and context cancellation. This ensures resources are properly cleaned up even if errors occur, making the code robust and maintainable.

```go
ctx, stop := signal.NotifyContext(
    context.Background(),
    syscall.SIGINT,
    syscall.SIGTERM,
)
defer stop()
```

This pattern allows graceful shutdown by handling signals and ensuring all background tasks are stopped cleanly.

---

*Generated by CodeWorm on 2026-02-20 18:29*
