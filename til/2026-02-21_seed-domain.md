# seed_domain

**Type:** Today I Learned
**Repository:** my-portfolio
**File:** v1/data/tools/seed.py
**Language:** python
**Lines:** 204-278
**Complexity:** 22.0

---

## Source Code

```python
async def seed_domain(
    session: AsyncSession,
    domain: str,
    dry_run: bool = False,
    clear: bool = False,
) -> tuple[int, int]:
    config = DOMAIN_CONFIG[domain]
    model = config["model"]
    files = scan_seed_files(domain)

    if not files:
        print(f"  {color('dim', 'No files found')}")
        return 0, 0

    if clear and not dry_run:
        await session.execute(delete(model))
        print(f"  {color('yellow', 'Cleared existing records')}")

    inserted = 0
    errors = 0

    for file_path, lang_code, is_array_file in files:
        try:
            with open(file_path) as f:
                raw_data = json.load(f)

            records = raw_data if is_array_file else [raw_data]

            for idx, data in enumerate(records):
                try:
                    if "language" not in data or data["language"] is None:
                        data["language"] = lang_code

                    transformed = transform_data(data, config)

                    if dry_run:
                        label = f"{file_path.name}[{idx}]" if is_array_file else file_path.name
                        print(f"  {color('blue', '○')} {label} (dry-run)")
                    else:
                        upsert_keys = config.get("upsert_keys", [])
                        if upsert_keys:
                            stmt = insert(model).values(**transformed)
                            update_cols = {
                                k: v for k, v in transformed.items()
                                if k not in upsert_keys and k != "id"
                            }
                            stmt = stmt.on_conflict_do_update(
                                index_elements=upsert_keys,
                                set_=update_cols,
                            )
                            await session.execute(stmt)
                        else:
                            record = model(**transformed)
                            session.add(record)

                    inserted += 1

                except TypeError as e:
                    label = f"{file_path.name}[{idx}]" if is_array_file else file_path.name
                    print(f"  {color('red', '✗')} {label}: Field error - {e}")
                    errors += 1

            if not dry_run and is_array_file:
                print(f"  {color('green', '✓')} {file_path.name} ({len(records)} records)")
            elif not dry_run:
                print(f"  {color('green', '✓')} {file_path.name}")

        except json.JSONDecodeError as e:
            print(f"  {color('red', '✗')} {file_path.name}: Invalid JSON - {e}")
            errors += 1
        except Exception as e:
            print(f"  {color('red', '✗')} {file_path.name}: {e}")
            errors += 1

    return inserted, errors
```

---

## Today I Learned

TIL: I learned about using `on_conflict_do_update` with SQLAlchemy's `insert()` to handle upserts elegantly in the `seed_domain` function. This avoids complex merge logic and ensures data integrity by updating existing records while inserting new ones, making the code clean and Pythonic.

```python
stmt = stmt.on_conflict_do_update(
    index_elements=upsert_keys,
    set_=update_cols,
)
await session.execute(stmt)
```

This pattern is both clever and useful for managing database updates efficiently.

---

*Generated by CodeWorm on 2026-02-21 18:13*
