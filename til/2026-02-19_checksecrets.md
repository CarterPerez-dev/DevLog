# checkSecrets

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/docker-security-audit/internal/analyzer/dockerfile.go
**Language:** go
**Lines:** 201-270
**Complexity:** 14.0

---

## Source Code

```go
func (a *DockerfileAnalyzer) checkSecrets(
	target finding.Target,
	ast *parser.Node,
) finding.Collection {
	var findings finding.Collection

	for _, node := range ast.Children {
		cmd := strings.ToUpper(node.Value)
		if cmd != "ENV" && cmd != "ARG" && cmd != "RUN" && cmd != "LABEL" {
			continue
		}

		line := getFullLine(node)

		if cmd == "ENV" || cmd == "ARG" {
			varName := ""
			varValue := ""
			if node.Next != nil {
				parts := strings.SplitN(node.Next.Value, "=", 2)
				varName = parts[0]
				if len(parts) > 1 {
					varValue = parts[1]
				}
			}
			if rules.IsSensitiveEnvName(varName) {
				control, _ := benchmark.Get("4.10")
				loc := &finding.Location{Path: a.path, Line: node.StartLine}
				f := finding.New("CIS-4.10", "Sensitive variable in "+cmd+": "+varName, finding.SeverityHigh, target).
					WithDescription(control.Description).
					WithCategory(string(CategoryDockerfile)).
					WithLocation(loc).
					WithRemediation(control.Remediation).
					WithReferences(control.References...).
					WithCISControl(control.ToCISControl())
				findings = append(findings, f)
			}

			if varValue != "" &&
				rules.IsHighEntropyString(
					varValue,
					config.MinSecretLength,
					config.MinEntropyForSecret,
				) {
				loc := &finding.Location{Path: a.path, Line: node.StartLine}
				f := finding.New("DS-HIGH-ENTROPY", "High entropy string in "+cmd+" (potential secret)", finding.SeverityMedium, target).
					WithDescription("Value in " + varName + " has high entropy, indicating a potential hardcoded secret or key.").
					WithCategory(string(CategoryDockerfile)).
					WithLocation(loc).
					WithRemediation("Use Docker secrets, build arguments, or environment variables at runtime instead of hardcoding sensitive values.")
				findings = append(findings, f)
			}
		}

		secrets := rules.DetectSecrets(line)
		for _, secret := range secrets {
			control, _ := benchmark.Get("4.10")
			loc := &finding.Location{Path: a.path, Line: node.StartLine}
			f := finding.New("CIS-4.10", "Potential "+string(secret.Type)+" detected in Dockerfile", finding.SeverityHigh, target).
				WithDescription(secret.Description + ". " + control.Description).
				WithCategory(string(CategoryDockerfile)).
				WithLocation(loc).
				WithRemediation(control.Remediation).
				WithReferences(control.References...).
				WithCISControl(control.ToCISControl())
			findings = append(findings, f)
		}
	}

	return findings
}
```

---

## Today I Learned

TIL: In the `checkSecrets` function, the code uses string manipulation and conditional checks to identify potential secrets within Dockerfile commands like `ENV`, `ARG`, and `RUN`. It leverages helper functions for detecting high-entropy strings and applying specific rules, making it a clever way to automate security audits. üõ°Ô∏èüîç

---

*Generated by CodeWorm on 2026-02-19 01:59*
