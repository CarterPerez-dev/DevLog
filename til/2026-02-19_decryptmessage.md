# decryptMessage

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/crypto/double-ratchet.ts
**Language:** typescript
**Lines:** 225-289
**Complexity:** 9.0

---

## Source Code

```typescript
async function decryptMessage(
  state: DoubleRatchetState,
  message: EncryptedMessage,
  associatedData?: Uint8Array
): Promise<Uint8Array> {
  const peerPublicKey = base64ToBytes(message.header.dh_public_key)

  const skippedKeyId = createSkippedKeyId(
    peerPublicKey,
    message.header.message_number
  )
  const skippedKey = state.skipped_message_keys.get(skippedKeyId)

  if (skippedKey !== undefined) {
    state.skipped_message_keys.delete(skippedKeyId)

    const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
    const aad =
      associatedData !== undefined
        ? concatBytes(associatedData, headerBytes)
        : headerBytes

    return await aesGcmDecrypt(skippedKey, message.ciphertext, message.nonce, aad)
  }

  const isDifferentRatchetKey =
    state.dh_peer_public_key === null ||
    bytesToBase64(state.dh_peer_public_key) !== message.header.dh_public_key

  if (isDifferentRatchetKey) {
    if (state.receiving_chain_key !== null && state.dh_peer_public_key !== null) {
      await skipMessageKeys(state, message.header.previous_chain_length)
    }

    await performDHRatchet(state, peerPublicKey)
  }

  await skipMessageKeys(state, message.header.message_number)

  if (state.receiving_chain_key === null) {
    throw new Error('Receiving chain key not initialized after ratchet')
  }

  const { messageKey, nextChainKey } = await deriveMessageKey(
    state.receiving_chain_key
  )

  const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
  const aad =
    associatedData !== undefined
      ? concatBytes(associatedData, headerBytes)
      : headerBytes

  const plaintext = await aesGcmDecrypt(
    messageKey,
    message.ciphertext,
    message.nonce,
    aad
  )

  state.receiving_chain_key = nextChainKey
  state.receiving_message_number++

  return plaintext
}
```

---

## Today I Learned

TIL: The `decryptMessage` function uses a clever pattern to handle message decryption and key management. It conditionally skips message keys based on previous state, ensuring that only relevant keys are used for decryption. This approach enhances security by preventing the reuse of old keys and efficiently managing cryptographic state transitions.

```typescript
TIL: In `decryptMessage`, conditional skipping of message keys (`skippedKey !== undefined`) ensures only current keys are used, enhancing security and efficiency.
```

---

*Generated by CodeWorm on 2026-02-19 09:53*
