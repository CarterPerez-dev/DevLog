# parseService

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/docker-security-audit/internal/parser/compose.go
**Language:** go
**Lines:** 216-274
**Complexity:** 21.0

---

## Source Code

```go
func (cf *ComposeFile) parseService(name string, node *yaml.Node) *Service {
	svc := &Service{
		Name:        name,
		Node:        node,
		Line:        node.Line,
		Environment: make(map[string]EnvVar),
	}

	if node.Kind != yaml.MappingNode {
		return svc
	}

	for i := 0; i < len(node.Content); i += 2 {
		if i+1 >= len(node.Content) {
			break
		}
		key := node.Content[i].Value
		value := node.Content[i+1]

		switch key {
		case "image":
			svc.Image = value.Value
		case "build":
			svc.Build = cf.parseBuildConfig(value)
		case "ports":
			svc.Ports = cf.parsePorts(value)
		case "volumes":
			svc.Volumes = cf.parseVolumeMounts(value)
		case "environment":
			svc.Environment = cf.parseEnvironment(value)
		case "cap_add":
			svc.CapAdd = cf.parseStringList(value)
		case "cap_drop":
			svc.CapDrop = cf.parseStringList(value)
		case "privileged":
			svc.Privileged = value.Value == "true"
		case "read_only":
			svc.ReadOnly = value.Value == "true"
		case "user":
			svc.User = value.Value
		case "network_mode":
			svc.NetworkMode = value.Value
		case "pid":
			svc.PidMode = value.Value
		case "ipc":
			svc.IpcMode = value.Value
		case "security_opt":
			svc.SecurityOpt = cf.parseStringList(value)
		case "deploy":
			svc.Deploy = cf.parseDeployConfig(value)
		case "depends_on":
			svc.DependsOn = cf.parseDependsOn(value)
		case "healthcheck":
			svc.Healthcheck = cf.parseHealthcheck(value)
		}
	}

	return svc
}
```

---

## Today I Learned

TIL: In Go, this `parseService` function demonstrates a clean way to handle YAML mapping nodes using a switch statement. By iterating over node.Content in steps of two, it efficiently parses key-value pairs into corresponding fields, making the code both readable and maintainable.

```go
func (cf *ComposeFile) parseService(name string, node *yaml.Node) *Service {
	// ...
	for i := 0; i < len(node.Content); i += 2 {
		key := node.Content[i].Value
		value := node.Content[i+1]
		switch key {
		case "image":
			svc.Image = value.Value
		// other cases...
		}
	}
	// ...
}
```

This pattern reduces redundancy and enhances clarity, showing how Go can elegantly process complex data structures.

---

*Generated by CodeWorm on 2026-02-18 08:02*
