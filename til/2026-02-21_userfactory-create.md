# UserFactory.create

**Type:** Today I Learned
**Repository:** my-portfolio
**File:** v1/backend/conftest.py
**Language:** python
**Lines:** 124-148
**Complexity:** 4.0

---

## Source Code

```python
async def create(
        cls,
        session: AsyncSession,
        *,
        email: str | None = None,
        password: str = "TestPass123",
        full_name: str | None = None,
        role: UserRole = UserRole.USER,
        is_active: bool = True,
        is_verified: bool = True,
    ) -> User:
        cls._counter += 1

        user = User(
            email = email or f"user{cls._counter}@test.com",
            hashed_password = await hash_password(password),
            full_name = full_name or f"Test User {cls._counter}",
            role = role,
            is_active = is_active,
            is_verified = is_verified,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user
```

---

## Today I Learned

TIL: In the `create` method, the class uses a class variable `_counter` to generate unique email addresses for each user instance. This clever approach ensures that emails are distinct and easily traceable, making testing and debugging simpler.

```python
cls._counter += 1
user = User(email=email or f"user{cls._counter}@test.com", ...)
```

This pattern is both concise and effective for managing unique identifiers in async contexts!

---

*Generated by CodeWorm on 2026-02-21 19:37*
