# PerformanceScore.calculate

**Type:** Today I Learned
**Repository:** kill-pr0cess.inc
**File:** backend/src/models/performance.rs
**Language:** rust
**Lines:** 532-583
**Complexity:** 10.0

---

## Source Code

```rust
pub fn calculate(system_info: &SystemInfo, app_metrics: &ApplicationMetrics) -> Self {
        let mut component_scores = HashMap::new();
        let mut bottlenecks = Vec::new();
        let mut recommendations = Vec::new();

        // Calculate component scores
        let cpu_score = calculate_cpu_score(system_info.cpu_usage_percent);
        let memory_score = calculate_memory_score(system_info.memory_usage_percent);
        let response_time_score = calculate_response_time_score(app_metrics.average_response_time_ms);
        let error_rate_score = calculate_error_rate_score(app_metrics.error_rate_percent);

        component_scores.insert("cpu".to_string(), cpu_score);
        component_scores.insert("memory".to_string(), memory_score);
        component_scores.insert("response_time".to_string(), response_time_score);
        component_scores.insert("error_rate".to_string(), error_rate_score);

        // Identify bottlenecks
        if cpu_score < 70.0 {
            bottlenecks.push("High CPU utilization".to_string());
            recommendations.push("Consider optimizing CPU-intensive operations".to_string());
        }
        if memory_score < 70.0 {
            bottlenecks.push("High memory usage".to_string());
            recommendations.push("Review memory usage and implement cleanup".to_string());
        }
        if response_time_score < 70.0 {
            bottlenecks.push("Slow response times".to_string());
            recommendations.push("Optimize database queries and caching".to_string());
        }
        if error_rate_score < 70.0 {
            bottlenecks.push("High error rate".to_string());
            recommendations.push("Investigate and fix error sources".to_string());
        }

        let overall_score = component_scores.values().sum::<f64>() / component_scores.len() as f64;
        let grade = match overall_score {
            x if x >= 90.0 => PerformanceGrade::A,
            x if x >= 80.0 => PerformanceGrade::B,
            x if x >= 70.0 => PerformanceGrade::C,
            x if x >= 60.0 => PerformanceGrade::D,
            _ => PerformanceGrade::F,
        };

        Self {
            overall_score,
            grade,
            component_scores,
            bottlenecks,
            recommendations,
            trend: PerformanceTrend::Stable, // Would be calculated from historical data
        }
    }
```

---

## Today I Learned

TIL: This Rust function cleverly calculates performance scores by breaking down tasks into smaller, manageable steps using mutable variables (`component_scores`, `bottlenecks`, `recommendations`). It then methodically evaluates each component's score and identifies bottlenecks, ensuring the code remains clear and easy to follow. Each step is purposeful, making it a great example of modular programming in Rust.

---

*Generated by CodeWorm on 2026-02-21 12:38*
