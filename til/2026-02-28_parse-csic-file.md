# parse_csic_file

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/ml/data_loader.py
**Language:** python
**Lines:** 46-84
**Complexity:** 9.0

---

## Source Code

```python
def parse_csic_file(
    path: Path,
    label: int,
) -> list[CSICRequest]:
    """
    Parse a CSIC 2010 dataset file into a list of CSICRequest objects
    """
    text = path.read_text(encoding="utf-8", errors="replace")
    lines = text.splitlines()

    blocks: list[list[str]] = []
    current: list[str] = []

    for line in lines:
        match = _REQUEST_LINE_RE.match(line)
        if match and current:
            blocks.append(current)
            current = [line]
        elif match:
            current = [line]
        elif current:
            current.append(line)

    if current:
        blocks.append(current)

    results: list[CSICRequest] = []
    for block in blocks:
        req = _parse_request_block(block, label)
        if req is not None:
            results.append(req)

    logger.info(
        "Parsed %d requests from %s (label=%d)",
        len(results),
        path.name,
        label,
    )
    return results
```

---

## Today I Learned

TIL: The `parse_csic_file` function uses a clever state-based approach to parse lines into blocks, making complex text parsing more readable and maintainable. By tracking whether a block is active (`current`) and appending lines accordingly, it efficiently handles multipart request structures.

```python
blocks: list[list[str]] = []
current: list[str] = []

for line in lines:
    if match and current:
        blocks.append(current)
        current = [line]
    elif match:
        current = [line]
    elif current:
        current.append(line)

if current:
    blocks.append(current)
```

This pattern simplifies managing state transitions, making the code easier to understand.

---

*Generated by CodeWorm on 2026-02-28 22:37*
