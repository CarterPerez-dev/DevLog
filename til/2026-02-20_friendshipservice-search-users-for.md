# FriendshipService.search_users_for_friends

**Type:** Today I Learned
**Repository:** CertGames-Core
**File:** backend/api/domains/social/services/friendship_ops.py
**Language:** python
**Lines:** 393-478
**Complexity:** 11.0

---

## Source Code

```python
def search_users_for_friends(
        user_id: str | ObjectId,
        search_term: str,
        limit: int = 20
    ) -> list[SearchUserDict]:
        """
        Search users by username (autocomplete)
        Returns users with their friendship status relative to the searcher
        """
        user_id = ObjectId(user_id
                           ) if isinstance(user_id,
                                           str) else user_id

        users = User.objects(
            username__icontains = search_term,
            id__ne = user_id
        ).limit(limit)

        existing_friendships = Friendship.objects().filter(
            __raw__ = {
                "$or": [
                    {
                        "requesterUserId": user_id
                    },
                    {
                        "recipientUserId": user_id
                    }
                ]
            }
        )

        friendship_map = {}
        for friendship in existing_friendships:
            if friendship.requesterUserId == user_id:
                friend_id = str(friendship.recipientUserId)
            else:
                friend_id = str(friendship.requesterUserId)

            can_send = True
            if friendship.status == FriendshipStatus.REJECTED.value and friendship.requesterUserId == user_id:
                thirty_days_ago = datetime.now(UTC) - timedelta(days = 30)
                recent_rejections = [
                    dt for dt in friendship.rejectionHistory if (
                        dt.replace(tzinfo = UTC) if dt.tzinfo is
                        None else dt
                    ) >= thirty_days_ago
                ]
                can_send = len(recent_rejections) < 6

            friendship_map[friend_id] = {
                "status": friendship.status,
                "friendshipId": str(friendship.id),
                "iRequested": friendship.requesterUserId == user_id,
                "canSendRequest": can_send,
            }

        result: list[SearchUserDict] = []
        for user in users:
            friend_data = friendship_map.get(str(user.id), {})
            result.append(
                {
                    "userId":
                    str(user.id),
                    "username":
                    user.username,
                    "level":
                    user.level,
                    "currentAvatar":
                    str(user.currentAvatar)
                    if user.currentAvatar else None,
                    "nameColor":
                    user.nameColor,
                    "friendshipStatus":
                    friend_data.get("status"),
                    "friendshipId":
                    friend_data.get("friendshipId"),
                    "iRequested":
                    friend_data.get("iRequested",
                                    False),
                    "canSendRequest":
                    friend_data.get("canSendRequest",
                                    True),
     
```

---

## Today I Learned

TIL: In the `search_users_for_friends` function, a clever dictionary comprehension and conditional logic are used to map existing friendships. This allows for efficient lookup of friendship statuses when iterating over search results, reducing redundant database queries.

```python
friendship_map = {str(friendship.recipientUserId): ... for friendship in existing_friendships}
```

This pattern minimizes overhead by precomputing the friendship status and conditions directly into a dictionary, making subsequent checks faster.

---

*Generated by CodeWorm on 2026-02-20 09:42*
