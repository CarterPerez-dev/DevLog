# authenticate_websocket

**Type:** Today I Learned
**Repository:** vuemantics
**File:** backend/auth/dependencies.py
**Language:** python
**Lines:** 41-125
**Complexity:** 13.0

---

## Source Code

```python
async def authenticate_websocket(websocket: WebSocket) -> str | None:
    """
    Authenticate WebSocket connection via first message pattern

    Returns:
        User ID if authentication successful, None otherwise
    """
    origin = websocket.headers.get("origin", "")
    if origin and origin not in config.settings.cors_origins:
        logger.warning(f"WebSocket from unauthorized origin: {origin}")
        return None

    await websocket.accept()

    try:
        auth_data = await asyncio.wait_for(
            websocket.receive_json(),
            timeout = config.WEBSOCKET_AUTH_TIMEOUT
        )
    except TimeoutError:
        await websocket.send_json(
            AuthError(message = "Authentication timeout").model_dump()
        )
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_AUTH_TIMEOUT,
            reason = "Authentication timeout"
        )
        return None
    except WebSocketDisconnect:
        logger.debug(
            "WebSocket disconnected before auth (likely React StrictMode)"
        )
        return None
    except Exception as e:
        logger.error(f"Error receiving auth message: {e}")
        with contextlib.suppress(RuntimeError):
            await websocket.close(
                code = config.WEBSOCKET_CLOSE_INVALID_MESSAGE,
                reason = "Invalid message format"
            )
        return None

    if auth_data.get("type") != "auth" or not auth_data.get("token"):
        await websocket.send_json(
            AuthError(message = "Authentication required").model_dump()
        )
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_AUTH_REQUIRED,
            reason = "Authentication required"
        )
        return None

    try:
        payload = decode_token(
            auth_data["token"],
            expected_type = TokenType.ACCESS
        )

        user_id_raw = payload.get("sub")
        if not user_id_raw:
            raise AuthenticationError("Missing user ID in token")

        user_id: str = str(user_id_raw)
        user = await User.find_by_id(UUID(user_id))
        if not user or not user.is_active:
            raise AuthenticationError("User not found or inactive")

        token_version = payload.get("token_version", 0)
        if token_version != user.token_version:
            raise AuthenticationError("Token has been invalidated")

        await websocket.send_json(
            AuthSuccess(user_id = user_id).model_dump()
        )

        return user_id

    except AuthenticationError as e:
        logger.warning(f"WebSocket auth failed: {e}")
        await websocket.send_json(AuthError(message = str(e)).model_dump())
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_INVALID_TOKEN,
            reason = "Invalid token"
        )
        return None
```

---

## Today I Learned

TIL: This `authenticate_websocket` function elegantly handles various authentication scenarios using exception handling and context managers. It ensures secure WebSocket connections by validating tokens, checking origins, and managing timeouts. Clever use of `asyncio.wait_for` prevents infinite waits, making the auth process robust and efficient. ðŸš€ðŸ”—

---

*Generated by CodeWorm on 2026-02-22 09:35*
