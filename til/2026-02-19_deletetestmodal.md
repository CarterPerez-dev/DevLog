# DeleteTestModal

**Type:** Today I Learned
**Repository:** CertGames-Core
**File:** frontend/admin-app/src/modules/testing/components/modals/DeleteTestModal.tsx
**Language:** tsx
**Lines:** 40-320
**Complexity:** 28.0

---

## Source Code

```tsx
function DeleteTestModal({
  test,
  isOpen,
  onClose,
  onSuccess,
}: DeleteTestModalProps): React.JSX.Element | null {
  const { mutate: deleteTest, isPending: isDeleting } = useDeleteTest();

  const handleDelete = (): void => {
    if (test.testId !== null && test.testId !== undefined && test.testId > 0) {
      deleteTest(test.testId, {
        onSuccess: () => {
          if (onSuccess !== null && onSuccess !== undefined) {
            onSuccess();
          }
          onClose();
        },
      });
    }
  };

  const renderTestInfo = (): React.JSX.Element => {
    const categoryLabel = getCategoryLabel(test.category);
    const categoryColor = getCategoryColor(test.category);
    const hasData = (test.total_attempts ?? 0) > 0;

    return (
      <div className={styles.testInfo}>
        <div className={styles.testHeader}>
          <div className={styles.testTitle}>
            <FiFileText className={styles.testIcon} />
            <div className={styles.testTitleContent}>
              <h3 className={styles.title}>{test.title}</h3>
              {test.testName !== null && test.testName !== undefined && (
                <span className={styles.testName}>{test.testName}</span>
              )}
            </div>
          </div>

          <div className={styles.testMeta}>
            <span className={styles.testId}>ID: {String(test.testId)}</span>
            <span
              className={styles.categoryBadge}
              style={{ color: categoryColor, borderColor: `${categoryColor}40` }}
            >
              {categoryLabel}
            </span>
          </div>
        </div>

        <div className={styles.testStats}>
          <div className={styles.statItem}>
            <FiFileText className={styles.statIcon} />
            <span className={styles.statLabel}>Questions</span>
            <span className={styles.statValue}>{String(test.questions.length)}</span>
          </div>

          <div className={styles.statItem}>
            <FiUsers className={styles.statIcon} />
            <span className={styles.statLabel}>Attempts</span>
            <span className={styles.statValue}>
              {formatNumber(test.total_attempts ?? 0)}
            </span>
          </div>

          <div className={styles.statItem}>
            <FiTarget className={styles.statIcon} />
            <span className={styles.statLabel}>Unique Users</span>
            <span className={styles.statValue}>
              {formatNumber(test.unique_users ?? 0)}
            </span>
          </div>

          <div className={styles.statItem}>
            <FiClock className={styles.statIcon} />
            <span className={styles.statLabel}>Last Attempt</span>
            <span className={styles.statValue}>
              {formatTestTimestamp(test.last_attempted)}
            </span>
          </div>
        </div>

        {hasData && (
          <div className={styles.dataWarning}>
            <FiBarChart2 className={styles.warningIcon} />
           
```

---

## Today I Learned

TIL: In `DeleteTestModal`, the function uses non-null assertion operators (`!`) to safely access properties like `test.testId` and `onSuccess`. This ensures that the function only attempts to delete a test if `testId` is defined, preventing potential runtime errors. Clever and concise!

```tsx
if (test.testId !== null && test.testId !== undefined && test.testId > 0) {
  deleteTest(test.testId, { onSuccess: () => { /* ... */ } });
}
```

This pattern helps maintain robustness by ensuring all necessary conditions are met before proceeding.

---

*Generated by CodeWorm on 2026-02-19 16:12*
