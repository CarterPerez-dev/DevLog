# InsightsRepository.aggregate_by_posting_time

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/analytics/facets/insights/repository.py
**Language:** python
**Lines:** 397-429
**Complexity:** 3.0

---

## Source Code

```python
async def aggregate_by_posting_time(
        cls,
        session: AsyncSession
    ) -> dict:
        """Aggregate performance by posting day of week"""
        videos = await cls.get_all_videos(session)

        day_stats = defaultdict(
            lambda: {
                "videos": [],
                "total_views": 0,
                "total_engagement": 0,}
        )

        for video in videos:
            day = cls.get_day_of_week(video.date_posted)
            engagement_rate = cls.calculate_engagement_rate(video)

            day_stats[day]["videos"].append(video)
            day_stats[day]["total_views"] += video.views
            day_stats[day]["total_engagement"] += engagement_rate

        # Calculate averages
        result = {}
        for day, stats in day_stats.items():
            count = len(stats["videos"])
            result[day] = {
                "video_count": count,
                "avg_views": stats["total_views"] / count,
                "avg_engagement_rate": stats["total_engagement"] / count,
            }

        return result
```

---

## Today I Learned

TIL: In `aggregate_by_posting_time`, defaultdict is cleverly used to initialize nested dictionaries for each day of the week, simplifying accumulation logic and making the code more readable. This pattern reduces boilerplate and ensures consistent structure during aggregation.

```python
day_stats = defaultdict(lambda: {
    "videos": [],
    "total_views": 0,
    "total_engagement": 0})
```

This approach keeps track of videos, views, and engagement rates by day efficiently!

---

*Generated by CodeWorm on 2026-03-01 15:07*
