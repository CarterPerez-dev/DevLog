# scanStaged

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/source/git.go
**Language:** go
**Lines:** 73-135
**Complexity:** 16.0

---

## Source Code

```go
func (g *Git) scanStaged(
	ctx context.Context,
	repo *git.Repository,
	out chan<- types.Chunk,
) error {
	wt, err := repo.Worktree()
	if err != nil {
		return fmt.Errorf("worktree: %w", err)
	}

	status, err := wt.Status()
	if err != nil {
		return fmt.Errorf("status: %w", err)
	}

	idx, err := repo.Storer.Index()
	if err != nil {
		return fmt.Errorf("index: %w", err)
	}

	for _, entry := range idx.Entries {
		if ctx.Err() != nil {
			return ctx.Err()
		}

		fileStatus := status.File(entry.Name)
		if fileStatus.Staging == git.Unmodified &&
			fileStatus.Worktree == git.Unmodified {
			continue
		}

		if g.isExcluded(entry.Name) || isBinaryExt(entry.Name) {
			continue
		}

		blob, blobErr := repo.BlobObject(entry.Hash)
		if blobErr != nil {
			continue
		}

		if blob.Size > g.MaxSize {
			continue
		}

		content, readErr := readBlob(blob)
		if readErr != nil {
			continue
		}

		chunks := splitIntoChunks(
			content, entry.Name, "", "", time.Time{},
		)
		for _, chunk := range chunks {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case out <- chunk:
			}
		}
	}

	return nil
}
```

---

## Today I Learned

TIL: The `scanStaged` function uses context cancellation to gracefully stop processing early, preventing unnecessary work. By checking `ctx.Err()` within the loop, it ensures the function exits promptly when the context is cancelled, making the code both efficient and responsive.

```go
if ctx.Err() != nil {
	return ctx.Err()
}
```

This pattern is a Go idiom for handling cancellable operations elegantly.

---

*Generated by CodeWorm on 2026-02-20 07:26*
