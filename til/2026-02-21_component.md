# Component

**Type:** Today I Learned
**Repository:** vuemantics
**File:** frontend/src/routes/upload/index.tsx
**Language:** tsx
**Lines:** 32-251
**Complexity:** 19.0

---

## Source Code

```tsx
function Component(): React.ReactElement {
  const {
    fileQueue,
    addFiles,
    removeFile,
    clearQueue,
    setDragActive,
    dragActive,
    setCurrentBatchId,
  } = useBulkUploadUIStore()

  const { data: clientConfig } = useClientConfig()
  const maxFileSizeBytes = (clientConfig?.max_upload_size_mb ?? 100) * 1024 * 1024

  const createBulkUpload = useCreateBulkUpload()

  const { batchProgress, setBatchProgress, setCurrentFile } =
    useGlobalBatchProgress()
  const { currentFile, handleFileProgress } = useFileProgress()

  useSocket({
    enabled: true,
    onBatchProgress: (data) => {
      setBatchProgress(data.payload.batch_id, {
        status: data.payload.status,
        total: data.payload.total,
        processed: data.payload.processed,
        successful: data.payload.successful,
        failed: data.payload.failed,
        progressPercentage: data.payload.progress_percentage,
      })
    },
    onFileProgress: (data) => {
      handleFileProgress(data)
      // Also update global store for header indicator
      if (data.payload.status === 'processing') {
        setCurrentFile({
          uploadId: data.payload.upload_id,
          fileName: data.payload.file_name,
          fileSize: data.payload.file_size,
          progress: data.payload.progress_percentage,
          status: data.payload.status,
        })
      } else {
        setCurrentFile(null)
      }
    },
  })

  const validateFile = (file: File): { valid: boolean; error?: string } => {
    const maxSizeMB = clientConfig?.max_upload_size_mb ?? 100
    if (file.size > maxFileSizeBytes) {
      return { valid: false, error: `Too large (max ${maxSizeMB}MB)` }
    }

    if (!Object.keys(ACCEPTED_TYPES).includes(file.type)) {
      return { valid: false, error: 'Unsupported file type' }
    }

    return { valid: true }
  }

  const handleDrag = (e: React.DragEvent): void => {
    e.preventDefault()
    e.stopPropagation()
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true)
    } else if (e.type === 'dragleave') {
      setDragActive(false)
    }
  }

  const processFiles = (files: FileList | File[]): void => {
    const fileArray = Array.from(files)
    const newQueuedFiles: QueuedFile[] = []

    // Check for duplicates in existing queue
    const existingNames = new Set(fileQueue.map((f) => f.file.name))

    fileArray.forEach((file) => {
      const validation = validateFile(file)
      const isDuplicate = existingNames.has(file.name)

      const queuedFile: QueuedFile = {
        id: `${Date.now()}-${Math.random()}`,
        file,
        status: isDuplicate
          ? 'duplicate'
          : validation.valid
            ? 'valid'
            : validation.error?.includes('large')
              ? 'too-large'
              : 'unsupported',
        error: isDuplicate ? 'Already in queue' : validation.error,
      }

      // Generate preview for images
      if (file.type.startsWith('image/') && validation.valid) {
       
```

---

## Today I Learned

TIL: In this React component, the `handleDrop` function intelligently processes dropped files by validating them against client config and existing queue entries before adding them to the file queue. This ensures only valid, non-duplicate files are accepted, enhancing user experience and maintaining queue integrity.

```tsx
const handleDrop = (e: React.DragEvent): void => {
  e.preventDefault()
  e.stopPropagation()
  setDragActive(false)

  if (e.dataTransfer.files) {
    processFiles(e.dataTransfer.files)
  }
}
```

This pattern reduces redundancy by centralizing file validation and processing logic, making the component more maintainable.

---

*Generated by CodeWorm on 2026-02-21 23:54*
