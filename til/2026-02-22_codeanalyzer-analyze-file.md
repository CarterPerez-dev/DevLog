# CodeAnalyzer.analyze_file

**Type:** Today I Learned
**Repository:** CodeWorm
**File:** codeworm/analysis/analyzer.py
**Language:** python
**Lines:** 88-168
**Complexity:** 13.0

---

## Source Code

```python
def analyze_file(self,
                     scanned_file: ScannedFile) -> Iterator[AnalysisCandidate]:
        """
        Analyze a single file and yield documentation candidates
        """
        try:
            source = scanned_file.path.read_text(encoding = "utf-8")
        except Exception:
            return

        extractor = CodeExtractor(source, scanned_file.language)
        complexity_results = self.complexity_analyzer.analyze_source(
            source,
            str(scanned_file.path),
        )
        complexity_map = {m.name: m for m in complexity_results}

        git_repo = self._get_git_repo(scanned_file.path.parent)
        if git_repo:
            self.scorer.git_repo = git_repo

        for parsed_func in extractor.extract_functions():
            if self._should_skip_function(parsed_func):
                continue

            complexity = complexity_map.get(parsed_func.name)
            if not complexity:
                for name, metrics in complexity_map.items():
                    if name.endswith(f".{parsed_func.name}"):
                        complexity = metrics
                        break

            git_stats = self.scorer.get_git_stats(
                scanned_file.path,
                parsed_func.start_line,
                parsed_func.end_line,
            )

            if complexity:
                interest = self.scorer.score(
                    complexity,
                    git_stats,
                    parsed_func.decorators,
                    parsed_func.is_async,
                    parsed_func.source,
                )
            else:
                interest = InterestScore(
                    total = 20,
                    complexity_score = 0,
                    length_score = 0,
                    nesting_score = 0,
                    parameter_score = 0,
                    churn_score = 0,
                    novelty_score = 0,
                )

            snippet = CodeSnippet(
                repo = scanned_file.repo_name,
                file_path = scanned_file.path,
                function_name = parsed_func.name,
                class_name = parsed_func.class_name,
                language = scanned_file.language,
                source = parsed_func.source,
                start_line = parsed_func.start_line,
                end_line = parsed_func.end_line,
                complexity = complexity.cyclomatic_complexity
                if complexity else 0,
                nesting_depth = complexity.max_nesting_depth if complexity else 0,
                parameter_count = complexity.parameter_count if complexity else 0,
                interest_score = interest.total,
            )

            yield AnalysisCandidate(
                snippet = snippet,
                parsed_function = parsed_func,
                complexity = complexity,
                git_stats = git_stats,
                interest_score = interest,
                scanned_file = scanned_file,
```

---

## Today I Learned

TIL: In `CodeAnalyzer.analyze_file`, the use of `try-except` with a simple return statement elegantly handles file reading errors, avoiding complex error management while ensuring the function can gracefully skip problematic files.

```python
try:
    source = scanned_file.path.read_text(encoding="utf-8")
except Exception:
    return
```

This pattern keeps the code clean and focused on its primary task.

---

*Generated by CodeWorm on 2026-02-22 11:48*
