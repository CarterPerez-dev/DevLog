# SSEHandler.do_GET

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/haskell-reverse-proxy/examples/websockets/sse_server.py
**Language:** python
**Lines:** 13-103
**Complexity:** 8.0

---

## Source Code

```python
def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            self.wfile.write(json.dumps({"status": "healthy"}).encode())
            return

        if self.path == "/events":
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.send_header("X-Accel-Buffering", "no")
            self.end_headers()

            print(f"[SSE] Client connected: {self.client_address}")

            try:
                event_id = 0
                while True:
                    event_id += 1
                    data = {
                        "id": event_id,
                        "timestamp": datetime.now().isoformat(),
                        "message": f"Event #{event_id}"
                    }

                    event = f"id: {event_id}\nevent: tick\ndata: {json.dumps(data)}\n\n"
                    self.wfile.write(event.encode())
                    self.wfile.flush()

                    print(f"[SSE] Sent event #{event_id}")
                    time.sleep(1)

            except (BrokenPipeError, ConnectionResetError):
                print(f"[SSE] Client {self.client_address} disconnected")
            return

        if self.path == "/stream/fast":
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.end_headers()

            print(f"[SSE-FAST] Client connected: {self.client_address}")

            try:
                for i in range(100):
                    data = {"seq": i, "ts": datetime.now().isoformat()}
                    event = f"data: {json.dumps(data)}\n\n"
                    self.wfile.write(event.encode())
                    self.wfile.flush()
                    time.sleep(0.05)

                self.wfile.write(b"event: done\ndata: complete\n\n")
                self.wfile.flush()
                print(f"[SSE-FAST] Stream complete")

            except (BrokenPipeError, ConnectionResetError):
                print(f"[SSE-FAST] Client disconnected early")
            return

        self.send_response(200)
        self.send_header("Content-Type", "text/html")
        self.end_headers()
        html = """<!DOCTYPE html>
<html>
<head><title>SSE Test</title></head>
<body>
<h1>SSE Test Endpoints</h1>
<ul>
  <li><a href="/events">/events</a> - Continuous 1-second ticks</li>
  <li><a href="/stream/fast">/stream/fast</a> - Fast burst (100 events)</li>
  <li><a href="/health">/health</a> - Health check</li>
</ul>
<h2>Live Events:</h2>
<pre id="output"></pre>
<script>
const es = new EventSource('/events');
es.onmessage = (e) => {
  document.getElementById
```

---

## Today I Learned

TIL: In the `do_GET` method, the use of context management and exception handling for Server-Sent Events (SSE) is clever. By catching `BrokenPipeError` and `ConnectionResetError`, it ensures graceful disconnection handling, making the SSE stream robust and user-friendly.

```python
try:
    # Event loop logic here
except (BrokenPipeError, ConnectionResetError):
    print(f"[SSE] Client {self.client_address} disconnected")
```

This pattern prevents abrupt termination and logs disconnections neatly.

---

*Generated by CodeWorm on 2026-03-01 22:12*
