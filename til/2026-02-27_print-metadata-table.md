# print_metadata_table

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/metadata-scrubber-tool/src/utils/display.py
**Language:** python
**Lines:** 21-114
**Complexity:** 11.0

---

## Source Code

```python
def print_metadata_table(metadata: dict[str, Any]):
    """
    Display metadata in a formatted table organized by logical groups.

    Organizes metadata into categories (Device Info, Exposure Settings,
    Image Data, Dates) and displays them in a Rich panel with color coding.

    Args:
        metadata: Dict of metadata key-value pairs to display.
    """

    # Define the groups using simple lists of keys
    groups = {
        "üìÑ Document Info": [
            "Author",
            "author",
            "/Author",
            "/Creator",
        ],
        "üì∏ Device Info": ["Make",
                          "Model",
                          "Software",
                          "ExifVersion"],
        "‚öôÔ∏è Exposure Settings": [
            "ExposureTime",
            "FNumber",
            "ISOSpeedRatings",
            "ShutterSpeedValue",
            "ApertureValue",
            "Flash",
            "FocalLength",
        ],
        "üñºÔ∏è Image Data": [
            "ImageWidth",
            "ImageLength",
            "PixelXDimension",
            "PixelYDimension",
            "Orientation",
            "ResolutionUnit",
        ],
        "üìÖ Dates": [
            "DateTime",
            "DateTimeOriginal",
            "DateTimeDigitized",
            "OffsetTime",
            "created",
            "modified",
            "/CreationDate",
            "/ModDate",
        ],
    }

    # Create the main table
    table = Table(box = box.ROUNDED, show_header = True, header_style = "bold magenta")
    table.add_column("Property", style = "cyan")
    table.add_column("Value", style = "green")

    # Track which keys we have displayed to handle the "leftovers"
    displayed_keys = set()

    # Loop through the defined groups to create sections
    for section_name, keys in groups.items():
        # Check if we have any data for this section
        section_data = {k: metadata[k] for k in keys if k in metadata}

        if section_data:
            # Add a section row (acts as a sub-header)
            table.add_row(Text(section_name, style = "bold yellow"), "")

            for key, val in section_data.items():
                table.add_row(f"  {key}", clean_value(val))
                displayed_keys.add(key)

            # Add a blank row for spacing
            table.add_section()

    # Handle "Other" (Any keys that isn't in the groups)
    leftovers = {
        k: v
        for k, v in metadata.items()
        if k not in displayed_keys and k != "JPEGInterchangeFormat"
    }  # skip binary blobs
    if leftovers:
        table.add_row(Text("üìù Other", style = "bold yellow"), "")
        for key, val in leftovers.items():
            table.add_row(f"  {key}", clean_value(val))

    # Print nicely inside a panel
    console.print(
        Panel(table,
              title = "Metadata Report",
              border_style = "blue",
              expand = False)
    )
```

---

## Today I Learned

TIL: In `print_metadata_table`, the code uses a dictionary of lists to categorize metadata keys, making it easy to organize and display related information in sections. This approach keeps the logic clean and reusable for different sets of metadata.

```python
groups = {
    "üìÑ Document Info": ["Author", "author", "/Author", "/Creator"],
    # ... other groups
}
```

By defining categories this way, the function dynamically organizes data into logical sections, enhancing readability and maintainability.

---

*Generated by CodeWorm on 2026-02-27 17:14*
