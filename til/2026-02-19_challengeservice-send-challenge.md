# ChallengeService.send_challenge

**Type:** Today I Learned
**Repository:** CertGames-Core
**File:** backend/api/domains/social/services/challenge_ops.py
**Language:** python
**Lines:** 30-141
**Complexity:** 9.0

---

## Source Code

```python
def send_challenge(
        challenger_id: str | ObjectId,
        challenged_id: str | ObjectId,
        test_category: str,
        test_id: int | None,
        question_count: int,
        mode: str
    ) -> Challenge:
        """
        Create a new challenge
        If test_id is None, randomly select a test from the category
        Validates test exists in database before creating challenge
        """
        challenger_id = ObjectId(challenger_id) if isinstance(
            challenger_id,
            str
        ) else challenger_id
        challenged_id = ObjectId(challenged_id) if isinstance(
            challenged_id,
            str
        ) else challenged_id

        if test_id is None:
            available_tests = list(
                Test.objects(category = test_category).only('testId')
            )

            if not available_tests:
                raise NotFoundError(
                    "Test",
                    f"No tests found for category '{test_category}'"
                )

            random_test = random.choice(available_tests)
            test_id = random_test.testId
        else:
            test = Test.objects(
                testId = test_id,
                category = test_category
            ).first()

            if not test:
                raise NotFoundError(
                    "Test",
                    f"Test {test_id} not found in category '{test_category}'"
                )

        existing_challenge = Challenge.objects(
            testCategory = test_category,
            testId = test_id,
            status__in = [
                ChallengeStatus.PENDING.value,
                ChallengeStatus.ACCEPTED.value,
                ChallengeStatus.IN_PROGRESS.value
            ]
        ).filter(
            __raw__ = {
                "$or": [
                    {
                        "challengerUserId": challenger_id,
                        "challengedUserId": challenged_id
                    },
                    {
                        "challengerUserId": challenged_id,
                        "challengedUserId": challenger_id
                    }
                ]
            }
        ).first()

        if existing_challenge:
            raise BusinessRuleError(
                f"You already have an active challenge for {test_category} Test #{test_id} with this user. Complete or cancel it first.",
                error_code = "DUPLICATE_CHALLENGE"
            )

        challenge = Challenge(
            challengerUserId = challenger_id,
            challengedUserId = challenged_id,
            testCategory = test_category,
            testId = test_id,
            questionCount = question_count,
            mode = mode,
            status = ChallengeStatus.PENDING.value,
            createdAt = datetime.now(UTC)
        )
        challenge.save()

        challenger = User.objects(
            id = challenger_id
        ).only("username",
               "level",
               "c
```

---

## Today I Learned

TIL: I learned about using `__raw__` filter in PyMongo to craft complex query conditions elegantly. In `send_challenge`, it allows combining multiple criteria for checking existing challenges, making the logic clear and concise.

```python
existing_challenge = Challenge.objects(
    testCategory=test_category,
    testId=test_id,
    status__in=[
        ChallengeStatus.PENDING.value,
        ChallengeStatus.ACCEPTED.value,
        ChallengeStatus.IN_PROGRESS.value
    ]
).filter(
    __raw__={
        "$or": [
            {"challengerUserId": challenger_id, "challengedUserId": challenged_id},
            {"challengerUserId": challenged_id, "challengedUserId": challenger_id}
        ]
    }
).first()
```

This pattern simplifies handling complex query conditions in MongoDB queries.

---

*Generated by CodeWorm on 2026-02-19 18:07*
