# CircuitBreaker.call

**Type:** Today I Learned
**Repository:** kill-pr0cess.inc
**File:** backend/src/utils/mod.rs
**Language:** rust
**Lines:** 351-420
**Complexity:** 10.0

---

## Source Code

```rust
pub fn call<F, T, E>(&self, operation: F) -> std::result::Result<T, E>
    where
        F: FnOnce() -> std::result::Result<T, E>,
        E: From<AppError>,
    {
        let can_proceed = {
            let mut current_state_guard = self.state.lock().unwrap(); // Lock to read and potentially modify
            match *current_state_guard {
                CircuitState::Closed => true,
                CircuitState::HalfOpen => true, // Allow one attempt in HalfOpen
                CircuitState::Open => {
                    let last_failure_time_guard = self.last_failure_time.lock().unwrap();
                    if let Some(last_failure) = *last_failure_time_guard {
                        if Instant::now().duration_since(last_failure) > self.timeout {
                            info!("CircuitBreaker: Timeout elapsed, transitioning from Open to HalfOpen.");
                            *current_state_guard = CircuitState::HalfOpen;
                            true // Allow this call as the first attempt in HalfOpen
                        } else {
                            // Still in Open state, timeout not elapsed
                            false
                        }
                    } else {
                        // Should not happen if last_failure_time is always set on failure
                        // but if it does, stay open.
                        warn!("CircuitBreaker: In Open state but no last_failure_time recorded.");
                        false
                    }
                }
            }
        };

        if !can_proceed {
            return Err(AppError::ServiceUnavailableError(
                "Circuit breaker is OPEN".to_string(),
            )
            .into());
        }

        match operation() {
            Ok(result) => {
                let mut current_state_guard = self.state.lock().unwrap();
                if *current_state_guard == CircuitState::HalfOpen {
                    info!("CircuitBreaker: Successful call in HalfOpen state, transitioning to Closed.");
                }
                *current_state_guard = CircuitState::Closed;
                *self.failure_count.lock().unwrap() = 0;
                *self.last_failure_time.lock().unwrap() = None; // Clear last failure time
                Ok(result)
            }
            Err(error) => {
                let mut failure_count_guard = self.failure_count.lock().unwrap();
                let mut current_state_guard = self.state.lock().unwrap();
                let mut last_failure_time_guard = self.last_failure_time.lock().unwrap();

                *failure_count_guard += 1;
                *last_failure_time_guard = Some(Instant::now());

                if *current_state_guard == CircuitState::HalfOpen {
                    // Failure in HalfOpen state, trip back to Open
                    info!("CircuitBreaker: Failure in HalfOpen state, transitioning back to Open.");
                    *current_state_guard = CircuitState::
```

---

## Today I Learned

TIL: The `call` function in the CircuitBreaker uses Rust's `Result` and `Option` types to handle error propagation and state transitions elegantly. By wrapping operations in `FnOnce`, it ensures safe execution within a controlled context, leveraging Rustâ€™s strong type system to manage circuit states and failures.

This pattern makes the code robust and easy to reason about, ensuring that only valid operations proceed when the circuit is closed or half-open.

---

*Generated by CodeWorm on 2026-02-21 09:59*
