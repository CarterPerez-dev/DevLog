# AuthService.complete_authentication

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/backend/app/services/auth_service.py
**Language:** python
**Lines:** 488-598
**Complexity:** 11.0

---

## Source Code

```python
async def complete_authentication(
        self,
        session: AsyncSession,
        request: AuthenticationCompleteRequest,
    ) -> UserResponse:
        """
        Complete WebAuthn passkey authentication
        """
        credential_id = request.credential.get("id")
        if not credential_id:
            raise InvalidDataError("Missing credential ID")

        credential = await self.get_credential_by_id(
            session = session,
            credential_id = credential_id,
        )

        if not credential:
            logger.warning(
                "Authentication with unknown credential: %s...",
                credential_id[: 16]
            )
            raise CredentialNotFoundError("Credential not found")

        user = await self.get_user_by_id(
            session = session,
            user_id = credential.user_id,
        )

        if not user:
            logger.error(
                "User not found for credential: %s...",
                credential_id[: 16]
            )
            raise UserNotFoundError("User not found")

        if not user.is_active:
            logger.warning(
                "Authentication attempt for inactive user: %s",
                user.username
            )
            raise UserInactiveError("User account is inactive")

        expected_challenge = await redis_manager.get_authentication_challenge(
            user_id = user.username
        )

        if not expected_challenge:
            logger.warning(
                "Authentication challenge not found for user: %s",
                user.username
            )
            raise ChallengeExpiredError(
                "Challenge expired or not found - please restart authentication"
            )

        try:
            verified = passkey_manager.verify_authentication(
                credential = request.credential,
                expected_challenge = expected_challenge,
                credential_public_key = base64url_to_bytes(credential.public_key),
                credential_current_sign_count = credential.sign_count,
            )
        except ValueError as e:
            logger.error("Authentication verification failed: %s", e)
            raise CredentialVerificationError(str(e)) from e
        except Exception as e:
            logger.error("Unexpected error during authentication: %s", e)
            raise CredentialVerificationError(
                "Authentication verification failed"
            ) from e

        await self.update_credential_counter(
            session = session,
            credential_id = credential.credential_id,
            new_count = verified.new_sign_count,
        )

        if (credential.backup_state != verified.backup_state
                or credential.backup_eligible != verified.backup_eligible):
            await self.update_backup_state(
                session = session,
                credential_id = credential.credential_id,
                backup_state = verified.backup_st
```

---

## Today I Learned

TIL: In `complete_authentication`, the function handles authentication errors with detailed logging and specific exceptions. This makes debugging easier by providing clear error messages and context, such as logging the credential ID for unknown credentials or user activity status. Clever use of structured exception handling ensures robust error management!

---

*Generated by CodeWorm on 2026-02-18 22:26*
