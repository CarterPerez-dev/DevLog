# FetchVersions

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/simple-vulnerability-scanner/internal/pypi/client.go
**Language:** go
**Lines:** 76-137
**Complexity:** 12.0

---

## Source Code

```go
func (c *Client) FetchVersions(
	ctx context.Context,
	name string,
) ([]string, error) {
	normalized := NormalizeName(name)

	entry, hit := c.cache.Get(normalized)
	if hit && c.cache.IsFresh(entry) {
		return entry.Versions, nil
	}

	url := simpleAPIBase + normalized + "/"
	req, err := http.NewRequestWithContext(
		ctx, http.MethodGet, url, nil,
	)
	if err != nil {
		return nil, fmt.Errorf("build request for %s: %w", name, err)
	}
	req.Header.Set("Accept", simpleAPIAccept)
	req.Header.Set("User-Agent", c.userAgent)

	if entry != nil && entry.ETag != "" {
		req.Header.Set("If-None-Match", entry.ETag)
	}

	resp, err := c.doWithRetry(ctx, req)
	if err != nil {
		if entry != nil {
			return entry.Versions, nil
		}
		return nil, fmt.Errorf("fetch %s: %w", name, err)
	}
	defer func() { _ = resp.Body.Close() }() //nolint:errcheck

	switch resp.StatusCode {
	case http.StatusNotModified:
		c.cache.Touch(normalized)
		return entry.Versions, nil

	case http.StatusNotFound:
		return nil, fmt.Errorf(
			"package %q not found on PyPI", name,
		)

	case http.StatusOK:
		var result simpleAPIResponse
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, fmt.Errorf("decode %s: %w", name, err)
		}
		_ = c.cache.Set(normalized, &CacheEntry{ //nolint:errcheck
			ETag:     resp.Header.Get("ETag"),
			Versions: result.Versions,
			CachedAt: time.Now(),
		})
		return result.Versions, nil

	default:
		return nil, fmt.Errorf(
			"PyPI returned %d for %s", resp.StatusCode, name,
		)
	}
}
```

---

## Today I Learned

TIL: In `FetchVersions`, the use of `http.NewRequestWithContext` with error handling is clever. It ensures that context propagation and request creation are done atomically, making the function more robust and easier to reason about.

```go
req, err := http.NewRequestWithContext(
	ctx, http.MethodGet, url, nil,
)
if err != nil {
	return nil, fmt.Errorf("build request for %s: %w", name, err)
}
```

This pattern prevents context loss and ensures errors are properly propagated.

---

*Generated by CodeWorm on 2026-02-19 10:45*
