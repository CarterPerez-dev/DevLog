# initConfig

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/cli/root.go
**Language:** go
**Lines:** 90-129
**Complexity:** 17.0

---

## Source Code

```go
func initConfig() {
	if noColor {
		color.NoColor = true
	}

	loaded, err := config.Load(cfgFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s config error: %s\n",
			ui.Warning, err)
	}
	if loaded != nil {
		cfg = loaded
	} else {
		cfg = &config.Config{}
	}

	if format == "" && cfg.Output.Format != "" {
		format = cfg.Output.Format
	}
	if format == "" {
		format = "terminal"
	}

	if !verbose && cfg.Output.Verbose {
		verbose = true
	}
	if !noColor && cfg.Output.NoColor {
		noColor = true
		color.NoColor = true
	}
	if !enableHIBP && cfg.HIBP.Enabled {
		enableHIBP = true
	}
	if maxSize == 0 && cfg.Scan.MaxFileSize > 0 {
		maxSize = cfg.Scan.MaxFileSize
	}
	if len(excludes) == 0 && len(cfg.Scan.Excludes) > 0 {
		excludes = cfg.Scan.Excludes
	}
}
```

---

## Today I Learned

TIL: In `initConfig`, the function cleverly updates global variables based on both user inputs and loaded configuration files. This ensures that settings are dynamically adjusted, prioritizing command-line flags but falling back to default values if necessary. It's a neat way to handle configurable behavior in Go applications!

---

*Generated by CodeWorm on 2026-02-20 08:55*
