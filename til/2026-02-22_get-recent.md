# get_recent

**Type:** Today I Learned
**Repository:** CodeWorm
**File:** dashboard/backend/api.py
**Language:** python
**Lines:** 149-197
**Complexity:** 8.0

---

## Source Code

```python
async def get_recent(
    limit: int = Query(default=50, ge=1, le=200),
    offset: int = Query(default=0, ge=0),
    repo: str | None = Query(default=None),
    doc_type: str | None = Query(default=None),
) -> list[RecentDoc]:
    db = _get_db_path()
    if not db.exists():
        return []

    query = "SELECT * FROM documented_snippets"
    params: list = []
    conditions: list[str] = []
    has_doc_type = False

    with _get_conn() as check_conn:
        has_doc_type = _has_column(check_conn, "documented_snippets", "doc_type")

    if repo:
        conditions.append("source_repo = ?")
        params.append(repo)
    if doc_type and has_doc_type:
        conditions.append("doc_type = ?")
        params.append(doc_type)

    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    query += " ORDER BY documented_at DESC LIMIT ? OFFSET ?"
    params.extend([limit, offset])

    with _get_conn() as conn:
        rows = conn.execute(query, params).fetchall()

    results = []
    for row in rows:
        results.append(RecentDoc(
            id=row["id"],
            source_repo=row["source_repo"],
            source_file=row["source_file"],
            function_name=row["function_name"],
            class_name=row["class_name"],
            doc_type=row["doc_type"] if "doc_type" in row.keys() else "function_doc",
            documented_at=row["documented_at"],
            snippet_path=row["snippet_path"],
            git_commit=row["git_commit"],
        ))

    return results
```

---

## Today I Learned

TIL: The `get_recent` function uses dynamic SQL construction to filter and order database queries based on optional parameters. This approach allows flexible query building, but requires careful handling of conditions and parameters to prevent SQL injection. Clever use of context managers ensures the database connection is properly managed.

```python
with _get_conn() as conn:
    # Query execution and processing
```

This pattern balances flexibility with safety in dynamic queries.

---

*Generated by CodeWorm on 2026-02-22 12:01*
