# capture

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/network-traffic-analyzer/src/netanal/main.py
**Language:** python
**Lines:** 111-212
**Complexity:** 7.0

---

## Source Code

```python
def capture(
    interface: Annotated[
        str | None,
        typer.Option(
            "--interface",
            "-i",
            help="Network interface to capture on",
        ),
    ] = None,
    filter_expr: Annotated[
        str | None,
        typer.Option(
            "--filter",
            "-f",
            help="BPF filter expression",
        ),
    ] = None,
    count: Annotated[
        int | None,
        typer.Option(
            "--count",
            "-c",
            help="Number of packets to capture",
        ),
    ] = None,
    timeout: Annotated[
        float | None,
        typer.Option(
            "--timeout",
            "-t",
            help="Capture timeout in seconds",
        ),
    ] = None,
    output: Annotated[
        Path | None,
        typer.Option(
            "--output",
            "-o",
            help="Output file for results (JSON)",
        ),
    ] = None,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            help="Show individual packets",
        ),
    ] = False,
) -> None:
    """
    [bold green]Capture[/bold green] live network packets

    Examples:
        netanal capture -i eth0 --count 100
        netanal capture --filter "tcp port 80" --timeout 30
        netanal capture -i lo -c 50 --verbose
    """
    can_capture, msg = check_capture_permissions()
    if not can_capture:
        print_error(f"Cannot capture packets: {msg}")
        raise typer.Exit(1)

    if filter_expr and not validate_bpf_filter(filter_expr):
        print_error(f"Invalid BPF filter: {filter_expr}")
        raise typer.Exit(1)

    config = CaptureConfig(
        interface=interface,
        bpf_filter=filter_expr,
        packet_count=count,
        timeout_seconds=timeout,
    )

    packets_captured: list[PacketInfo] = []

    def on_packet(packet: PacketInfo) -> None:
        if verbose:
            print_packet(packet)
        if output:
            packets_captured.append(packet)

    console.print(
        f"[cyan]Starting capture on {interface or 'all interfaces'}...[/cyan]"
    )
    console.print("[dim]Press Ctrl+C to stop[/dim]\n")

    engine = CaptureEngine(
        config=config,
        on_packet=on_packet if verbose or output else None
    )

    with GracefulCapture(engine) as cap:
        stats = cap.wait()

    console.print()
    print_capture_summary(stats)
    print_protocol_table(stats)
    print_top_talkers(stats)

    if output:
        export_to_json(stats, output, packets_captured)
        print_success(f"Results saved to {output}")
```

---

## Today I Learned

TIL: I learned about using `Annotated` for type hints and options in Typer commands. This makes the function signature clear while providing helpful metadata like option names and descriptions, enhancing readability and maintainability.

```python
def capture(
    interface: Annotated[
        str | None,
        typer.Option(...),
    ] = None,
    ...
)
```

This pattern simplifies command-line argument handling in Python.

---

*Generated by CodeWorm on 2026-02-18 21:34*
