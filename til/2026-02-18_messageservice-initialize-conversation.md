# MessageService.initialize_conversation

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/backend/app/services/message_service.py
**Language:** python
**Lines:** 48-166
**Complexity:** 10.0

---

## Source Code

```python
async def initialize_conversation(
        self,
        session: AsyncSession,
        sender_id: UUID,
        recipient_id: UUID
    ) -> RatchetState:
        """
        Performs X3DH key exchange and initializes Double Ratchet for new conversation
        """
        if sender_id == recipient_id:
            raise InvalidDataError("Cannot start conversation with yourself")

        existing_state_statement = select(RatchetState).where(
            RatchetState.user_id == sender_id,
            RatchetState.peer_user_id == recipient_id
        )
        existing_state_result = await session.execute(existing_state_statement)
        existing_state = existing_state_result.scalar_one_or_none()

        if existing_state:
            logger.warning(
                "Ratchet state already exists for %s -> %s",
                sender_id,
                recipient_id
            )
            return existing_state

        sender_ik_statement = select(IdentityKey).where(
            IdentityKey.user_id == sender_id
        )
        sender_ik_result = await session.execute(sender_ik_statement)
        sender_ik = sender_ik_result.scalar_one_or_none()

        if not sender_ik:
            logger.error("Sender identity key not found: %s", sender_id)
            raise InvalidDataError(
                "Sender has no identity key - initialize encryption first"
            )

        recipient_bundle = await prekey_service.get_prekey_bundle(
            session,
            recipient_id
        )

        recipient_ik_statement = select(IdentityKey).where(
            IdentityKey.user_id == recipient_id
        )
        recipient_ik_result = await session.execute(recipient_ik_statement)
        recipient_ik = recipient_ik_result.scalar_one_or_none()

        if not recipient_ik:
            logger.error("Recipient identity key not found: %s", recipient_id)
            raise InvalidDataError("Recipient has no identity key")

        try:
            x3dh_result = x3dh_manager.perform_x3dh_sender(
                alice_identity_private_x25519 = sender_ik.private_key,
                bob_bundle = recipient_bundle,
                bob_identity_public_ed25519 = recipient_ik.public_key_ed25519
            )
        except Exception as e:
            logger.error("X3DH key exchange failed: %s", e)
            raise KeyExchangeError(f"Key exchange failed: {str(e)}") from e

        recipient_spk_public_bytes = base64url_to_bytes(
            recipient_bundle.signed_prekey
        )

        dr_state = double_ratchet.initialize_sender(
            shared_key = x3dh_result.shared_key,
            peer_public_key = recipient_spk_public_bytes
        )

        dh_private_bytes = dr_state.dh_private_key.private_bytes(
            encoding = serialization.Encoding.Raw,
            format = serialization.PrivateFormat.Raw,
            encryption_algorithm = serialization.NoEncryption()
        ) if dr_state.dh_private_key else b''

        dh_public_bytes = dr_stat
```

---

## Today I Learned

TIL: In `initialize_conversation`, the code uses context managers and exception handling to ensure robust database operations. The `try-except` block around `session.commit()` ensures that any errors during commit are caught, rolled back, and logged, maintaining data integrity and providing clear error messages.

```python
try:
    await session.commit()
    await session.refresh(ratchet_state)
except IntegrityError as e:
    await session.rollback()
    logger.error("Database error saving ratchet state: %s", e)
```

This pattern prevents partial writes and ensures the database remains consistent.

---

*Generated by CodeWorm on 2026-02-18 20:55*
