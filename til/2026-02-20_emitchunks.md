# emitChunks

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/source/directory.go
**Language:** go
**Lines:** 89-150
**Complexity:** 11.0

---

## Source Code

```go
func (d *Directory) emitChunks(
	ctx context.Context,
	absPath, relPath string,
	out chan<- types.Chunk,
) error {
	f, err := os.Open(absPath)
	if err != nil {
		return nil
	}
	defer f.Close()

	var buf strings.Builder
	scanner := bufio.NewScanner(f)
	scanner.Buffer(make([]byte, 0, 512*1024), 512*1024)

	lineNum := 0
	chunkStart := 1
	linesInChunk := 0

	for scanner.Scan() {
		if ctx.Err() != nil {
			return ctx.Err()
		}

		lineNum++
		linesInChunk++

		if buf.Len() > 0 {
			buf.WriteByte('\n')
		}
		buf.WriteString(scanner.Text())

		if linesInChunk >= 50 {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case out <- types.Chunk{
				Content:   buf.String(),
				FilePath:  relPath,
				LineStart: chunkStart,
			}:
			}
			buf.Reset()
			chunkStart = lineNum + 1
			linesInChunk = 0
		}
	}

	if buf.Len() > 0 {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case out <- types.Chunk{
			Content:   buf.String(),
			FilePath:  relPath,
			LineStart: chunkStart,
		}:
		}
	}

	return nil
}
```

---

## Today I Learned

TIL: The `emitChunks` function uses a buffered scanner to read large files line by line, ensuring efficient memory usage. By limiting chunks to 50 lines and using a select statement within the loop, it handles context cancellation gracefully, allowing partial data to be sent or discarded if the operation is cancelled early.

This pattern combines resource management with concurrent safe chunking, making it both performant and responsive.

---

*Generated by CodeWorm on 2026-02-20 07:35*
