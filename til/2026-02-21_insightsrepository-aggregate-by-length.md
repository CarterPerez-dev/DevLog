# InsightsRepository.aggregate_by_length_range

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/analytics/facets/insights/repository.py
**Language:** python
**Lines:** 303-347
**Complexity:** 6.0

---

## Source Code

```python
async def aggregate_by_length_range(
        cls, session: AsyncSession
    ) -> dict[str, dict]:
        """Aggregate performance by video length ranges"""
        videos = await cls.get_all_videos(session)

        range_stats = defaultdict(lambda: {
            "videos": [],
            "total_views": 0,
            "total_engagement": 0,
            "total_watch_percentage": 0,
        })

        for video in videos:
            seconds = cls.convert_length_to_seconds(video.length)
            range_label = cls.get_length_range_label(seconds)
            engagement_rate = cls.calculate_engagement_rate(video)

            range_stats[range_label]["videos"].append(video)
            range_stats[range_label]["total_views"] += video.views
            range_stats[range_label]["total_engagement"] += engagement_rate
            range_stats[range_label]["total_watch_percentage"] += video.watched_full_video_percentage

        # Calculate averages and add min/max seconds
        result = {}
        for range_label, stats in range_stats.items():
            count = len(stats["videos"])
            # Extract min/max from range label (e.g., "1:00-1:30" -> 60, 90)
            if range_label == "3:00+":
                min_sec, max_sec = 180, 999
            else:
                parts = range_label.split("-")
                min_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[0].split(":"))))
                max_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[1].split(":"))))

            result[range_label] = {
                "min_seconds": min_sec,
                "max_seconds": max_sec,
                "video_count": count,
                "avg_views": stats["total_views"] / count,
                "avg_engagement_rate": stats["total_engagement"] / count,
                "avg_watch_percentage": stats["total_watch_percentage"] / count,
            }

        return result
```

---

## Today I Learned

TIL: I learned how to use `defaultdict` with a lambda function to initialize nested dictionaries efficiently in Python. This snippet from `InsightsRepository.aggregate_by_length_range` uses `defaultdict(lambda: { ... })` to automatically create sub-dictionaries for each video length range, making the aggregation process cleaner and more concise.

```python
range_stats = defaultdict(lambda: {
    "videos": [],
    "total_views": 0,
    "total_engagement": 0,
    "total_watch_percentage": 0,
})
```

This pattern simplifies managing nested dictionary updates and ensures all keys are initialized correctly.

---

*Generated by CodeWorm on 2026-02-21 02:06*
