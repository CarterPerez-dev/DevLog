# parseComposeFile

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/scanner/finder.go
**Language:** go
**Lines:** 140-235
**Complexity:** 14.0

---

## Source Code

```go
func (s *Scanner) parseComposeFile(
	ctx context.Context,
	path string,
) (*model.Project, error) {
	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	checksum, err := fileChecksum(path)
	if err != nil {
		return nil, err
	}

	s.mu.RLock()
	cached, exists := s.cache[path]
	s.mu.RUnlock()

	if exists && cached.ModTime.Equal(info.ModTime()) &&
		cached.CheckSum == checksum {
		return cached.Project, nil
	}

	projectName := deriveProjectName(path)

	oldStderr := os.Stderr
	devNull, devNullErr := os.OpenFile(os.DevNull, os.O_WRONLY, 0)
	if devNullErr == nil {
		os.Stderr = devNull
	}

	opts, err := cli.NewProjectOptions(
		[]string{path},
		cli.WithName(projectName),
		cli.WithResolvedPaths(true),
		cli.WithInterpolation(true),
		cli.WithProfiles([]string{}),
	)

	os.Stderr = oldStderr
	if devNull != nil {
		devNull.Close()
	}

	if err != nil {
		return nil, err
	}

	os.Stderr = devNull
	if devNullErr == nil {
		devNull, _ = os.OpenFile(os.DevNull, os.O_WRONLY, 0)
	}

	composeProject, err := opts.LoadProject(ctx)

	os.Stderr = oldStderr
	if devNull != nil {
		devNull.Close()
	}
	if err != nil {
		return nil, err
	}

	if len(composeProject.Services) == 0 {
		return nil, nil
	}

	services := make([]string, 0, len(composeProject.Services))
	for _, svc := range composeProject.Services {
		services = append(services, svc.Name)
	}

	proj := &model.Project{
		ID:              generateProjectID(path),
		Name:            projectName,
		Path:            filepath.Dir(path),
		ComposeFile:     filepath.Base(path),
		ComposeFilePath: path,
		Environment:     detectEnvironment(path),
		Status:          model.StatusUnknown,
		Services:        services,
		Containers:      make([]model.Container, 0),
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	s.mu.Lock()
	s.cache[path] = &CachedProject{
		Project:  proj,
		ModTime:  info.ModTime(),
		CheckSum: checksum,
	}
	s.mu.Unlock()

	return proj, nil
}
```

---

## Today I Learned

TIL: In `parseComposeFile`, the function temporarily redirects stderr to `/dev/null` during project loading to suppress potential CLI output, then restores it afterward. This clever use of context management ensures that any noisy stdout is silenced without affecting other parts of the program.

```go
oldStderr := os.Stderr
devNull, devNullErr := os.OpenFile(os.DevNull, os.O_WRONLY, 0)
if devNullErr == nil {
	os.Stderr = devNull
}
// ...
os.Stderr = oldStderr
if devNull != nil {
	devNull.Close()
}
```

This pattern is useful for controlling output in sensitive parts of code without disrupting the rest.

---

*Generated by CodeWorm on 2026-02-20 17:06*
