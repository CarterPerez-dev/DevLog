# AnalyzeSlowQueries

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/metrics/service.go
**Language:** go
**Lines:** 307-407
**Complexity:** 15.0

---

## Source Code

```go
func (s *Service) AnalyzeSlowQueries(ctx context.Context, minMillis, limit int) (*SlowQueryAnalysis, error) {
	queries, err := s.repo.GetSlowQueries(ctx, s.database, minMillis, limit)
	if err != nil {
		return nil, fmt.Errorf("get slow queries: %w", err)
	}

	collectionMap := make(map[string]*collectionAggregator)
	operationMap := make(map[string]*operationAggregator)
	suggestionMap := make(map[string]*IndexSuggestion)

	for _, q := range queries {
		if agg, ok := collectionMap[q.Namespace]; ok {
			agg.count++
			agg.totalMillis += q.MillisRuntime
			if q.MillisRuntime > agg.maxMillis {
				agg.maxMillis = q.MillisRuntime
			}
		} else {
			collectionMap[q.Namespace] = &collectionAggregator{
				namespace:   q.Namespace,
				count:       1,
				totalMillis: q.MillisRuntime,
				maxMillis:   q.MillisRuntime,
			}
		}

		if agg, ok := operationMap[q.Op]; ok {
			agg.count++
			agg.totalMillis += q.MillisRuntime
		} else {
			operationMap[q.Op] = &operationAggregator{
				operation:   q.Op,
				count:       1,
				totalMillis: q.MillisRuntime,
			}
		}

		if q.PlanSummary == "COLLSCAN" && q.DocsExamined > 100 {
			key := q.Namespace + ":COLLSCAN"
			if sug, ok := suggestionMap[key]; ok {
				sug.Occurrences++
			} else {
				suggestionMap[key] = &IndexSuggestion{
					Collection:     q.Namespace,
					SuggestedIndex: []string{"_id"},
					Reason:         "Collection scan detected with high document examination",
					QueryPattern:   "COLLSCAN",
					Occurrences:    1,
				}
			}
		}

		if q.KeysExamined > 0 && q.DocsExamined > q.KeysExamined*10 {
			key := q.Namespace + ":INEFFICIENT_INDEX"
			if sug, ok := suggestionMap[key]; ok {
				sug.Occurrences++
			} else {
				suggestionMap[key] = &IndexSuggestion{
					Collection:     q.Namespace,
					SuggestedIndex: []string{"examine query filter fields"},
					Reason:         fmt.Sprintf("Inefficient index usage: %d docs examined vs %d keys", q.DocsExamined, q.KeysExamined),
					QueryPattern:   q.PlanSummary,
					Occurrences:    1,
				}
			}
		}
	}

	var topCollections []CollectionStats
	for _, agg := range collectionMap {
		topCollections = append(topCollections, CollectionStats{
			Namespace: agg.namespace,
			Count:     agg.count,
			AvgMillis: float64(agg.totalMillis) / float64(agg.count),
			MaxMillis: agg.maxMillis,
		})
	}

	var topOperations []OperationStats
	for _, agg := range operationMap {
		topOperations = append(topOperations, OperationStats{
			Operation: agg.operation,
			Count:     agg.count,
			AvgMillis: float64(agg.totalMillis) / float64(agg.count),
		})
	}

	var suggestions []IndexSuggestion
	for _, sug := range suggestionMap {
		suggestions = append(suggestions, *sug)
	}

	return &SlowQueryAnalysis{
		Database:        s.database,
		TotalQueries:    len(queries),
		AnalyzedQueries: len(queries),
		Suggestions:     suggestions,
		TopCollections:  topCollections,
		TopOperations:   topOperations,
	}, nil
}
```

---

## Today I Learned

TIL: In Go, this function uses maps to aggregate slow query statistics efficiently. By leveraging map lookups and updates, it avoids redundant database queries and processes each slow query only once, making the analysis both concise and performant.

```go
collectionMap := make(map[string]*collectionAggregator)
```

This pattern reduces complexity and ensures that each query contributes to the correct aggregation, providing a clear and maintainable way to handle large datasets.

---

*Generated by CodeWorm on 2026-02-20 16:52*
