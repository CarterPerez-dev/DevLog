# runUpdate

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/simple-vulnerability-scanner/internal/cli/update.go
**Language:** go
**Lines:** 269-359
**Complexity:** 14.0

---

## Source Code

```go
func runUpdate(
	ctx context.Context,
	f *updateFlags,
	dryRun bool,
) error {
	start := time.Now()
	cfg := config.Load(f.file)

	deps, err := parseDeps(f.file)
	if err != nil {
		return err
	}

	spin := ui.NewSpinner(fmt.Sprintf(
		"Scanning %d dependencies...", len(deps),
	))
	spin.Start()

	client, err := pypi.NewClient(defaultCacheDir())
	if err != nil {
		spin.Stop()
		return err
	}

	names := make([]string, len(deps))
	for i, d := range deps {
		names[i] = d.Name
	}
	fetched := client.FetchAllVersions(ctx, names)

	versionMap := make(map[string][]string, len(fetched))
	for _, r := range fetched {
		if r.Err == nil {
			versionMap[r.Name] = r.Versions
		}
	}

	updates, updateSpecs := resolveUpdates(
		deps, versionMap, f.safe,
		f.includePrerelease, cfg.Ignore,
	)

	sortUpdates(updates)

	var vulns map[string][]types.Vulnerability
	var scanErr error
	if f.vulns {
		vulns, scanErr = scanForVulns(ctx, deps)
	}

	spin.Stop()

	if scanErr != nil {
		PrintError(scanErr.Error())
	}

	if !dryRun && len(updateSpecs) > 0 {
		if err := updateDepsFile(
			f.file, updateSpecs,
		); err != nil {
			return fmt.Errorf("write updates: %w", err)
		}
	}

	minSev := resolveMinSeverity(cfg.MinSeverity)
	if vulns != nil {
		vulns = filterIgnoredVulns(vulns, cfg.IgnoreVulns)
		vulns = filterVulnsBySeverity(vulns, minSev)
		PrintVulnerabilities(vulns)
	}

	PrintUpdates(updates)
	PrintSkipped(updates)

	totalVulns := 0
	for _, vl := range vulns {
		totalVulns += len(vl)
	}

	PrintSummary(types.ScanResult{
		Updates:         updates,
		Vulnerabilities: vulns,
		TotalPackages:   len(deps),
		TotalUpdated:    len(updateSpecs),
		TotalVulns:      totalVulns,
		VulnsScanned:    f.vulns,
		Duration:        time.Since(start),
	}, !dryRun && len(updateSpecs) > 0)

	return nil
}
```

---

## Today I Learned

TIL: In `runUpdate`, the function uses a spinner to provide visual feedback during dependency scanning, enhancing user experience by showing progress without blocking the UI. This simple yet effective technique keeps users informed and engaged, making the tool more usable.

```go
spin := ui.NewSpinner(fmt.Sprintf("Scanning %d dependencies...", len(deps)))
spin.Start()
```

This snippet starts a spinner to indicate long-running operations, improving usability.

---

*Generated by CodeWorm on 2026-02-18 15:45*
