# WebSocketService.handle_encrypted_message

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/backend/app/services/websocket_service.py
**Language:** python
**Lines:** 87-179
**Complexity:** 11.0

---

## Source Code

```python
async def handle_encrypted_message(
        self,
        user_id: UUID,
        message: dict[str,
                      Any]
    ) -> None:
        """
        Process client-encrypted message and forward to recipient (pass-through)
        """
        try:
            recipient_id = UUID(message.get("recipient_id"))
            room_id = message.get("room_id")
            ciphertext = message.get("ciphertext")
            nonce = message.get("nonce")
            header = message.get("header")
            temp_id = message.get("temp_id", "")

            if not ciphertext or not nonce or not header:
                logger.error("Missing encryption fields in message from %s", user_id)
                return

            if not room_id:
                logger.error("Missing room_id in message from %s", user_id)
                return

            async with async_session_maker() as session:
                result = await message_service.store_encrypted_message(
                    session,
                    user_id,
                    recipient_id,
                    ciphertext,
                    nonce,
                    header,
                    room_id,
                )

            ws_message = EncryptedMessageWS(
                message_id = result.id if hasattr(result, 'id') else "unknown",
                sender_id = str(user_id),
                recipient_id = str(recipient_id),
                room_id = room_id,
                content = "",
                ciphertext = ciphertext,
                nonce = nonce,
                header = header,
                sender_username = result.sender_username if hasattr(result, 'sender_username') else ""
            )

            is_recipient_connected = connection_manager.is_user_connected(recipient_id)
            logger.debug(
                "Sending to recipient %s - connected: %s",
                recipient_id,
                is_recipient_connected
            )

            await connection_manager.send_message(
                recipient_id,
                ws_message.model_dump(mode = "json")
            )
            logger.debug("Message sent to recipient %s", recipient_id)

            confirmation = MessageSentWS(
                temp_id = temp_id,
                message_id = result.id if hasattr(result, 'id') else "unknown",
                room_id = room_id,
                status = "sent",
                created_at = result.created_at if hasattr(result, 'created_at') else datetime.now(UTC)
            )

            await connection_manager.send_message(
                user_id,
                confirmation.model_dump(mode = "json")
            )

            logger.info(
                "Encrypted message forwarded: %s -> %s in room %s",
                user_id,
                recipient_id,
                room_id
            )

        except ValueError as e:
            logger.error(
                "Invalid UUID in encrypted message from %s: %s",
                
```

---

## Today I Learned

TIL: This function uses an async context manager to handle database operations efficiently. By wrapping `async_session_maker()` with `async with`, it ensures the session is properly managed and closed after executing the `message_service.store_encrypted_message` method, preventing resource leaks and maintaining clean code.

```python
async with async_session_maker() as session:
    # Database operation within this block
```

This pattern promotes better resource management and readability.

---

*Generated by CodeWorm on 2026-02-19 08:19*
