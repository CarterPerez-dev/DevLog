# Run

**Type:** Today I Learned
**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/websocket/hub.go
**Language:** go
**Lines:** 44-94
**Complexity:** 10.0

---

## Source Code

```go
func (h *Hub) Run(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			h.mu.Lock()
			for client := range h.clients {
				close(client.send)
				delete(h.clients, client)
			}
			h.mu.Unlock()
			return

		case client := <-h.register:
			h.mu.Lock()
			h.clients[client] = true
			h.mu.Unlock()
			h.logger.Debug("websocket client connected",
				"client_id", client.clientID,
				"total_clients", len(h.clients),
			)

		case client := <-h.unregister:
			h.mu.Lock()
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send)
			}
			h.mu.Unlock()
			h.logger.Debug("websocket client disconnected",
				"client_id", client.clientID,
				"total_clients", len(h.clients),
			)

		case message := <-h.broadcast:
			h.mu.RLock()
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					h.mu.RUnlock()
					h.mu.Lock()
					delete(h.clients, client)
					close(client.send)
					h.mu.Unlock()
					h.mu.RLock()
				}
			}
			h.mu.RUnlock()
		}
	}
}
```

---

## Today I Learned

TIL: The `Run` function in Go uses select statements to handle multiple channels concurrently, ensuring efficient and responsive handling of websocket clients. The clever use of context cancellation (`ctx.Done()`) allows graceful shutdown by closing client sends and cleaning up connections. This pattern minimizes resource leaks and ensures clean state management during runtime or shutdown.

---

*Generated by CodeWorm on 2026-02-21 08:28*
