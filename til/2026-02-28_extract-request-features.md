# extract_request_features

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/core/features/extractor.py
**Language:** python
**Lines:** 41-105
**Complexity:** 10.0

---

## Source Code

```python
def extract_request_features(
    entry: ParsedLogEntry,
    country_code: str = "",
) -> dict[str, int | float | bool | str]:
    """
    Extract 23 stateless per-request features from a parsed log entry.
    """
    full_uri = entry.path
    if entry.query_string:
        full_uri = f"{entry.path}?{entry.query_string}"

    ua_lower = entry.user_agent.lower()
    non_alnum = sum(1 for c in entry.path if not c.isalnum())
    path_len = len(entry.path)

    _, ext = splitext(entry.path)

    return {
        "http_method":
        entry.method,
        "path_depth":
        len([s for s in entry.path.split("/") if s]),
        "path_entropy":
        _shannon_entropy(entry.path),
        "path_length":
        path_len,
        "query_string_length":
        len(entry.query_string),
        "query_param_count":
        (len(entry.query_string.split("&")) if entry.query_string else 0),
        "has_encoded_chars":
        bool(ENCODED_CHARS.search(full_uri)),
        "has_double_encoding":
        bool(DOUBLE_ENCODED.search(full_uri)),
        "status_code":
        entry.status_code,
        "status_class":
        f"{entry.status_code // 100}xx",
        "response_size":
        entry.response_size,
        "hour_of_day":
        entry.timestamp.hour,
        "day_of_week":
        entry.timestamp.weekday(),
        "is_weekend":
        entry.timestamp.weekday() >= 5,
        "ua_length":
        len(entry.user_agent),
        "ua_entropy":
        _shannon_entropy(entry.user_agent),
        "is_known_bot":
        any(sig in ua_lower for sig in BOT_USER_AGENTS),
        "is_known_scanner":
        any(sig in ua_lower for sig in SCANNER_USER_AGENTS),
        "has_attack_pattern":
        bool(ATTACK_COMBINED.search(full_uri)),
        "special_char_ratio":
        non_alnum / path_len if path_len else 0.0,
        "file_extension":
        ext,
        "country_code":
        country_code,
        "is_private_ip":
        _is_private_ip(entry.ip),
    }
```

---

## Today I Learned

TIL: In `extract_request_features`, the function uses a mix of static and dynamic feature extraction to analyze HTTP requests. Notably, it calculates the "special_char_ratio" by dividing the count of non-alphanumeric characters (`non_alnum`) by the path length (`path_len`). This clever ratio helps identify paths with unusual or potentially malicious characters, enhancing security analysis.

```python
# Example: special_char_ratio = non_alnum / path_len if path_len else 0.0
```

This technique is both simple and effective for spotting suspicious patterns in URLs!

---

*Generated by CodeWorm on 2026-02-28 07:36*
