# health_check_detailed

**Type:** Today I Learned
**Repository:** my-portfolio
**File:** v1/backend/app/core/health_routes.py
**Language:** python
**Lines:** 49-80
**Complexity:** 5.0

---

## Source Code

```python
async def health_check_detailed() -> HealthDetailedResponse:
    """
    Detailed health check including database connectivity
    """
    db_status = HealthStatus.UNHEALTHY
    redis_status = None

    try:
        async with sessionmanager.connect() as conn:
            await conn.execute(text("SELECT 1"))
            db_status = HealthStatus.HEALTHY
    except Exception:
        db_status = HealthStatus.UNHEALTHY

    if settings.REDIS_URL:
        try:
            r = redis.from_url(str(settings.REDIS_URL))
            await r.ping()
            redis_status = HealthStatus.HEALTHY
            await r.close()
        except Exception:
            redis_status = HealthStatus.UNHEALTHY

    overall = HealthStatus.HEALTHY if db_status == HealthStatus.HEALTHY else HealthStatus.DEGRADED

    return HealthDetailedResponse(
        status = overall,
        environment = settings.ENVIRONMENT.value,
        version = settings.APP_VERSION,
        database = db_status,
        redis = redis_status,
    )
```

---

## Today I Learned

TIL: I learned about using context managers with `async with` to safely handle database connections in asynchronous functions. This ensures resources are properly managed, making the `health_check_detailed` function both clean and robust.

```python
async def health_check_detailed() -> HealthDetailedResponse:
    ...
    try:
        async with sessionmanager.connect() as conn:
            await conn.execute(text("SELECT 1"))
            db_status = HealthStatus.HEALTHY
    except Exception:
        db_status = HealthStatus.UNHEALTHY
    ...
```

This pattern minimizes error handling boilerplate and ensures connections are closed automatically.

---

*Generated by CodeWorm on 2026-03-01 23:59*
