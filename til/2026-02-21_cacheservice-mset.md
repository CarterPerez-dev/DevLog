# CacheService.mset

**Type:** Today I Learned
**Repository:** kill-pr0cess.inc
**File:** backend/src/services/cache_service.rs
**Language:** rust
**Lines:** 432-481
**Complexity:** 9.0

---

## Source Code

```rust
pub async fn mset<T>(&self, entries: &[(&str, &T)], ttl_seconds: Option<u64>) -> Result<()>
    where
    T: Serialize + Send + Sync,
    {
        if entries.is_empty() {
            return Ok(());
        }

        let ttl = ttl_seconds.unwrap_or(self.default_ttl);
        let now = self.current_timestamp();
        let mut conn = self.get_connection().await?;

        debug!("Cache MSET: {} entries (TTL: {}s)", entries.len(), ttl);

        // Prepare entries as (key, value) tuples for mset_multiple
        let mut kv_pairs_for_redis: Vec<(String, String)> = Vec::with_capacity(entries.len());

        for (key, value) in entries {
            let full_key = self.build_key(key);
            let entry = CacheEntry {
                data: value,
                created_at: now,
                expires_at: now + ttl,
                access_count: 0,
                last_accessed: now,
                version: 1,
            };

            let serialized = serde_json::to_string(&entry)
            .map_err(|e| AppError::SerializationError(format!("Failed to serialize cache entry: {}", e)))?;

            kv_pairs_for_redis.push((full_key, serialized));
        }

        // Set all entries
        conn.mset::<_, _, ()>(&kv_pairs_for_redis).await
        .map_err(|e| AppError::CacheError(format!("Failed to set multiple cache entries: {}", e)))?;

        // Set expiration for all keys in a pipeline for efficiency
        let mut pipe = redis::pipe();
        for (key, _) in entries { // Iterate original keys to avoid issues with kv_pairs_for_redis potentially being moved
            let full_key_for_expire = self.build_key(key);
            pipe.expire(full_key_for_expire, ttl as i64);
        }
        pipe.query_async::<_, ()>(&mut conn).await
            .map_err(|e| AppError::CacheError(format!("Failed to set expiration for multiple keys: {}", e)))?;


        Ok(())
    }
```

---

## Today I Learned

TIL: In `CacheService::mset`, the code efficiently handles caching and expiration by using Redis pipelines to batch operations, reducing network overhead. This technique minimizes round trips between the application and Redis, making it both faster and more efficient.

```rust
pipe.expire(full_key_for_expire, ttl as i64);
pipe.query_async::<_, ()>(&mut conn).await
    .map_err(|e| AppError::CacheError(format!("Failed to set expiration for multiple keys: {}", e)))?;
```

By chaining `expire` calls in a pipeline and then executing them all at once, the code ensures that cache entries are both stored and expired with minimal latency.

---

*Generated by CodeWorm on 2026-02-21 17:26*
