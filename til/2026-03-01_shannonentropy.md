# ShannonEntropy

**Type:** Today I Learned
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/rules/entropy.go
**Language:** go
**Lines:** 48-83
**Complexity:** 9.0

---

## Source Code

```go
func ShannonEntropy(data, charset string) float64 {
	if len(data) == 0 {
		return 0.0
	}

	filtered := data
	if charset != "" {
		cs := charsetSet(charset)
		var b strings.Builder
		b.Grow(len(data))
		for _, c := range data {
			if cs[c] {
				b.WriteRune(c)
			}
		}
		filtered = b.String()
		if len(filtered) == 0 {
			return 0.0
		}
	}

	freq := make(map[rune]int)
	for _, c := range filtered {
		freq[c]++
	}

	length := float64(len([]rune(filtered)))
	entropy := 0.0
	for _, count := range freq {
		p := float64(count) / length
		if p > 0 {
			entropy -= p * math.Log2(p)
		}
	}
	return entropy
}
```

---

## Today I Learned

TIL: In the `ShannonEntropy` function, the use of a `strings.Builder` to filter characters is clever. It efficiently builds the filtered string only when needed, avoiding unnecessary allocations and making the entropy calculation more memory-friendly.

```go
if charset != "" {
	cs := charsetSet(charset)
	var b strings.Builder
	b.Grow(len(data))
	for _, c := range data {
		if cs[c] {
			b.WriteRune(c)
		}
	}
	filtered = b.String()
}
```

This pattern minimizes allocations by reusing the `strings.Builder` and only creating a new string if necessary.

---

*Generated by CodeWorm on 2026-03-01 13:42*
