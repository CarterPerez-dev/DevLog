# CacheService.get

**Type:** Today I Learned
**Repository:** kill-pr0cess.inc
**File:** backend/src/services/cache_service.rs
**Language:** rust
**Lines:** 149-208
**Complexity:** 9.0

---

## Source Code

```rust
pub async fn get<T>(&self, key: &str) -> Result<Option<T>>
    where
    T: DeserializeOwned + Send + Sync + Serialize,
    {
        let full_key = self.build_key(key);
        let mut conn = self.get_connection().await?;

        debug!("Cache GET: {}", full_key);

        match conn.get::<_, Option<String>>(&full_key).await {
            Ok(Some(cached_data)) => {
                match serde_json::from_str::<CacheEntry<T>>(&cached_data) {
                    Ok(mut entry) => {
                        let now = self.current_timestamp();

                        // Check if entry has expired
                        if now > entry.expires_at {
                            debug!("Cache entry expired: {}", full_key);
                            // Asynchronously delete expired entry
                            let _ = self.delete(key).await; // Use existing delete method
                            return Ok(None);
                        }

                        // Update access metadata
                        entry.access_count += 1;
                        entry.last_accessed = now;

                        // Update entry in cache (fire and forget, but handle potential errors)
                        let updated_data_res = serde_json::to_string(&entry);
                        if let Ok(updated_data) = updated_data_res {
                           let set_result = conn.set::<_, _, ()>(&full_key, updated_data).await;
                           if let Err(e) = set_result {
                               warn!("Failed to update access metadata for cache key {}: {}", full_key, e);
                           }
                        } else if let Err(e) = updated_data_res {
                             warn!("Failed to serialize updated metadata for cache key {}: {}", full_key, e);
                        }


                        debug!("Cache HIT: {}", full_key);
                        Ok(Some(entry.data))
                    }
                    Err(e) => {
                        warn!("Failed to deserialize cache entry {}: {}", full_key, e);
                        // Delete corrupted entry
                        let _ = self.delete(key).await;
                        Ok(None)
                    }
                }
            }
            Ok(None) => {
                debug!("Cache MISS: {}", full_key);
                Ok(None)
            }
            Err(e) => {
                error!("Cache GET error for {}: {}", full_key, e);
                Err(AppError::CacheError(format!("Failed to get cache entry: {}", e)))
            }
        }
    }
```

---

## Today I Learned

TIL: Rust's `Result` and `Option` patterns are elegantly used here to handle asynchronous cache operations. The function adeptly manages potential errors, ensuring that corrupted entries are deleted and expired ones are asynchronously removed, maintaining cache integrity while providing informative logs.

```rust
match conn.get::<_, Option<String>>(&full_key).await {
    // ...
}
```

This pattern ensures robust error handling and graceful degradation of the caching mechanism.

---

*Generated by CodeWorm on 2026-02-21 17:05*
