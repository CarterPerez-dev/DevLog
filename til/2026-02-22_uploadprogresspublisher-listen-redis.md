# UploadProgressPublisher._listen_redis

**Type:** Today I Learned
**Repository:** vuemantics
**File:** backend/core/websocket/publisher.py
**Language:** python
**Lines:** 107-198
**Complexity:** 21.0

---

## Source Code

```python
async def _listen_redis(self) -> None:
        """
        Background task that listens to Redis pub/sub

        Receives messages from Redis and
        forwards to local WebSocket connections
        """
        pubsub = None
        try:
            pubsub = await redis_pool.psubscribe("upload:*", "user:*")

            logger.info("Redis listener started (patterns: upload:*, user:*)")

            while self._running:
                try:
                    message = await pubsub.get_message(
                        ignore_subscribe_messages = True,
                        timeout = 0.1
                    )

                    if message is None:
                        continue

                    if message["type"] != "pmessage":
                        continue

                    # Note: decode_responses=True means these are already strings
                    channel = message["channel"]
                    if isinstance(channel, bytes):
                        channel = channel.decode("utf-8")

                    payload = message["data"]
                    if isinstance(payload, bytes):
                        payload = payload.decode("utf-8")

                    manager = get_manager()

                    user_ids: list[str]
                    if channel.startswith("upload:"):
                        upload_id = channel.split(":", 1)[1]
                        user_ids = list(manager.get_upload_subscriber_ids(upload_id))
                    elif channel.startswith("user:"):
                        user_id = channel.split(":", 1)[1]
                        user_ids = [user_id]
                    else:
                        continue

                    for user_id in user_ids:
                        connections = list(
                            manager.user_connections.get(user_id,
                                                         set())
                        )
                        dead_connections: set[WebSocket] = set()

                        for ws in connections:
                            try:
                                await ws.send_text(payload)
                            except Exception as e:
                                logger.debug(
                                    f"Failed to forward message to user {user_id}: {e}"
                                )
                                dead_connections.add(ws)

                        # Garbage c
                        for ws in dead_connections:
                            await manager.disconnect(user_id, ws)

                except asyncio.CancelledError:
                    break
                except Exception as e:
                    logger.error(f"Error in Redis listener: {e}")
                    if self._running:
                        await asyncio.sleep(1)

        except asyncio.CancelledError:
            logger.info("Redis listener cancelled")
        except Exception as e:
            logger.error(f"Redis listener err
```

---

## Today I Learned

TIL: The `asyncio.wait_for` used to gracefully close the Redis pub/sub connection is clever. It handles potential timeouts and errors, ensuring resources are cleaned up properly without crashing.

```markdown
Today I learned: The `asyncio.wait_for` in `_listen_redis` ensures a graceful shutdown of Redis connections by handling timeouts and exceptions, preventing resource leaks.
```

This technique elegantly manages asynchronous cleanup, making the code robust and maintainable.

---

*Generated by CodeWorm on 2026-02-22 08:10*
