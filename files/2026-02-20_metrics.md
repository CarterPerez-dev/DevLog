# metrics

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/handler/metrics.go
**Language:** go
**Lines:** 1-137
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
metrics.go
*/

package handler

import (
	"context"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"

	"github.com/carterperez-dev/templates/go-backend/internal/core"
	"github.com/carterperez-dev/templates/go-backend/internal/metrics"
)

type metricsService interface {
	GetDashboardMetrics(ctx context.Context) (*metrics.DashboardMetrics, error)
	GetSlowQueries(ctx context.Context, minMillis, limit int) (*metrics.SlowQueryReport, error)
	GetProfilingStatus(ctx context.Context) (*metrics.ProfilingStatus, error)
	SetProfilingLevel(ctx context.Context, level, slowMs int) error
	AnalyzeSlowQueries(ctx context.Context, minMillis, limit int) (*metrics.SlowQueryAnalysis, error)
}

type MetricsHandler struct {
	service metricsService
}

func NewMetricsHandler(service metricsService) *MetricsHandler {
	return &MetricsHandler{service: service}
}

func (h *MetricsHandler) RegisterRoutes(r chi.Router) {
	r.Route("/api/metrics", func(r chi.Router) {
		r.Get("/", h.GetMetrics)
		r.Get("/slow-queries", h.GetSlowQueries)
		r.Get("/slow-queries/analyze", h.AnalyzeSlowQueries)
		r.Get("/profiling", h.GetProfilingStatus)
		r.Put("/profiling", h.SetProfilingLevel)
	})
}

func (h *MetricsHandler) GetMetrics(w http.ResponseWriter, r *http.Request) {
	m, err := h.service.GetDashboardMetrics(r.Context())
	if err != nil {
		core.InternalServerError(w, err)
		return
	}

	core.OK(w, m)
}

func (h *MetricsHandler) GetSlowQueries(w http.ResponseWriter, r *http.Request) {
	minMillis := 100
	if v := r.URL.Query().Get("min_millis"); v != "" {
		if parsed, err := strconv.Atoi(v); err == nil && parsed > 0 {
			minMillis = parsed
		}
	}

	limit := 50
	if v := r.URL.Query().Get("limit"); v != "" {
		if parsed, err := strconv.Atoi(v); err == nil && parsed > 0 && parsed <= 500 {
			limit = parsed
		}
	}

	report, err := h.service.GetSlowQueries(r.Context(), minMillis, limit)
	if err != nil {
		core.InternalServerError(w, err)
		return
	}

	core.OK(w, report)
}

func (h *MetricsHandler) AnalyzeSlowQueries(w http.ResponseWriter, r *http.Request) {
	minMillis := 100
	if v := r.URL.Query().Get("min_millis"); v != "" {
		if parsed, err := strconv.Atoi(v); err == nil && parsed > 0 {
			minMillis = parsed
		}
	}

	limit := 100
	if v := r.URL.Query().Get("limit"); v != "" {
		if parsed, err := strconv.Atoi(v); err == nil && parsed > 0 && parsed <= 1000 {
			limit = parsed
		}
	}

	analysis, err := h.service.AnalyzeSlowQueries(r.Context(), minMillis, limit)
	if err != nil {
		core.InternalServerError(w, err)
		return
	}

	core.OK(w, analysis)
}

func (h *MetricsHandler) GetProfilingStatus(w http.ResponseWriter, r *http.Request) {
	status, err := h.service.GetProfilingStatus(r.Context())
	if err != nil {
		core.InternalServerError(w, err)
		return
	}

	core.OK(w, status)
}

type SetProfilingRequest struct {
	Level  int `json:"level"`
	SlowMs int `json:"slow_ms"`
}

func (h *MetricsHandler) SetProfilingLevel(w http.ResponseWriter, r *http.Request) {
	var req SetProfilingRe
```

---

## File Overview

# metrics.go

## Purpose and Responsibility
This file defines the `MetricsHandler` struct, which handles HTTP requests related to application performance metrics. It interacts with a `metricsService` to fetch various types of metric data and manage profiling settings.

## Key Exports and Public Interface
- **MetricsHandler**: A handler for metrics-related API endpoints.
  - `NewMetricsHandler(metricsService) *MetricsHandler`: Constructor function that initializes the handler with a service.
  - `RegisterRoutes(chi.Router)`: Registers routes for handling different types of metric requests.
  - Various methods like `GetMetrics`, `GetSlowQueries`, `AnalyzeSlowQueries`, `GetProfilingStatus`, and `SetProfilingLevel` to handle specific API endpoints.

## How It Fits into the Project
The `metrics.go` file is part of the handler package, which is responsible for defining and handling HTTP requests. It integrates with the core services layer via the `metricsService` interface, ensuring that metric-related functionalities are encapsulated within a well-defined service abstraction.

## Notable Design Decisions
- **Error Handling**: Uses the `core.InternalServerError` and `core.BadRequest` functions to handle errors consistently across different methods.
- **Query Parameters**: Utilizes query parameters for flexible filtering of slow queries (e.g., minimum millisecond threshold, limit).
- **JSON Decoding**: Ensures that request bodies are properly decoded using `core.DecodeJSON`.
- **Service Interface**: Defines a service interface (`metricsService`) to decouple the handler from specific implementations, promoting flexibility and testability.

---

*Generated by CodeWorm on 2026-02-20 00:06*
