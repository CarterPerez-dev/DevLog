# client

**Type:** File Overview
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/websocket/client.go
**Language:** go
**Lines:** 1-167
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
client.go
*/

package websocket

import (
	"encoding/json"
	"log/slog"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

const (
	writeWait      = 10 * time.Second
	pongWait       = 60 * time.Second
	pingPeriod     = (pongWait * 9) / 10
	maxMessageSize = 4096
)

type Client struct {
	hub           *Hub
	conn          *websocket.Conn
	send          chan []byte
	subscriptions map[string]bool
	logger        *slog.Logger
	mu            sync.RWMutex
}

// NewClient creates a WebSocket client.
func NewClient(hub *Hub, conn *websocket.Conn, logger *slog.Logger) *Client {
	return &Client{
		hub:           hub,
		conn:          conn,
		send:          make(chan []byte, 256),
		subscriptions: make(map[string]bool),
		logger:        logger,
	}
}

// ReadPump handles incoming messages from the WebSocket connection.
func (c *Client) ReadPump() {
	defer func() {
		c.hub.Unregister(c)
		_ = c.conn.Close()
	}()

	c.conn.SetReadLimit(maxMessageSize)
	_ = c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error {
		return c.conn.SetReadDeadline(time.Now().Add(pongWait))
	})

	for {
		_, message, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(
				err,
				websocket.CloseGoingAway,
				websocket.CloseAbnormalClosure,
			) {
				c.logger.Error("websocket read error", "error", err)
			}
			break
		}

		c.handleMessage(message)
	}
}

// WritePump handles outgoing messages to the WebSocket connection.
func (c *Client) WritePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		_ = c.conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.send:
			_ = c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				_ = c.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			w, err := c.conn.NextWriter(websocket.TextMessage)
			if err != nil {
				return
			}
			_, _ = w.Write(message)

			n := len(c.send)
			for i := 0; i < n; i++ {
				_, _ = w.Write([]byte{'\n'})
				_, _ = w.Write(<-c.send)
			}

			if err := w.Close(); err != nil {
				return
			}

		case <-ticker.C:
			_ = c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

// Subscribe adds a project to this client's subscriptions.
func (c *Client) Subscribe(projectID string) {
	c.mu.Lock()
	c.subscriptions[projectID] = true
	c.mu.Unlock()
}

// Unsubscribe removes a project from this client's subscriptions.
func (c *Client) Unsubscribe(projectID string) {
	c.mu.Lock()
	delete(c.subscriptions, projectID)
	c.mu.Unlock()
}

// IsSubscribed checks if client is subscribed to a project.
func (c *Client) IsSubscribed(projectID string) bool {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if len(c.subscriptions) == 0 {
		return true
	}

	return c.subscriptions[projectID]
}

func (c *Client) handleMessage(data []byte) {
	var msg Message
	if err := json.Unmarshal(data, &msg); err != nil {
	
```

---

## File Overview

### client.go

**Purpose and Responsibility:**
This file defines the `Client` struct for handling WebSocket connections within the `websocket` package. It manages communication between clients and a central hub, including subscription management and message handling.

**Key Exports and Public Interface:**
- **NewClient:** Creates a new `Client` instance.
- **ReadPump:** Handles incoming messages from the WebSocket connection.
- **WritePump:** Manages outgoing messages to the WebSocket connection.
- **Subscribe/Unsubscribe/IsSubscribed:** Methods for managing client subscriptions.

**How It Fits in the Project:**
The `client.go` file is a crucial component of the WebSocket communication layer. Clients connect to the server, subscribe to projects, and receive updates via the hub. This file ensures efficient message handling and subscription management, facilitating real-time data exchange within the application.

**Notable Design Decisions:**
- **Error Handling:** Robust error handling, especially for unexpected close errors.
- **Concurrency:** Use of goroutines (`ReadPump` and `WritePump`) to manage read and write operations concurrently.
- **Subscription Management:** Thread-safe subscription management using mutexes.
- **JSON Parsing:** Decoding incoming messages into a structured format for easier processing.

This file is integral to the WebSocket communication mechanism, ensuring smooth data flow between clients and the server.

---

*Generated by CodeWorm on 2026-02-19 19:50*
