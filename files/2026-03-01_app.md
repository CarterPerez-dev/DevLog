# app

**Type:** File Overview
**Repository:** Yoshi-Audit
**File:** internal/ui/app.go
**Language:** go
**Lines:** 1-233
**Complexity:** 0.0

---

## Source Code

```go
// Â©AngelaMos | 2026
// app.go

package ui

import (
	"fmt"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	"github.com/CarterPerez-dev/yoshi-audit/internal/config"
	"github.com/CarterPerez-dev/yoshi-audit/internal/ui/audittab"
	"github.com/CarterPerez-dev/yoshi-audit/internal/ui/dashboard"
	"github.com/CarterPerez-dev/yoshi-audit/internal/ui/dockertab"
)

type Tab int

const (
	TabDashboard Tab = iota
	TabDocker
	TabAudit
)

type TickMsg time.Time

type App struct {
	activeTab  Tab
	width      int
	height     int
	paused     bool
	showSplash bool
	splash     SplashModel
	dashboard  dashboard.Dashboard
	dockerTab  dockertab.DockerTab
	auditTab   audittab.AuditTab
	cfg        config.Config
}

func NewApp() App {
	cfg, _ := config.Load(config.DefaultPath())
	return App{
		activeTab:  TabDashboard,
		showSplash: true,
		splash:     NewSplash(),
		dashboard:  dashboard.NewDashboard(),
		dockerTab:  dockertab.NewDockerTab(cfg),
		auditTab:   audittab.NewAuditTab(),
		cfg:        cfg,
	}
}

func doTick() tea.Cmd {
	return tea.Tick(2*time.Second, func(t time.Time) tea.Msg {
		return TickMsg(t)
	})
}

func (a App) Init() tea.Cmd {
	if a.showSplash {
		return a.splash.Init()
	}
	return a.initDataFetches()
}

func (a App) initDataFetches() tea.Cmd {
	cfg := a.cfg
	auditScanner := a.auditTab.Scanner()
	auditRSS := a.auditTab.RSSHistory()
	return tea.Batch(doTick(), dashboard.FetchStats, func() tea.Msg {
		return dockertab.FetchDockerData(cfg)
	}, func() tea.Msg {
		return audittab.FetchAuditData(auditScanner, auditRSS)
	})
}

func (a App) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	if a.showSplash {
		if wsm, ok := msg.(tea.WindowSizeMsg); ok {
			a.width = wsm.Width
			a.height = wsm.Height
		}
		var cmd tea.Cmd
		a.splash, cmd = a.splash.Update(msg)
		if a.splash.Done() {
			a.showSplash = false
			return a, a.initDataFetches()
		}
		return a, cmd
	}

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		a.width = msg.Width
		a.height = msg.Height
	case dashboard.StatsMsg:
		a.dashboard, _ = a.dashboard.Update(msg)
	case dockertab.DockerDataMsg:
		a.dockerTab, _ = a.dockerTab.Update(msg)
	case audittab.AuditDataMsg:
		a.auditTab, _ = a.auditTab.Update(msg)
	case dockertab.DeleteResultMsg:
		var cmd tea.Cmd
		a.dockerTab, cmd = a.dockerTab.Update(msg)
		return a, cmd
	case tea.KeyMsg:
		if a.activeTab == TabDocker {
			switch msg.String() {
			case "q", "ctrl+c":
				return a, tea.Quit
			case "tab":
				a.activeTab = (a.activeTab + 1) % 3
			case "r":
				cfg := a.cfg
				return a, func() tea.Msg { return dockertab.FetchDockerData(cfg) }
			default:
				var cmd tea.Cmd
				a.dockerTab, cmd = a.dockerTab.Update(msg)
				return a, cmd
			}
			return a, nil
		}

		if a.activeTab == TabAudit {
			switch msg.String() {
			case "q", "ctrl+c":
				return a, tea.Quit
			case "tab":
				a.activeTab = (a.activeTab + 1) % 3
			default:
				var cmd tea.Cmd
				a.auditTab, cmd = a.auditTab.Update(msg)
				return a, cmd
			}
	
```

---

## File Overview

# app.go

## Purpose and Responsibility
This Go source file defines the main application model for the user interface (UI) of Yoshi-Audit, a tool designed to monitor Docker containers and perform security audits. The `App` struct encapsulates the state and behavior of the UI, managing tabs for different views such as Dashboard, Docker, and Audit.

## Key Exports and Public Interface
- **Type**: `App`
  - Represents the main application model.
  - Contains methods for initialization (`Init`), updating state (`Update`), and rendering the view (`View`).

- **Methods**:
  - `NewApp() App`: Initializes a new instance of the app with default configurations.
  - `Init()` tea.Cmd: Sets up initial commands, such as fetching data or displaying the splash screen.
  - `Update(msg tea.Msg) (tea.Model, tea.Cmd)`: Handles messages to update the application state and return commands for UI updates.
  - `View() string`: Renders the current view of the app based on the active tab.

## How It Fits in the Project
The `app.go` file serves as the central hub for the UI, integrating with other modules like `dashboard`, `dockertab`, and `audittab`. These modules provide specific functionalities that are aggregated by the `App` struct to create a cohesive user experience. The app handles state management, event processing, and rendering, making it a critical component of the project.

## Notable Design Decisions
- **Error Handling**: Uses Go's idiomatic error handling with `error` types.
- **Goroutines**: Utilizes goroutines for background tasks like data fetching through `tea.Batch`.
- **Tea Framework**: Leverages the `charmbracelet/bubbletea` framework for event-driven UI updates, ensuring responsive and efficient state management.
- **Tab Management**: Implements a tab-based navigation system to switch between different views (`Dashboard`, `Docker`, `Audit`) with keyboard shortcuts.

---

*Generated by CodeWorm on 2026-03-01 10:44*
