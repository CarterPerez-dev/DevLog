# scanner

**Type:** File Overview
**Repository:** docksec
**File:** internal/scanner/scanner.go
**Language:** go
**Lines:** 1-261
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2025
scanner.go
*/

package scanner

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"runtime"

	"github.com/CarterPerez-dev/docksec/internal/analyzer"
	"github.com/CarterPerez-dev/docksec/internal/config"
	"github.com/CarterPerez-dev/docksec/internal/docker"
	"github.com/CarterPerez-dev/docksec/internal/finding"
	"github.com/CarterPerez-dev/docksec/internal/report"
	"golang.org/x/sync/errgroup"
	"golang.org/x/time/rate"
)

type Scanner struct {
	cfg      *config.Config
	client   *docker.Client
	logger   *slog.Logger
	limiter  *rate.Limiter
	reporter report.Reporter
}

func New(cfg *config.Config) (*Scanner, error) {
	client, err := docker.NewClient()
	if err != nil {
		return nil, fmt.Errorf("creating docker client: %w", err)
	}

	logger := slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: getLogLevel(cfg),
	}))

	reporter, err := report.NewReporter(cfg.Output, cfg.OutputFile)
	if err != nil {
		return nil, fmt.Errorf("creating reporter: %w", err)
	}

	workers := cfg.Workers
	if workers <= 0 {
		workers = runtime.NumCPU() * 4
	}
	if workers > config.MaxWorkers {
		workers = config.MaxWorkers
	}

	limiter := rate.NewLimiter(
		rate.Limit(config.RateLimitPerSecond),
		config.RateLimitBurst,
	)

	return &Scanner{
		cfg:      cfg,
		client:   client,
		logger:   logger,
		limiter:  limiter,
		reporter: reporter,
	}, nil
}

func (s *Scanner) Close() error {
	return s.client.Close()
}

func (s *Scanner) Run(ctx context.Context) error {
	if err := s.client.Ping(ctx); err != nil {
		return fmt.Errorf("docker daemon not accessible: %w", err)
	}

	s.logger.Info("starting security scan")

	analyzers := s.buildAnalyzers()
	if len(analyzers) == 0 {
		return fmt.Errorf("no analyzers configured")
	}

	findings, err := s.runAnalyzers(ctx, analyzers)
	if err != nil {
		return err
	}

	findings = s.filterFindings(findings)

	if err := s.reporter.Report(findings); err != nil {
		return fmt.Errorf("generating report: %w", err)
	}

	return s.checkFailThreshold(findings)
}

func (s *Scanner) buildAnalyzers() []analyzer.Analyzer {
	var analyzers []analyzer.Analyzer

	if s.cfg.ShouldScanContainers() {
		analyzers = append(analyzers, analyzer.NewContainerAnalyzer(s.client))
	}

	if s.cfg.ShouldScanDaemon() {
		analyzers = append(analyzers, analyzer.NewDaemonAnalyzer(s.client))
	}

	if s.cfg.ShouldScanImages() {
		analyzers = append(analyzers, analyzer.NewImageAnalyzer(s.client))
	}

	for _, file := range s.cfg.Files {
		if isDockerfile(file) {
			analyzers = append(analyzers, analyzer.NewDockerfileAnalyzer(file))
		} else if isComposeFile(file) {
			analyzers = append(analyzers, analyzer.NewComposeAnalyzer(file))
		}
	}

	return analyzers
}

func (s *Scanner) runAnalyzers(
	ctx context.Context,
	analyzers []analyzer.Analyzer,
) (finding.Collection, error) {
	g, ctx := errgroup.WithContext(ctx)
	g.SetLimit(s.cfg.Workers)

	results := make(chan finding.Collection, len(analyzers))

	for _, a := range analyzers {
		a := a
		g.Go(func() erro
```

---

## File Overview

# scanner.go

## Purpose and Responsibility
This Go source file is responsible for orchestrating the security scanning process within the `docksec` project. It initializes the necessary components, runs analyzers on Docker containers, images, and configurations, filters findings based on severity and CIS controls, and generates a report.

## Key Exports and Public Interface
- **Scanner**: A struct that encapsulates the state and behavior of the security scanner.
  - `New(cfg *config.Config) (*Scanner, error)`: Creates a new instance of the `Scanner`.
  - `Close() error`: Closes the Docker client connection.
  - `Run(ctx context.Context) error`: Starts the security scan process.

## How It Fits into the Project
The `scanner.go` file is part of the core functionality in `docksec`, which aims to provide comprehensive security analysis for Docker environments. It integrates with other modules like `docker`, `analyzer`, and `report` to ensure a cohesive workflow from scanning to reporting findings.

## Notable Design Decisions
- **Concurrency**: Utilizes goroutines and an error group (`errgroup`) to manage concurrent analyzer runs, ensuring efficient processing of multiple analyzers.
- **Rate Limiting**: Implements rate limiting using `golang.org/x/time/rate` to prevent overwhelming the Docker daemon with too many requests.
- **Logging**: Configures logging levels based on user settings, providing flexibility in verbosity and output.
- **Finding Filtering**: Applies filters for severity and CIS controls to tailor findings to specific security requirements.

---

*Generated by CodeWorm on 2026-02-20 19:27*
