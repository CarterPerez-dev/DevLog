# security

**Type:** File Overview
**Repository:** my-portfolio
**File:** v1/backend/app/core/security.py
**Language:** python
**Lines:** 1-190
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
security.py
"""

import asyncio
import hashlib
import secrets
from datetime import (
    UTC,
    datetime,
    timedelta,
)
from typing import Any
from uuid import UUID

import jwt
from fastapi import Response
from pwdlib import PasswordHash

import config
from config import (
    settings,
    TokenType,
)


password_hasher = PasswordHash.recommended()


async def hash_password(password: str) -> str:
    """
    Hash password using Argon2id

    Runs in thread pool to avoid blocking the async event loop
    since Argon2 is CPU intensive by design
    """
    return await asyncio.to_thread(password_hasher.hash, password)


async def verify_password(plain_password: str,
                          hashed_password: str) -> tuple[bool,
                                                         str | None]:
    """
    Verify password and check if rehash is needed

    Returns:
        Tuple of (is_valid, new_hash_if_needs_rehash)
        If password is valid but hash params are outdated, returns new hash
    """
    try:
        return await asyncio.to_thread(
            password_hasher.verify_and_update,
            plain_password,
            hashed_password
        )
    except Exception:
        return False, None


DUMMY_HASH = password_hasher.hash("dummy_password_for_timing_attack_prevention")


async def verify_password_with_timing_safety(
    plain_password: str,
    hashed_password: str | None,
) -> tuple[bool,
           str | None]:
    """
    Verify password with constant time behavior to prevent user enumeration

    If no hash is provided (user doesn't exist), still performs a dummy
    hash operation to prevent timing attacks
    """
    if hashed_password is None:
        await asyncio.to_thread(
            password_hasher.verify,
            plain_password,
            DUMMY_HASH
        )
        return False, None
    return await verify_password(plain_password, hashed_password)


def create_access_token(
    user_id: UUID,
    token_version: int,
    extra_claims: dict[str,
                       Any] | None = None,
) -> str:
    """
    Create a short lived access token
    """
    now = datetime.now(UTC)
    payload = {
        "sub": str(user_id),
        "type": TokenType.ACCESS.value,
        "token_version": token_version,
        "iat": now,
        "exp": now + timedelta(minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES),
    }
    if extra_claims:
        payload.update(extra_claims)

    return jwt.encode(
        payload,
        settings.SECRET_KEY.get_secret_value(),
        algorithm = settings.JWT_ALGORITHM,
    )


def create_refresh_token(
    user_id: UUID,
    family_id: UUID,
) -> tuple[str,
           str,
           datetime]:
    """
    Create a long lived refresh token

    Returns:
        Tuple of (raw_token, token_hash, expires_at)
        Raw token is sent to client, hash is stored in database
    """
    raw_token = secrets.token_urlsafe(32)
    token_hash = hashlib.sha256(raw_toke
```

---

## File Overview

**security.py**

This Python module is responsible for handling user authentication and authorization within the application, focusing on password hashing, token generation, and cookie management.

### Key Exports and Public API

- **Password Hashing & Verification:**
  - `hash_password`: Asynchronously hashes a plain text password.
  - `verify_password`: Verifies a password and checks if rehash is needed.
  - `verify_password_with_timing_safety`: Ensures constant-time behavior to prevent timing attacks.

- **Token Generation:**
  - `create_access_token`: Generates short-lived access tokens with specified user ID, token version, and extra claims.
  - `create_refresh_token`: Creates long-lived refresh tokens with associated user and family IDs.

- **Token Decoding & Hashing:**
  - `decode_access_token`: Validates an access token and extracts its payload.
  - `hash_token`: Securely hashes a token for storage.
  - `generate_secure_token`: Generates cryptographically secure random tokens.

- **Cookie Management:**
  - `set_refresh_cookie`: Sets a refresh token as an HttpOnly cookie.
  - `clear_refresh_cookie`: Clears the refresh token cookie.

### How It Fits into the Project

This module is central to the authentication and authorization mechanisms of the application. It interacts with user data, generates secure tokens for access and refresh purposes, and manages cookies to maintain session state securely. The functions here are called by various parts of the backend, ensuring that all user interactions are authenticated and authorized.

### Notable Design Decisions

- **Asynchronous Operations:** Functions use `asyncio.to_thread` to offload CPU-intensive tasks like hashing, preventing blocking of the event loop.
- **Timing Safety:** Implements constant-time behavior in password verification to prevent timing attacks.
- **Secure Token Handling:** Uses secure methods for token generation and storage, including SHA-256 hashing and JWT encoding with a secret key.
- **Environment-Specific Configurations:** Utilizes environment-specific settings from `config.settings` to control cookie security (e.g., `httponly`, `secure` flags).
```

This documentation provides an overview of the file's purpose, its key exports, how it integrates into the project, and highlights some design decisions.

---

*Generated by CodeWorm on 2026-02-20 02:30*
