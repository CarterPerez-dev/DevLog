# security

**Type:** File Overview
**Repository:** docksec
**File:** internal/proc/security.go
**Language:** go
**Lines:** 1-406
**Complexity:** 0.0

---

## Source Code

```go
/*
CarterPerez-dev | 2025
security.go
*/

package proc

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type SecurityProfile struct {
	PID             int
	SeccompMode     SeccompMode
	SeccompFilter   bool
	AppArmorProfile string
	SELinuxContext  string
	NoNewPrivs      bool
	Capabilities    *CapabilitySet
	Namespaces      map[string]uint64
	UserNS          bool
	RootFS          string
	CgroupNS        bool
}

type SeccompMode int

const (
	SeccompDisabled SeccompMode = 0
	SeccompStrict   SeccompMode = 1
	SeccompFilter   SeccompMode = 2
)

func (s SeccompMode) String() string {
	switch s {
	case SeccompDisabled:
		return "disabled"
	case SeccompStrict:
		return "strict"
	case SeccompFilter:
		return "filter"
	default:
		return "unknown"
	}
}

func (s SeccompMode) IsEnabled() bool {
	return s != SeccompDisabled
}

func GetSecurityProfile(pid int) (*SecurityProfile, error) {
	procPath := fmt.Sprintf("/proc/%d", pid)

	if _, err := os.Stat(procPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("process %d does not exist", pid)
	}

	profile := &SecurityProfile{
		PID:        pid,
		Namespaces: make(map[string]uint64),
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readSeccomp(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readAppArmor(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readSELinux(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readNoNewPrivs(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readCapabilities(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readNamespaces(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := profile.readRootFS(procPath); err != nil {
	}

	return profile, nil
}

func (p *SecurityProfile) readSeccomp(procPath string) error {
	file, err := os.Open(filepath.Join(procPath, "status"))
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "Seccomp:") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				switch parts[1] {
				case "0":
					p.SeccompMode = SeccompDisabled
				case "1":
					p.SeccompMode = SeccompStrict
				case "2":
					p.SeccompMode = SeccompFilter
					p.SeccompFilter = true
				}
			}
			break
		}
	}

	return scanner.Err()
}

func (p *SecurityProfile) readAppArmor(procPath string) error {
	data, err := os.ReadFile(filepath.Join(procPath, "attr/current"))
	if err != nil {
		attrPath := filepath.Join(procPath, "attr/apparmor/current")
		data, err = os.ReadFile
```

---

## File Overview

# security.go

## Purpose and Responsibility
This Go source file, `security.go`, is responsible for extracting and parsing security-related information from a process's `/proc` directory. It constructs a `SecurityProfile` struct containing details such as seccomp mode, AppArmor profile, SELinux context, no-new-privs status, capabilities, namespaces, user namespace flag, root filesystem path, and cgroup namespace.

## Key Exports and Public Interface
The primary export is the `GetSecurityProfile(pid int)` function, which returns a populated `*SecurityProfile` struct for a given process ID. Additionally, it includes several helper functions to read specific security attributes from `/proc/<pid>/status`.

## Fit in the Project
This file is part of the `proc` package within the `docksec` project, designed to analyze and manage container security profiles. It integrates with other components that may use this profile data for enforcing security policies or monitoring processes.

## Notable Design Decisions
1. **Graceful Degradation**: The `GetSecurityProfile` function uses `nolint:staticcheck` comments to ignore potential errors, ensuring the function can handle missing or incomplete `/proc` entries without failing.
2. **Error Handling**: Functions like `readSeccomp`, `readAppArmor`, etc., return detailed error messages when they encounter issues, aiding in debugging and robustness.
3. **Use of Constants and Structs**: The use of constants for seccomp modes and a struct for the security profile ensures clarity and maintainability.
4. **Filesystem Path Handling**: Functions like `readAppArmor` and `readSELinux` handle multiple paths to ensure compatibility with different system configurations.

---

*Generated by CodeWorm on 2026-02-20 19:43*
