# analyzer

**Type:** File Overview
**Repository:** CodeWorm
**File:** codeworm/analysis/analyzer.py
**Language:** python
**Lines:** 1-290
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
analysis/analyzer.py
"""
from __future__ import annotations

import random
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

from git import InvalidGitRepositoryError, Repo

from codeworm.analysis.complexity import ComplexityAnalyzer, ComplexityMetrics
from codeworm.analysis.parser import CodeExtractor, ParsedFunction, ParserManager
from codeworm.analysis.scanner import RepoScanner, ScannedFile, WeightedRepoSelector
from codeworm.analysis.scoring import GitStats, InterestScore, InterestScorer
from codeworm.models import CodeSnippet

if TYPE_CHECKING:
    from collections.abc import Iterator

    from codeworm.core.config import AnalyzerSettings, RepoEntry


@dataclass
class AnalysisCandidate:
    """
    A code snippet candidate for documentation
    """
    snippet: CodeSnippet
    parsed_function: ParsedFunction
    complexity: ComplexityMetrics | None
    git_stats: GitStats
    interest_score: InterestScore
    scanned_file: ScannedFile

    @property
    def score(self) -> float:
        return self.interest_score.total

    @property
    def is_worth_documenting(self) -> bool:
        """
        Check if this candidate meets minimum thresholds
        """
        return self.score >= 25 and self.snippet.line_count >= 10


class CodeAnalyzer:
    """
    Main code analysis engine
    Combines parsing, complexity analysis, and interest scoring
    """
    def __init__(
        self,
        repos: list[RepoEntry],
        settings: AnalyzerSettings | None = None,
    ) -> None:
        """
        Initialize analyzer with repository configurations
        """
        self.repos = repos
        self.settings = settings
        self.repo_selector = WeightedRepoSelector(repos)
        self.scanner = RepoScanner(
            include_patterns = settings.include_patterns if settings else None,
            exclude_patterns = settings.exclude_patterns if settings else None,
        )
        self.complexity_analyzer = ComplexityAnalyzer()
        self.scorer = InterestScorer()

        self._git_repos: dict[Path, Repo | None] = {}

        ParserManager.initialize()

    def _get_git_repo(self, repo_path: Path) -> Repo | None:
        """
        Get or create git repo instance for a path
        """
        if repo_path in self._git_repos:
            return self._git_repos[repo_path]
        try:
            repo = Repo(repo_path, search_parent_directories=True)
            git_root = Path(repo.working_dir)
            if git_root in self._git_repos:
                repo.close()
                self._git_repos[repo_path] = self._git_repos[git_root]
            else:
                self._git_repos[git_root] = repo
                self._git_repos[repo_path] = repo
        except InvalidGitRepositoryError:
            self._git_repos[repo_path] = None
        return self._git_repos[repo_path]

    def close_repos(self) -> None:
        """
        Close all cached git repo handles and 
```

---

## File Overview

### analyzer.py

**Purpose and Responsibility:**
This file serves as the core analysis engine for CodeWorm, a tool designed to identify code snippets worthy of documentation. It integrates parsing, complexity analysis, and interest scoring to generate high-quality documentation candidates.

**Key Exports and Public Interface:**
- `AnalysisCandidate`: A data class representing a code snippet candidate for documentation.
- `CodeAnalyzer`: The main analysis engine that combines various analyzers and scorers to produce documentation candidates.

**How it Fits into the Project:**
The `CodeAnalyzer` is central to CodeWorm's functionality. It leverages other modules like `ComplexityAnalyzer`, `ParserManager`, and `InterestScorer` to analyze code repositories, extract functions, calculate complexity metrics, and score interest levels. This analysis helps in identifying critical parts of the codebase that require documentation.

**Notable Design Decisions:**
- **Decoupling**: The file is designed with clear separation of concerns, where different classes handle specific tasks such as parsing (`CodeExtractor`), complexity analysis (`ComplexityAnalyzer`), and scoring interest levels (`InterestScorer`). This promotes modularity and ease of maintenance.
- **Lazy Initialization**: `ParserManager.initialize()` ensures that necessary parsers are set up only when needed, optimizing resource usage.
- **Git Integration**: The `_get_git_repo` method efficiently caches Git repository instances to avoid redundant operations, improving performance by reducing the number of times repositories need to be opened and closed.

---

*Generated by CodeWorm on 2026-02-27 17:12*
