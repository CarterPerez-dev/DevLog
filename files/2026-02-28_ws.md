# ws

**Type:** File Overview
**Repository:** CodeWorm
**File:** dashboard/backend/ws.py
**Language:** python
**Lines:** 1-126
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
dashboard/backend/ws.py
"""
from __future__ import annotations

import asyncio
import contextlib
import os
from collections import deque
from typing import Any

import orjson
from fastapi import APIRouter, WebSocket, WebSocketDisconnect


router = APIRouter()

LOG_BUFFER_SIZE = 200


class ConnectionManager:
    def __init__(self) -> None:
        self.active: list[WebSocket] = []
        self.log_buffer: deque[dict[str, Any]] = deque(maxlen = LOG_BUFFER_SIZE)

    async def connect(self, websocket: WebSocket) -> None:
        await websocket.accept()
        self.active.append(websocket)
        if self.log_buffer:
            history = orjson.dumps(
                {
                    "channel": "codeworm:history",
                    "data": list(self.log_buffer),
                }
            ).decode("utf-8")
            try:  # noqa: SIM105
                await websocket.send_text(history)
            except Exception:  # noqa: S110
                pass

    def disconnect(self, websocket: WebSocket) -> None:
        if websocket in self.active:
            self.active.remove(websocket)

    async def broadcast(self, message: dict[str, Any]) -> None:
        if message.get("channel") in ("codeworm:logs", "codeworm:events"):
            self.log_buffer.append(message)
        payload = orjson.dumps(message).decode("utf-8")
        disconnected: list[WebSocket] = []
        for ws in self.active:
            try:
                await ws.send_text(payload)
            except Exception:
                disconnected.append(ws)
        for ws in disconnected:
            self.disconnect(ws)


manager = ConnectionManager()

_subscriber_task: asyncio.Task | None = None


async def start_redis_subscriber() -> None:
    global _subscriber_task
    redis_url = os.environ.get("REDIS_URL", "redis://localhost:6379")

    try:
        import redis.asyncio as aioredis

        client = aioredis.from_url(redis_url, decode_responses = True)
        await client.ping()
    except Exception:
        return

    async def _subscribe() -> None:
        pubsub = client.pubsub()
        await pubsub.subscribe(
            "codeworm:logs",
            "codeworm:events",
            "codeworm:stats",
        )

        async for message in pubsub.listen():
            if message["type"] != "message":
                continue

            channel = message["channel"]
            try:
                data = orjson.loads(message["data"])
            except Exception:
                data = {"raw": message["data"]}

            await manager.broadcast({
                "channel": channel,
                "data": data,
            })

    _subscriber_task = asyncio.create_task(_subscribe())


async def stop_redis_subscriber() -> None:
    global _subscriber_task
    if _subscriber_task and not _subscriber_task.done():
        _subscriber_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await _subscriber_task
  
```

---

## File Overview

### Purpose and Responsibility

This Python source file, `ws.py`, is responsible for managing WebSocket connections and handling real-time data streaming within the CodeWorm application. It integrates with a Redis server to subscribe to specific channels (`codeworm:logs`, `codeworm:events`, `codeworm:stats`) and broadcasts received messages to connected clients.

### Key Exports and Public Interface

- **`ConnectionManager` Class**: Manages WebSocket connections, log buffers, and message broadcasting.
  - `connect(websocket)`: Accepts a new WebSocket connection and sends historical data if available.
  - `disconnect(websocket)`: Removes a WebSocket from the active list when it disconnects.
  - `broadcast(message)`: Broadcasts messages to all connected WebSockets or appends them to the log buffer.

- **`start_redis_subscriber()` Function**: Starts an asynchronous task that subscribes to Redis channels and broadcasts received messages.
- **`stop_redis_subscriber()` Function**: Cancels the running subscriber task if it exists.

- **`websocket_endpoint(websocket: WebSocket)`:** A WebSocket endpoint handler for `/ws`, managing connection lifecycle and handling simple "ping" requests.

### How It Fits into the Project

This file is a critical component of the CodeWorm backend, enabling real-time data streaming to clients. It integrates with other parts of the application by subscribing to Redis channels, which are used to stream logs, events, and stats in near-real time. The `ConnectionManager` class ensures that all connected WebSockets receive timely updates.

### Notable Design Decisions

- **Use of `orjson` for JSON Serialization**: Provides faster JSON serialization compared to Python's built-in `json`.
- **Asynchronous Task Management**: Uses asyncio tasks to manage the Redis subscriber, ensuring graceful shutdown.
- **Context Manager and Exception Handling**: Ensures that WebSocket connections are properly managed and cleaned up on disconnection or error.
- **Type Hints and Annotations**: Utilizes type hints and annotations for better code clarity and maintainability.

---

*Generated by CodeWorm on 2026-02-28 17:58*
