# api.config

**Type:** File Overview
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/frontend/src/core/api/api.config.ts
**Language:** typescript
**Lines:** 1-161
**Complexity:** 0.0

---

## Source Code

```typescript
// ===================
// Â© AngelaMos | 2025
// api.config.ts
// ===================

import axios, {
  type AxiosError,
  type AxiosInstance,
  type InternalAxiosRequestConfig,
} from 'axios'
import { API_ENDPOINTS, HTTP_STATUS } from '@/config'
import { useAuthStore } from '@/core/lib'
import { ApiError, ApiErrorCode, transformAxiosError } from './errors'

interface RequestConfig extends InternalAxiosRequestConfig {
  _retry?: boolean
}

interface RefreshSubscriber {
  resolve: (token: string) => void
  reject: (error: Error) => void
}

const getBaseURL = (): string => {
  return import.meta.env.VITE_API_URL ?? '/api'
}

export const apiClient: AxiosInstance = axios.create({
  baseURL: getBaseURL(),
  timeout: 15000,
  headers: { 'Content-Type': 'application/json' },
  withCredentials: true,
})

let isRefreshing = false
let refreshSubscribers: RefreshSubscriber[] = []

const processRefreshQueue = (error: Error | null, token: string | null): void => {
  refreshSubscribers.forEach((subscriber) => {
    if (error !== null) {
      subscriber.reject(error)
    } else if (token !== null) {
      subscriber.resolve(token)
    }
  })
  refreshSubscribers = []
}

const addRefreshSubscriber = (
  resolve: (token: string) => void,
  reject: (error: Error) => void
): void => {
  refreshSubscribers.push({ resolve, reject })
}

const handleTokenRefresh = async (): Promise<string> => {
  const response = await apiClient.post<{ access_token: string }>(
    API_ENDPOINTS.AUTH.REFRESH
  )

  if (
    response.data === null ||
    response.data === undefined ||
    typeof response.data !== 'object'
  ) {
    throw new ApiError(
      'Invalid refresh response',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  const accessToken = response.data.access_token
  if (typeof accessToken !== 'string' || accessToken.length === 0) {
    throw new ApiError(
      'Invalid access token',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  return accessToken
}

const handleAuthFailure = (): void => {
  useAuthStore.getState().logout()
  window.location.href = '/login'
}

apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig): InternalAxiosRequestConfig => {
    const token = useAuthStore.getState().accessToken
    if (token !== null && token.length > 0) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error: unknown): Promise<never> => {
    return Promise.reject(error)
  }
)

apiClient.interceptors.response.use(
  (response) => response,
  async (error: AxiosError): Promise<unknown> => {
    const originalRequest = error.config as RequestConfig | undefined

    if (originalRequest === undefined) {
      return Promise.reject(transformAxiosError(error))
    }

    const isUnauthorized = error.response?.status === HTTP_STATUS.UNAUTHORIZED
    const isNotRetried = originalRequest._retry !== true
    const isNotRefreshEndpoint =
      originalRequest.
```

---

## File Overview

# api.config.ts

**Purpose & Responsibility:**
This file configures and manages Axios instances for API requests, handling authentication tokens, refresh logic, and error transformations. It ensures secure and efficient communication with backend services.

**Key Exports & Public Interface:**
- `apiClient`: An Axios instance configured with base URL, headers, and interceptors.
- `handleTokenRefresh`: A utility function to handle token refreshing on unauthorized access.
- `processRefreshQueue`, `addRefreshSubscriber`: Functions for managing the refresh queue and subscribers.

**How it Fits in the Project:**
This file is a crucial part of the application's core API layer. It integrates with authentication logic from `useAuthStore` and handles HTTP requests, ensuring that all API calls are authenticated and errors are properly managed. The Axios instance is used throughout the project to make HTTP requests.

**Notable Design Decisions:**
1. **Token Refresh Handling:** Implements a queue for token refreshes to avoid multiple concurrent requests.
2. **Interceptor Setup:** Uses interceptors to add authentication headers and handle unauthorized responses, ensuring consistent behavior across API calls.
3. **Error Management:** Transforms Axios errors into custom `ApiError` instances, providing clear error codes and messages.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and significant design choices.

---

*Generated by CodeWorm on 2026-02-18 11:57*
