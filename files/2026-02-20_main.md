# main

**Type:** File Overview
**Repository:** timer-go
**File:** main.go
**Language:** go
**Lines:** 1-239
**Complexity:** 0.0

---

## Source Code

```go
/*
â’¸AngelaMos | 2025
main.go
*/

package main

import (
	"embed"
	"encoding/json"
	"log/slog"
	"net/http"
	"os"
	"sync"
	"time"
)

//go:embed static/index.html
var staticFiles embed.FS

type TimerState struct {
	StartTime     int64 `json:"start_time"`
	StoppedAt     int64 `json:"stopped_at"`
	OffsetSeconds int64 `json:"offset_seconds"`
	IsRunning     bool  `json:"is_running"`
}

type TimerResponse struct {
	IsRunning        bool   `json:"is_running"`
	ElapsedSeconds   int64  `json:"elapsed_seconds"`
	ElapsedFormatted string `json:"elapsed_formatted"`
}

type StartRequest struct {
	OffsetHours float64 `json:"offset_hours"`
}

var (
	state     TimerState
	stateMu   sync.RWMutex
	stateFile = "timer.json"
)

func loadState() error {
	stateMu.Lock()
	defer stateMu.Unlock()

	data, err := os.ReadFile(stateFile)
	if os.IsNotExist(err) {
		state = TimerState{}
		return nil
	}
	if err != nil {
		return err
	}
	return json.Unmarshal(data, &state)
}

func saveState() error {
	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(stateFile, data, 0644)
}

func getElapsed() int64 {
	if !state.IsRunning && state.StartTime == 0 {
		return state.OffsetSeconds
	}

	var elapsed int64
	if state.IsRunning {
		elapsed = time.Now().Unix() - state.StartTime
	} else {
		elapsed = state.StoppedAt - state.StartTime
	}
	return elapsed + state.OffsetSeconds
}

func formatElapsed(seconds int64) string {
	hours := seconds / 3600
	minutes := (seconds % 3600) / 60
	secs := seconds % 60

	result := ""
	if hours > 0 {
		result = string(rune('0'+hours/100)) + string(rune('0'+hours/10%10)) + string(rune('0'+hours%10))
		for len(result) > 1 && result[0] == '0' {
			result = result[1:]
		}
		result += ":"
	}

	if hours > 0 {
		result += string(rune('0'+minutes/10)) + string(rune('0'+minutes%10))
	} else {
		result += string(rune('0'+minutes/10)) + string(rune('0'+minutes%10))
	}
	result += ":"
	result += string(rune('0'+secs/10)) + string(rune('0'+secs%10))

	return result
}

func handleGetTimer(w http.ResponseWriter, r *http.Request) {
	stateMu.RLock()
	elapsed := getElapsed()
	running := state.IsRunning
	stateMu.RUnlock()

	resp := TimerResponse{
		IsRunning:        running,
		ElapsedSeconds:   elapsed,
		ElapsedFormatted: formatElapsed(elapsed),
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

func handleStart(w http.ResponseWriter, r *http.Request) {
	var req StartRequest
	if r.ContentLength > 0 {
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "invalid json", http.StatusBadRequest)
			return
		}
	}

	stateMu.Lock()
	defer stateMu.Unlock()

	if state.IsRunning {
		w.Header().Set("Content-Type", "application/json")
		_ = json.NewEncoder(w).Encode(map[string]string{"status": "already running"})
		return
	}

	now := time.Now().Unix()

	if state.StoppedAt > 0 {
		pausedDuration := state.StoppedAt - state.StartTime
		state.OffsetSeconds += pausedDuration
		st
```

---

## File Overview

# main.go

## Purpose and Responsibility
This Go source file serves as the entry point for a timer application, handling HTTP requests to manage a running timer state stored locally. It provides endpoints to start, stop, reset, and retrieve the current state of the timer.

## Key Exports and Public Interface
- `loadState() error`: Loads the timer state from a JSON file.
- `saveState() error`: Saves the timer state to a JSON file.
- `handleGetTimer(w http.ResponseWriter, r *http.Request)`: Handles GET requests to retrieve the current timer state.
- `handleStart(w http.ResponseWriter, r *http.Request)`: Handles POST requests to start or resume the timer with an optional offset.
- `handleStop(w http.ResponseWriter, r *http.Request)`: Handles requests to stop the running timer.
- `handleReset(w http.ResponseWriter, r *http.Request)`: Handles requests to reset the timer state.
- `handleIndex(w http.ResponseWriter, r *http.Request)`: Serves the static HTML file for the user interface.

## How It Fits in the Project
This file acts as the central controller, managing the lifecycle of the timer and handling all HTTP interactions. It integrates with a JSON storage mechanism to persist the timer state between sessions, ensuring that the application can resume from where it left off.

## Notable Design Decisions
- **State Management**: The `state` variable is protected by a mutex (`sync.RWMutex`) to ensure thread safety when accessing or modifying the timer state.
- **Error Handling**: Errors are logged using `slog`, and appropriate HTTP responses are returned to indicate failure scenarios, such as invalid JSON or file read/write issues.
- **HTTP Handlers**: Each handler function is designed to be self-contained, with clear responsibilities for starting/stopping/resetting the timer and serving static content.

---

*Generated by CodeWorm on 2026-02-20 18:46*
