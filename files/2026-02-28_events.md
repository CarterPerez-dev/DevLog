# events

**Type:** File Overview
**Repository:** CodeWorm
**File:** codeworm/core/events.py
**Language:** python
**Lines:** 1-98
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
core/events.py
"""
from __future__ import annotations

import threading
from datetime import datetime
from typing import Any

import orjson


_publisher: EventPublisher | None = None


class EventPublisher:
    CHANNEL_LOGS = "codeworm:logs"
    CHANNEL_EVENTS = "codeworm:events"
    CHANNEL_STATS = "codeworm:stats"

    def __init__(self, redis_url: str) -> None:
        import redis as redis_lib

        self._client = redis_lib.Redis.from_url(
            redis_url,
            decode_responses = False,
            socket_connect_timeout = 2,
            socket_timeout = 2,
        )
        self._lock = threading.Lock()
        self._connected = False
        self._check_connection()

    def _check_connection(self) -> bool:
        try:
            self._client.ping()
            self._connected = True
            return True
        except Exception:
            self._connected = False
            return False

    def _publish(self, channel: str, data: dict) -> None:
        if not self._connected and not self._check_connection():
            return
        try:
            payload = orjson.dumps(data, default = str)
            with self._lock:
                self._client.publish(channel, payload)
        except Exception:
            self._connected = False

    def publish_log(self, event_dict: dict) -> None:
        self._publish(self.CHANNEL_LOGS, event_dict)

    def publish_event(self, event_type: str, data: dict | None = None) -> None:
        payload = {
            "type": event_type,
            "timestamp": datetime.now().isoformat(),
            "data": data or {},
        }
        self._publish(self.CHANNEL_EVENTS, payload)

    def publish_stats(self, stats: dict) -> None:
        payload = {
            "timestamp": datetime.now().isoformat(),
            **stats,
        }
        self._publish(self.CHANNEL_STATS, payload)

    def close(self) -> None:
        try:  # noqa: SIM105
            self._client.close()
        except Exception:  # noqa: S110
            pass


def redis_log_processor(
    logger: Any,
    method_name: str,
    event_dict: dict,
) -> dict:
    publisher = get_publisher()
    if publisher is not None:
        publisher.publish_log(event_dict)
    return event_dict


def init_publisher(redis_url: str) -> EventPublisher:
    global _publisher
    _publisher = EventPublisher(redis_url)
    return _publisher


def get_publisher() -> EventPublisher | None:
    return _publisher

```

---

## File Overview

### Purpose and Responsibility

This Python source file, `events.py`, is responsible for managing event publishing to a Redis channel using an EventPublisher class. It ensures that log events, generic events with types and data, and statistical events are published reliably.

### Key Exports and Public Interface

- **EventPublisher**: A class for interacting with Redis to publish various types of events.
  - `CHANNEL_LOGS`, `CHANNEL_EVENTS`, `CHANNEL_STATS`: Constants representing different event channels.
  - `__init__`: Initializes the publisher with a Redis URL, establishing a connection.
  - `_check_connection`: Checks and maintains the connection status with Redis.
  - `_publish`: Publishes data to a specified channel after ensuring the connection is active.
  - `publish_log`, `publish_event`, `publish_stats`: Methods for publishing specific types of events.
  - `close`: Closes the Redis client connection.

- **redis_log_processor**: A function that processes log events and publishes them using the EventPublisher.

- **init_publisher**: Initializes a global EventPublisher instance with a given Redis URL.
- **get_publisher**: Returns the global EventPublisher instance if it exists, or `None` otherwise.

### How It Fits in the Project

This file is part of the core infrastructure layer in the CodeWorm project. It provides a centralized mechanism for logging and event publishing, ensuring that all components can communicate through Redis channels. This design enhances modularity and scalability by decoupling different parts of the application.

### Notable Design Decisions

- **Thread Safety**: The use of `threading.Lock` ensures that only one thread can publish to Redis at a time.
- **Connection Management**: The `_check_connection` method maintains the connection status, retrying if necessary.
- **Error Handling**: Graceful handling of exceptions during publishing and connection checks.
- **Global Publisher Instance**: A single global instance of `EventPublisher` is used for all event publications, promoting consistency and reducing redundancy.

---

*Generated by CodeWorm on 2026-02-28 18:00*
