# photo

**Type:** File Overview
**Repository:** angelamos-operations
**File:** CarterBot-Telegram/src/handlers/photo.ts
**Language:** typescript
**Lines:** 1-153
**Complexity:** 0.0

---

## Source Code

```typescript
/**
 * CarterOS Telegram Bot - Photo Handler
 *
 * Handles single photos and media groups (albums).
 */

import type { Context } from "grammy";
import { session } from "../session";
import { ALLOWED_USERS, TEMP_DIR } from "../config";
import { isAuthorized, startTypingIndicator } from "../utils";
import { StreamingState, createStatusCallback } from "./streaming";
import { createMediaGroupBuffer, handleProcessingError } from "./media-group";

const photoBuffer = createMediaGroupBuffer({
  itemLabel: "photo",
  itemLabelPlural: "photos",
});

async function downloadPhoto(ctx: Context): Promise<string> {
  const photos = ctx.message?.photo;
  if (!photos || photos.length === 0) {
    throw new Error("No photo in message");
  }

  const file = await ctx.getFile();
  const timestamp = Date.now();
  const random = Math.random().toString(36).slice(2, 8);
  const photoPath = `${TEMP_DIR}/photo_${timestamp}_${random}.jpg`;

  const response = await fetch(
    `https://api.telegram.org/file/bot${ctx.api.token}/${file.file_path}`
  );
  const buffer = await response.arrayBuffer();
  await Bun.write(photoPath, buffer);

  return photoPath;
}

async function processPhotos(
  ctx: Context,
  photoPaths: string[],
  caption: string | undefined,
  userId: number,
  username: string,
  chatId: number
): Promise<void> {
  const stopProcessing = session.startProcessing();

  let prompt: string;
  if (photoPaths.length === 1) {
    prompt = caption
      ? `[Photo: ${photoPaths[0]}]\n\n${caption}`
      : `Please analyze this image: ${photoPaths[0]}`;
  } else {
    const pathsList = photoPaths.map((p, i) => `${i + 1}. ${p}`).join("\n");
    prompt = caption
      ? `[Photos:\n${pathsList}]\n\n${caption}`
      : `Please analyze these ${photoPaths.length} images:\n${pathsList}`;
  }

  const typing = startTypingIndicator(ctx);
  const state = new StreamingState();
  const statusCallback = createStatusCallback(ctx, state);

  try {
    await session.sendMessageStreaming(
      prompt,
      username,
      userId,
      statusCallback,
      chatId,
      ctx
    );
  } catch (error) {
    await handleProcessingError(ctx, error, state.toolMessages);
  } finally {
    stopProcessing();
    typing.stop();
  }
}

export async function handlePhoto(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username || "unknown";
  const chatId = ctx.chat?.id;
  const mediaGroupId = ctx.message?.media_group_id;

  if (!userId || !chatId) {
    return;
  }

  if (!isAuthorized(userId, ALLOWED_USERS)) {
    await ctx.reply("Unauthorized. Contact the bot owner for access.");
    return;
  }

  let statusMsg: Awaited<ReturnType<typeof ctx.reply>> | null = null;
  if (!mediaGroupId) {
    console.log(`Received photo from @${username}`);
    statusMsg = await ctx.reply("Processing image...");
  }

  let photoPath: string;
  try {
    photoPath = await downloadPhoto(ctx);
  } catch (error) {
    console.error("Failed to download photo:", error);
  
```

---

## File Overview

### Photo Handler for CarterOS Telegram Bot

**Purpose and Responsibility:**
This file handles single photos and media groups (albums) in the CarterOS Telegram bot. It ensures that authorized users can upload images, which are then processed using a streaming session to analyze them.

**Key Exports or Public Interface:**
- `handlePhoto`: The main entry point for processing photo messages.
- `processPhotos`: Processes individual photos or media groups and sends analysis prompts to the streaming session.
- `downloadPhoto`: Downloads and saves the photo from Telegram to a temporary directory.

**How It Fits in the Project:**
This file is part of the broader messaging handling system within CarterOS. It integrates with other handlers and utilities to manage user interactions, authentication, and media processing. The `handlePhoto` function acts as a gateway, invoking specific logic based on whether a single photo or a media group has been received.

**Notable Design Decisions:**
- **Session Management**: Utilizes the `session` module for managing streaming sessions, ensuring that image analysis is done in chunks to handle large files.
- **Error Handling and Feedback**: Provides clear feedback to users via Telegram messages if an error occurs during photo processing or download.
- **Authorization Check**: Ensures only authorized users can interact with the bot by checking against `ALLOWED_USERS` in the configuration.
```

This documentation provides a high-level overview of the file's purpose, key functions, integration within the project, and important design choices.

---

*Generated by CodeWorm on 2026-02-19 20:11*
