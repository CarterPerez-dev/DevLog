# github

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** frontend/src/services/github.ts
**Language:** typescript
**Lines:** 1-468
**Complexity:** 0.0

---

## Source Code

```typescript
/*
 * Â©AngelaMos | 2025
 */

import { apiClient } from './api';
import type {
  Repository,
  RepositoryDetailed,
  RepositoryFilter,
} from '../hooks/useGitHub';

interface RepositoryResponse {
  repositories: Repository[];
  pagination: {
    current_page: number;
    per_page: number;
    total_pages: number;
    total_count: number;
    has_next_page: boolean;
    has_previous_page: boolean;
  };
  statistics: {
    total_stars: number;
    total_forks: number;
    average_stars: number;
    most_starred_repo: string;
    language_count: number;
    topics_count: number;
  };
  rate_limit: {
    limit: number;
    remaining: number;
    reset_at: string;
    percentage_used: number;
  };
}

interface LanguageDistribution {
  languages: Array<{
    name: string;
    repository_count: number;
    total_size_kb: number;
    percentage: number;
    average_stars: number;
  }>;
  summary: {
    total_languages: number;
    total_repositories_analyzed: number;
    most_used_language?: string;
    language_diversity_score: number;
  };
}

class GitHubService {
  private cache: Map<string, { data: any; timestamp: number; ttl: number }>;
  private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes

  constructor() {
    this.cache = new Map();

    // I'm setting up cache cleanup to prevent memory leaks
    setInterval(() => this.cleanupCache(), 60000); // Cleanup every minute
  }

  private cleanupCache() {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        this.cache.delete(key);
      }
    }
  }

  private getCacheKey(
    endpoint: string,
    params?: Record<string, any>,
  ): string {
    const paramString = params ? JSON.stringify(params) : '';
    return `${endpoint}:${paramString}`;
  }

  private getFromCache<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const now = Date.now();
    if (now - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  private setCache<T>(key: string, data: T, ttl: number = this.DEFAULT_TTL) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl,
    });
  }

  async getRepositories(
    params: {
      page?: number;
      per_page?: number;
      sort?: string;
      direction?: string;
      language?: string;
      min_stars?: number;
      max_stars?: number;
      is_fork?: boolean;
      is_archived?: boolean;
      search?: string;
    } = {},
  ): Promise<RepositoryResponse> {
    const cacheKey = this.getCacheKey('/api/github/repos', params);

    // I'm checking cache first for performance optimization
    const cached = this.getFromCache<RepositoryResponse>(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      const queryParams = new URLSearchParams();

      // I'm building query parameters with proper type conversion
      Object.entries(params).forEach(([ke
```

---

## File Overview

### GitHubService.ts

**Purpose and Responsibility:**
This file contains the `GitHubService` class, which handles interactions with the GitHub API to fetch repositories, detailed repository information, and statistics. It ensures efficient caching of responses based on rate limits to optimize performance.

**Key Exports or Public Interface:**
- **getRepositories(params): Promise<RepositoryResponse>**: Fetches a list of repositories with optional filtering parameters.
- **getRepositoryDetails(owner, name): Promise<RepositoryDetailed>**: Retrieves detailed information about a specific repository.
- **getRepositoryStats(owner, name): Promise<any>**: Fetches statistics for a given repository.

**How it Fits in the Project:**
This service is part of the frontend layer and interacts with the `apiClient` to make HTTP requests. It provides essential functionality for displaying and managing GitHub repositories within the application. The cached responses help reduce API calls, especially when dealing with frequent data retrieval.

**Notable Design Decisions:**
- **Caching Mechanism**: Implements a caching strategy that respects rate limits by adjusting cache TTLs dynamically.
- **Rate Limit Handling**: Ensures that the service operates efficiently by reducing redundant API requests based on remaining rate limit.
- **Error Handling**: Logs errors and rethrows them, maintaining consistency in error management across the application.
```

This documentation covers the high-level purpose of the file, its key exports, how it integrates into the project, and important design decisions.

---

*Generated by CodeWorm on 2026-02-19 20:37*
