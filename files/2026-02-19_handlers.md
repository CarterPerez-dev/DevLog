# handlers

**Type:** File Overview
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/api/handlers.go
**Language:** go
**Lines:** 1-292
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
handlers.go
*/

package api

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"

	"github.com/carterperez-dev/holophyly/internal/model"
	"github.com/carterperez-dev/holophyly/internal/project"
)

type Handler struct {
	manager *project.Manager
	logger  *slog.Logger
}

// NewHandler creates an API handler with the project manager.
func NewHandler(manager *project.Manager, logger *slog.Logger) *Handler {
	return &Handler{
		manager: manager,
		logger:  logger,
	}
}

func (h *Handler) ListProjects(w http.ResponseWriter, r *http.Request) {
	if err := h.manager.Refresh(r.Context()); err != nil {
		h.logger.Error("failed to refresh projects", "error", err)
	}

	projects := h.manager.ListProjects()
	respondJSON(w, http.StatusOK, projects)
}

func (h *Handler) GetProject(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")

	proj, err := h.manager.GetProject(id)
	if err != nil {
		respondError(w, http.StatusNotFound, "project not found")
		return
	}

	respondJSON(w, http.StatusOK, proj)
}

func (h *Handler) StartProject(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")

	if err := h.manager.StartProject(r.Context(), id); err != nil {
		h.logger.Error("failed to start project", "id", id, "error", err)
		respondError(w, http.StatusInternalServerError, err.Error())
		return
	}

	proj, _ := h.manager.GetProject(id)
	respondJSON(w, http.StatusOK, proj)
}

func (h *Handler) StopProject(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	force := r.URL.Query().Get("force") == "true"

	if err := h.manager.StopProject(r.Context(), id, force); err != nil {
		status := http.StatusInternalServerError
		if !force {
			proj, _ := h.manager.GetProject(id)
			if proj != nil && proj.Protected {
				status = http.StatusForbidden
			}
		}
		h.logger.Error("failed to stop project", "id", id, "error", err)
		respondError(w, status, err.Error())
		return
	}

	proj, _ := h.manager.GetProject(id)
	respondJSON(w, http.StatusOK, proj)
}

func (h *Handler) RestartProject(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")

	if err := h.manager.RestartProject(r.Context(), id); err != nil {
		h.logger.Error("failed to restart project", "id", id, "error", err)
		respondError(w, http.StatusInternalServerError, err.Error())
		return
	}

	proj, _ := h.manager.GetProject(id)
	respondJSON(w, http.StatusOK, proj)
}

func (h *Handler) SetProjectProtection(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")

	var req struct {
		Protected bool   `json:"protected"`
		Reason    string `json:"reason,omitempty"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, "invalid request body")
		return
	}

	reason := model.ProtectionUserMarked
	if req.Reason != "" {
		reason = model.ProtectionReason(req.Reason)
	}

	if err := h.manager.SetProjectProtection(id, req.Protected, reason); err != nil {
```

---

## File Overview

### handlers.go

**Purpose and Responsibility:**
This file defines the API handlers for managing projects within the Holophyly application. It handles operations such as listing, getting, starting, stopping, restarting, protecting, renaming, hiding, and retrieving statistics of projects.

**Key Exports and Public Interface:**
- `Handler`: A struct that encapsulates project management logic.
- Various handler methods (`ListProjects`, `GetProject`, `StartProject`, etc.) for handling HTTP requests related to project operations.

**How It Fits in the Project:**
This file is a crucial component of the API layer, providing an interface for external interactions with the project management system. It leverages the `project.Manager` to perform operations and returns responses via HTTP. The handlers are registered as routes within the Chi router, allowing them to be accessed over HTTP.

**Notable Design Decisions:**
- **Error Handling:** Errors are logged using `slog`, and appropriate HTTP status codes are returned based on the nature of the error.
- **Dependency Injection:** The `Handler` struct is initialized with a `project.Manager` instance and a logger, promoting loose coupling and testability.
- **JSON Decoding:** Request bodies are decoded into structured data to handle different types of requests, such as setting project protection or display name.
- **Context Management:** Operations that require context (like refreshing projects) use the provided context from HTTP requests.
```

This documentation provides a high-level overview of the file's purpose, key components, and design choices.

---

*Generated by CodeWorm on 2026-02-19 18:51*
