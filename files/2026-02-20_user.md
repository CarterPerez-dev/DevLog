# User

**Type:** File Overview
**Repository:** vuemantics
**File:** backend/models/User.py
**Language:** python
**Lines:** 1-320
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
User model for authentication and user management
User.py
"""

from __future__ import annotations

from typing import Any
from uuid import UUID

from asyncpg import UniqueViolationError

import config
import database
from models.Base import BaseModel


class User(BaseModel):
    """
    User model for authentication

    Attributes:
        id: Unique identifier (UUID)
        email: Unique email address
        password_hash: Bcrypt hashed password
        is_active: Whether user account is active
        created_at: Timestamp of account creation
        updated_at: Timestamp of last update
    """
    __tablename__ = "users"

    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize user instance.
        """
        super().__init__(**kwargs)
        self.id: UUID = kwargs["id"]  # Users from DB always have IDs
        self.email: str = kwargs.get("email", "")
        self.password_hash: str = kwargs.get("password_hash", "")
        self.is_active: bool = kwargs.get("is_active", True)
        self.token_version: int = kwargs.get("token_version", 0)

    @classmethod
    async def create_table(cls) -> None:
        """
        Create users table with indexes.
        """
        query = """
            CREATE TABLE IF NOT EXISTS users (
                id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
                email VARCHAR(255) UNIQUE NOT NULL,
                password_hash VARCHAR(255) NOT NULL,
                is_active BOOLEAN DEFAULT TRUE,
                token_version INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW()
            );

            CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
            CREATE INDEX IF NOT EXISTS idx_users_is_active ON users(is_active);
        """

        await database.db.execute(query)

    @classmethod
    async def create(
        cls,
        email: str,
        password_hash: str,
        is_active: bool = True
    ) -> User:
        """
        Create a new user
        """
        await cls.ensure_table_exists()

        query = """
            INSERT INTO users (email, password_hash, is_active)
            VALUES ($1, $2, $3)
            RETURNING *
        """

        try:
            record = await database.db.fetchrow(
                query,
                email.lower(),
                password_hash,
                is_active
            )
            if record is None:
                raise ValueError("Failed to create user")
            user = cls.from_record(record)
            if user is None:
                raise ValueError("Failed to create user from record")
            return user
        except UniqueViolationError as e:
            raise ValueError(
                f"User with email {email} already exists"
            ) from e

    @classmethod
    async def find_by_email(cls, email: str) -> User | None:
        """
        Find user by email addres
```

---

## File Overview

### User.py

**Purpose and Responsibility:**
This Python file defines the `User` model for managing user accounts within the application. It handles creation, retrieval, and updating of user records in the database.

**Key Exports and Public Interface:**
- **Class `User`:** Represents a user entity with attributes like `id`, `email`, `password_hash`, etc.
  - Methods:
    - `__init__`: Initializes a user instance.
    - `create_table`: Creates or ensures the users table exists in the database.
    - `create`: Creates a new user entry.
    - `find_by_email`: Finds a user by email address.
    - `find_active_by_email`: Finds an active user by email address.
    - `get_all_active`: Retrieves all active users with pagination.

**How it Fits into the Project:**
The `User` model is central to authentication and user management. It interacts with the database through `asyncpg` for CRUD operations and ensures data integrity via unique constraints and indexes. This class is part of a larger module that handles user-related functionalities, contributing to the overall security and functionality of the application.

**Notable Design Decisions:**
- **Type Hints:** Utilizes Python type hints for better code clarity and maintainability.
- **Database Interaction:** Uses `asyncpg` for asynchronous database operations, ensuring non-blocking I/O.
- **Indexes:** Ensures efficient querying by creating indexes on critical fields like `email` and `is_active`.
- **Error Handling:** Implements robust error handling to manage unique constraint violations and other potential issues.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and significant design choices.

---

*Generated by CodeWorm on 2026-02-20 12:38*
