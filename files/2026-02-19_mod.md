# mod

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/database/mod.rs
**Language:** rust
**Lines:** 1-271
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Database module aggregator providing centralized access to all database-related functionality for the dark performance showcase.
 * I'm organizing connection management, migration utilities, and database operations into a clean, cohesive interface that supports the high-performance architecture.
 */

pub mod connection;

// Re-export commonly used database types and functions
pub use connection::{
    DatabasePool,
    DatabaseManager,
    DatabaseHealthStatus,
    DatabaseStats,
    create_pool,
    create_pool_with_config,
    with_transaction,
    batch_execute,
    ConnectionPoolMonitor
};

use crate::utils::error::{AppError, Result};
use sqlx::Row;

/// Database utilities and helper functions for common operations
/// I'm providing convenient database operations that maintain consistency across the application
pub struct DatabaseUtils;

impl DatabaseUtils {
    /// Check if a table exists in the database
    /// I'm implementing table existence checking for dynamic schema operations
    pub async fn table_exists(pool: &DatabasePool, table_name: &str) -> Result<bool> {
        let result = sqlx::query(
            "SELECT EXISTS (
                SELECT FROM information_schema.tables
                WHERE table_schema = 'public'
                AND table_name = $1
            )"
        )
        .bind(table_name)
        .fetch_one(pool)
        .await?;

        let exists: bool = result.try_get("exists")?;
        Ok(exists)
    }

    /// Get database version information
    /// I'm providing database version checking for compatibility verification
    pub async fn get_database_version(pool: &DatabasePool) -> Result<String> {
        let result = sqlx::query("SELECT version() as db_version")
            .fetch_one(pool)
            .await?;

        let version: String = result.try_get("db_version")?;
        Ok(version)
    }

    /// Get database size in bytes
    /// I'm implementing database size monitoring for resource tracking
    pub async fn get_database_size(pool: &DatabasePool) -> Result<i64> {
        let result = sqlx::query(
            "SELECT pg_database_size(current_database()) as size_bytes"
        )
        .fetch_one(pool)
        .await?;

        let size: i64 = result.try_get("size_bytes")?;
        Ok(size)
    }

    /// Clean up expired cache entries and performance data
    /// I'm implementing automated cleanup for maintaining database performance
    pub async fn cleanup_expired_data(pool: &DatabasePool) -> Result<u64> {
        let mut total_cleaned = 0u64;

        // Clean expired cache entries
        let cache_result = sqlx::query(
            "DELETE FROM cache_entries WHERE expires_at < NOW()"
        )
        .execute(pool)
        .await?;
        total_cleaned += cache_result.rows_affected();

        // Clean old performance metrics (keep last 30 days)
        let metrics_result = sqlx::query(
            "DELETE FROM performance_metrics WHERE timestamp < NOW() - INTERVAL '30 days'"
        )
```

---

## File Overview

# Database Module Documentation

## Purpose and Responsibility
This module serves as a central hub for all database-related functionality, providing a clean and cohesive API for managing connections, executing queries, and monitoring database health and performance. It integrates with the `connection` module to manage database pools and handles common operations like table existence checks, version verification, size monitoring, and cleanup of expired data.

## Key Exports and Public Interface
- **DatabasePool**: A connection pool for managing database connections.
- **DatabaseManager**: Manages the lifecycle of database connections.
- **DatabaseHealthStatus**: Represents the health status of a database.
- **DatabaseStats**: Provides statistics about the database state.
- **create_pool** and `create_pool_with_config`: Functions to initialize database pools with or without custom configurations.
- **with_transaction**, `batch_execute`: Utility functions for executing transactions and batch operations.
- **DatabaseUtils**: A struct containing helper methods for common database operations.

## How It Fits into the Project
This module is a critical component of the project, ensuring that all database interactions are consistent and efficient. By centralizing database management, it supports the high-performance architecture of the dark performance showcase application, making it easier to manage connections, execute queries, and monitor database health and performance.

## Notable Design Decisions
- **Result/Option Patterns**: All public methods return `Result` or `Option`, ensuring robust error handling.
- **Lifetimes**: Proper use of lifetimes in method signatures to prevent dangling references.
- **Ownership and Borrowing**: Methods are designed to work with owned resources, reducing the risk of memory leaks.
- **SQLx for Database Operations**: Utilizes SQLx for database interactions, providing a safe and efficient way to execute queries and manage transactions.

This module is essential for maintaining the integrity and performance of the application's database operations.

---

*Generated by CodeWorm on 2026-02-19 21:59*
