# mod

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/models/mod.rs
**Language:** rust
**Lines:** 1-317
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Models module aggregator organizing all data structures and business logic entities for the dark performance showcase backend.
 * I'm providing a clean interface to GitHub repository data, fractal computation parameters, and performance metrics with comprehensive serialization and validation support.
 */

pub mod github;
pub mod fractals;
pub mod performance;

// Re-export commonly used models for convenient access throughout the application
pub use github::{
    Repository,
    RepositoryDetailed,
    RepositoryStats,
    GitHubUser,
    RepositoryFilter,
    RepositoryCollection,
    CollectionStats,
    LanguageStats,
    RateLimitInfo,
    calculate_collection_stats
};

pub use fractals::{
    FractalRequest,
    FractalResponse,
    FractalType,
    FractalParameters,
    FractalMetadata,
    FractalComputationLog,
    BenchmarkRequest,
    BenchmarkResponse
};

pub use performance::{
    PerformanceMetric,
    SystemInfo,
    BenchmarkResult,
    MetricType,
    MetricValue,
    SystemSnapshot,
    PerformanceAlert,
    ResourceUsage
};

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// Common pagination structure used across all API responses
/// I'm providing consistent pagination handling for all list endpoints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Pagination {
    pub current_page: i32,
    pub per_page: i32,
    pub total_pages: i32,
    pub total_count: i32,
    pub has_next_page: bool,
    pub has_previous_page: bool,
}

impl Pagination {
    pub fn new(current_page: i32, per_page: i32, total_count: i32) -> Self {
        let total_pages = ((total_count as f64) / (per_page as f64)).ceil() as i32;

        Self {
            current_page,
            per_page,
            total_pages,
            total_count,
            has_next_page: current_page < total_pages,
            has_previous_page: current_page > 1,
        }
    }
}

/// Standard API response wrapper for consistent response formatting
/// I'm implementing consistent API response structure across all endpoints
#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub data: T,
    pub pagination: Option<Pagination>,
    pub metadata: Option<serde_json::Value>,
    pub timestamp: DateTime<Utc>,
    pub request_duration_ms: Option<u128>,
}

impl<T> ApiResponse<T> {
    pub fn new(data: T) -> Self {
        Self {
            data,
            pagination: None,
            metadata: None,
            timestamp: Utc::now(),
            request_duration_ms: None,
        }
    }

    pub fn with_pagination(mut self, pagination: Pagination) -> Self {
        self.pagination = Some(pagination);
        self
    }

    pub fn with_metadata(mut self, metadata: serde_json::Value) -> Self {
        self.metadata = Some(metadata);
        self
    }

    pub fn with_duration(mut self, duration_ms: u128) -> Self {
        self.request_duration_ms = Some(duration_ms);
        self
    }
}

/// Health check response struct
```

---

## File Overview

# Models Module Documentation

## Purpose and Responsibility
This module serves as a central hub for organizing all data structures, business logic entities, and common utilities used across the backend of the `kill-pr0cess.inc` repository's dark performance showcase application. It provides clean interfaces for handling GitHub repository data, fractal computation parameters, and performance metrics.

## Key Exports and Public Interface
- **Common Models**: Re-exports commonly used models like `Repository`, `FractalRequest`, `PerformanceMetric`, etc., for convenient access throughout the application.
- **Pagination and API Responses**: Defines a consistent pagination structure and standardizes API response wrappers to ensure uniform handling of list endpoints.
- **Health Check Response**: Provides standardized health check information across all services.
- **Sorting and Filtering Options**: Offers reusable sorting and filtering functionality.

## How It Fits in the Project
This module acts as a core component, ensuring that data structures and business logic are well-defined and consistent. It is imported by various parts of the application to handle different types of data and operations, making it easier to maintain and extend the backend functionalities.

## Notable Design Decisions
- **Serde Integration**: Utilizes `serde` for serialization and deserialization to facilitate easy JSON handling.
- **Pagination Handling**: Implements a robust pagination mechanism with consistent structure across all list endpoints.
- **Health Check Standardization**: Provides a standardized health check response format to monitor system status effectively.
- **Common Utility Functions**: Includes utility functions like sorting, filtering, and API response construction for reusability.

---

*Generated by CodeWorm on 2026-02-19 22:39*
