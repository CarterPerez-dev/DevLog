# mod

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/services/mod.rs
**Language:** rust
**Lines:** 1-416
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Services module aggregator providing centralized access to all business logic services for the dark performance showcase.
 * I'm organizing GitHub API integration, fractal computation, performance monitoring, and caching into a cohesive service layer that maintains clean separation of concerns.
 */

pub mod fractal_service;
pub mod github_service;
pub mod performance_service;
pub mod cache_service;

// Re-export all services for convenient access throughout the application
pub use fractal_service::FractalService;
pub use github_service::GitHubService;
pub use performance_service::PerformanceService;
pub use cache_service::CacheService;

use crate::{
    database::DatabasePool,
    utils::error::{AppError, Result},
};
use std::sync::Arc;
use tokio::sync::RwLock;

/// Service registry for centralized service management and dependency injection
/// I'm implementing a service registry pattern for clean dependency management
pub struct ServiceRegistry {
    pub fractal_service: Arc<FractalService>,
    pub github_service: Arc<GitHubService>,
    pub performance_service: Arc<PerformanceService>,
    pub cache_service: Arc<CacheService>,
}

impl ServiceRegistry {
    /// Create a new service registry with all services initialized
    /// I'm ensuring all services are properly configured and connected
    pub async fn new(
        db_pool: DatabasePool,
        redis_client: redis::Client,
        github_token: String,
    ) -> Result<Self> {
        tracing::info!("Initializing service registry");

        // Initialize cache service first as other services depend on it
        let cache_service = Arc::new(CacheService::with_config(
            redis_client,
            "perf_showcase:".to_string(),
            3600, // 1 hour default TTL
        ));

        // Initialize GitHub service with cache dependency
        let github_service = Arc::new(GitHubService::new(
            github_token.clone(),
            (*cache_service).clone(),
        ));

        // Initialize fractal service (no external dependencies)
        let fractal_service = Arc::new(FractalService::new());

        // Initialize performance service with database dependency
        let performance_service = Arc::new(PerformanceService::new(db_pool.clone()));

        tracing::info!("All services initialized successfully");

        Ok(Self {
            fractal_service,
            github_service,
            performance_service,
            cache_service,
        })
    }

    /// Perform health checks on all services
    /// I'm implementing comprehensive service health verification
    pub async fn health_check(&self) -> Result<serde_json::Value> {
        let mut health_results = serde_json::Map::new();

        // Check cache service health
        match self.cache_service.health_check().await {
            Ok(cache_health) => {
                health_results.insert("cache".to_string(), cache_health);
            }
            Err(e) => {
                health_results.inser
```

---

## File Overview

---
Services module aggregator providing centralized access to all business logic services for the dark performance showcase.

### Purpose and Responsibility
This file is responsible for aggregating and managing various services that are crucial for the application's functionality, including fractal computation, GitHub API integration, performance monitoring, and caching. It ensures clean separation of concerns by encapsulating each service into its own module while providing a unified interface through a `ServiceRegistry`.

### Key Exports and Public Interface
- **ServiceRegistry**: A struct that holds instances of all services (FractalService, GitHubService, PerformanceService, CacheService) wrapped in `Arc` and `RwLock` for thread safety.
- **Public Methods**:
  - `new`: Initializes the service registry with necessary dependencies like database pool and Redis client.
  - `health_check`: Performs comprehensive health checks on all services.

### How It Fits into the Project
This module acts as a central hub, ensuring that different parts of the application can interact with these services seamlessly. By organizing services in this way, it promotes modularity and makes the codebase easier to maintain and extend.

### Notable Design Decisions
- **Service Registry Pattern**: Implements a service registry for centralized management and dependency injection.
- **Thread Safety**: Uses `Arc` and `RwLock` to ensure thread-safe access to services.
- **Health Checks**: Comprehensive health checks are implemented to monitor the status of each service, ensuring the application can respond appropriately if any service fails.

Dependencies include:
- `database::DatabasePool`
- `utils::error::{AppError, Result}`
- `std::sync::Arc`
- `tokio::sync::RwLock`
- `redis::Client`

This design ensures that services are properly initialized and managed, providing a robust foundation for the application's functionality.
---

---

*Generated by CodeWorm on 2026-02-19 21:17*
