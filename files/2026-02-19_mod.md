# mod

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/utils/mod.rs
**Language:** rust
**Lines:** 1-482
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Â©AngelaMos | 2025
 */


pub mod config;
pub mod error;
pub mod metrics;

pub use config::Config;
pub use error::{AppError, Result, ErrorContext, ResultExt};
pub use metrics::{MetricsCollector, PerformanceTimer, TimingGuard};

use serde::{Deserialize, Serialize};
use tracing::{info, warn};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use chrono::{DateTime, Utc};

pub struct Utils;

impl Utils {
    pub fn generate_correlation_id() -> String {
        uuid::Uuid::new_v4().to_string()
    }

    pub fn current_timestamp() -> DateTime<Utc> {
        Utc::now()
    }

    pub fn current_unix_timestamp() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs()
    }

    pub fn current_timestamp_millis() -> u128 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis()
    }

    pub fn format_duration(duration: Duration) -> String {
        let seconds = duration.as_secs();
        let millis = duration.subsec_millis();

        if seconds >= 3600 {
            let hours = seconds / 3600;
            let minutes = (seconds % 3600) / 60;
            let secs = seconds % 60;
            format!("{}h {}m {}s", hours, minutes, secs)
        } else if seconds >= 60 {
            let minutes = seconds / 60;
            let secs = seconds % 60;
            format!("{}m {}s", minutes, secs)
        } else if seconds > 0 {
            format!("{}.{:03}s", seconds, millis)
        } else {
            format!("{}ms", millis)
        }
    }

    pub fn format_bytes(bytes: u64) -> String {
        const UNITS: &[&str] = &["B", "KB", "MB", "GB", "TB", "PB"];

        if bytes == 0 {
            return "0 B".to_string();
        }

        let base = 1024_f64;
        let size = bytes as f64;
        let index = (size.ln() / base.ln()).floor() as usize;
        let index = index.min(UNITS.len() - 1);

        let size_in_unit = size / base.powi(index as i32);

        if index == 0 {
            format!("{} {}", bytes, UNITS[index])
        } else {
            format!("{:.1} {}", size_in_unit, UNITS[index])
        }
    }

     pub fn parse_size(size_str: &str) -> std::result::Result<u64, AppError> {
        let size_str = size_str.trim().to_uppercase();

        if size_str.is_empty() {
            return Err(AppError::ConfigurationError("Empty size string".to_string()));
        }

        let (number_part, unit_part) = if size_str.ends_with("B") {
            let without_b = &size_str[..size_str.len() - 1];
            if let Some(pos) = without_b.chars().position(|c| c.is_alphabetic()) {
                (&without_b[..pos], &without_b[pos..])
            } else {
                (without_b, "")
            }
        } else {
            if let Some(pos) = size_str.chars().position(|c| c.is_alphabetic()) {
                (&size_str[..pos], &size_str[pos..])
            } else {
                (size
```

---

## File Overview

# utils/mod.rs Documentation

## Purpose and Responsibility
This file contains utility functions that provide common functionality across the application, such as generating IDs, handling timestamps, formatting data, parsing sizes, logging sanitization, and calculating percentiles.

## Key Exports and Public Interface
- **Correlation ID Generation**: `generate_correlation_id`
- **Timestamps**: `current_timestamp`, `current_unix_timestamp`, `current_timestamp_millis`
- **Duration Formatting**: `format_duration`
- **Byte Size Formatting**: `format_bytes`
- **Size Parsing**: `parse_size`
- **String Truncation and Sanitization**: `truncate_string`, `sanitize_for_log`
- **Percentile Calculation**: `calculate_percentile`
- **Random String Generation**: `generate_random_string`

## How It Fits in the Project
This module serves as a central repository for utility functions that are used across various components of the application. These utilities enhance code readability, maintainability, and consistency by providing standardized implementations.

## Notable Design Decisions
1. **Error Handling**: Functions use custom `AppError` to handle configuration errors gracefully.
2. **Performance Considerations**: Efficient string manipulation and parsing techniques are employed to ensure performance.
3. **Logging Safety**: The `sanitize_for_log` function ensures that sensitive data is safely sanitized before logging, preventing potential security issues.
4. **Flexibility**: Functions like `parse_size` and `calculate_percentile` offer flexibility by supporting various input formats and edge cases.

---

*Generated by CodeWorm on 2026-02-19 22:20*
