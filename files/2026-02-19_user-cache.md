# user_cache

**Type:** File Overview
**Repository:** CertGames-Core
**File:** backend/api/core/auth/user_cache.py
**Language:** python
**Lines:** 1-116
**Complexity:** 0.0

---

## Source Code

```python
"""
User caching layer for auth_required decorator
/api/core/auth/user_cache.py
"""

from __future__ import annotations

import base64
import pickle
from typing import Any, TYPE_CHECKING
from contextlib import suppress
from flask import current_app

if TYPE_CHECKING:
    from api.domains.account.models.User import User


USER_CACHE_TTL = 300
USER_CACHE_PREFIX = "user_cache"


def _get_redis() -> Any | None:
    """
    Get Redis client from Flask app extensions
    """
    try:
        return current_app.extensions.get("redis_client")
    except RuntimeError:
        return None


def _get_cache_key(user_id: str) -> str:
    """
    Generate cache key for user
    """
    return f"{USER_CACHE_PREFIX}:{user_id}"


def get_cached_user(user_id: str) -> User | None:
    """
    Retrieve cached user from Redis - NO MongoDB query on cache hit
    Returns None if cache miss, allowing fallback to MongoDB
    """
    from api.domains.account.models.User import User

    redis_client = _get_redis()
    if not redis_client:
        return None

    try:
        cache_key = _get_cache_key(user_id)
        cached_b64 = redis_client.get(cache_key)

        if not cached_b64:
            return None

        pickled_data = base64.b64decode(cached_b64)
        user_data = pickle.loads(pickled_data)

        user = User()
        user.id = user_data.get('_id')

        for key, value in user_data.items():
            if key not in ['_id', 'id'] and hasattr(user, key):
                with suppress(Exception):
                    setattr(user, key, value)

        user._from_cache = True  # pylint: disable=protected-access
        return user

    except Exception as e:
        current_app.logger.warning(
            f"User cache read failed for {user_id}: {e}"
        )
        return None


def cache_user(user: User) -> None:
    """
    Cache user object in Redis using pickle + base64
    """
    redis_client = _get_redis()
    if not redis_client or not user:
        return

    try:
        cache_key = _get_cache_key(str(user.id))
        user_data = user.to_mongo().to_dict()

        pickled = pickle.dumps(user_data)
        b64_encoded = base64.b64encode(pickled).decode('utf-8')

        redis_client.setex(cache_key, USER_CACHE_TTL, b64_encoded)

    except Exception as e:
        current_app.logger.warning(
            f"User cache write failed for {user.id}: {e}"
        )


def invalidate_user_cache(user_id: str) -> None:
    """
    Invalidate cached user
    """
    redis_client = _get_redis()
    if not redis_client:
        return

    try:
        cache_key = _get_cache_key(user_id)
        redis_client.delete(cache_key)
    except Exception as e:
        current_app.logger.warning(
            f"User cache invalidation failed for {user_id}: {e}"
        )

```

---

## File Overview

# user_cache.py Documentation

## Purpose and Responsibility
This file provides a caching layer for user objects, leveraging Redis to cache and retrieve `User` instances from MongoDB. It ensures that frequent database queries are minimized by caching user data, thus improving performance.

## Key Exports and Public Interface
- **get_cached_user(user_id: str) -> User | None**: Retrieves a cached user from Redis.
- **cache_user(user: User) -> None**: Caches a `User` object in Redis using pickle and base64 encoding.
- **invalidate_user_cache(user_id: str) -> None**: Invalidates the cache for a specific user.

## How It Fits into the Project
This module is part of the authentication system, specifically designed to optimize user retrieval by caching frequently accessed user data. It integrates with the Flask application's Redis client and interacts with MongoDB through the `User` model from the `account.models`.

## Notable Design Decisions
- **Redis Integration**: Utilizes a Redis client attached to the Flask app for efficient caching.
- **Pickle + Base64 Encoding/Decoding**: Ensures data integrity and compatibility across different environments.
- **Error Handling**: Logs warnings for cache read/write failures, ensuring operational resilience.
- **Cache Invalidation**: Provides a method to invalidate user cache entries, maintaining data consistency.
```

This documentation provides an overview of the file's purpose, key functions, integration within the project, and notable design choices.

---

*Generated by CodeWorm on 2026-02-19 15:30*
