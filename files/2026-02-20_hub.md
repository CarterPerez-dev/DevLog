# hub

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/websocket/hub.go
**Language:** go
**Lines:** 1-167
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
hub.go
*/

package websocket

import (
	"context"
	"encoding/json"
	"log/slog"
	"sync"
	"time"

	"github.com/coder/websocket"
)

type Client struct {
	hub      *Hub
	conn     *websocket.Conn
	send     chan []byte
	clientID string
}

type Hub struct {
	clients    map[*Client]bool
	register   chan *Client
	unregister chan *Client
	broadcast  chan []byte
	mu         sync.RWMutex
	logger     *slog.Logger
}

func NewHub(logger *slog.Logger) *Hub {
	return &Hub{
		clients:    make(map[*Client]bool),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		broadcast:  make(chan []byte, 256),
		logger:     logger,
	}
}

func (h *Hub) Run(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			h.mu.Lock()
			for client := range h.clients {
				close(client.send)
				delete(h.clients, client)
			}
			h.mu.Unlock()
			return

		case client := <-h.register:
			h.mu.Lock()
			h.clients[client] = true
			h.mu.Unlock()
			h.logger.Debug("websocket client connected",
				"client_id", client.clientID,
				"total_clients", len(h.clients),
			)

		case client := <-h.unregister:
			h.mu.Lock()
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send)
			}
			h.mu.Unlock()
			h.logger.Debug("websocket client disconnected",
				"client_id", client.clientID,
				"total_clients", len(h.clients),
			)

		case message := <-h.broadcast:
			h.mu.RLock()
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					h.mu.RUnlock()
					h.mu.Lock()
					delete(h.clients, client)
					close(client.send)
					h.mu.Unlock()
					h.mu.RLock()
				}
			}
			h.mu.RUnlock()
		}
	}
}

type Message struct {
	Type      string    `json:"type"`
	Payload   any       `json:"payload"`
	Timestamp time.Time `json:"timestamp"`
}

func (h *Hub) Broadcast(msgType string, payload any) {
	msg := Message{
		Type:      msgType,
		Payload:   payload,
		Timestamp: time.Now(),
	}

	data, err := json.Marshal(msg)
	if err != nil {
		h.logger.Error("failed to marshal broadcast message", "error", err)
		return
	}

	select {
	case h.broadcast <- data:
	default:
		h.logger.Warn("broadcast channel full, dropping message")
	}
}

func (h *Hub) ClientCount() int {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return len(h.clients)
}

func (c *Client) WritePump(ctx context.Context) {
	defer func() {
		c.conn.Close(websocket.StatusNormalClosure, "connection closed")
		c.hub.unregister <- c
	}()

	for {
		select {
		case <-ctx.Done():
			return
		case message, ok := <-c.send:
			if !ok {
				return
			}

			writeCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
			err := c.conn.Write(writeCtx, websocket.MessageText, message)
			cancel()

			if err != nil {
				return
			}
		}
	}
}

func (c *Client) ReadPump(ctx context.Context) {
	defer func() {
		c.hub.unregister <- c
		c.conn.Close(websocket.StatusNormalClosure, "connection closed")
	}()

	for {
		_, _, err := c.conn.Read(ctx)
		if err != nil {
			return
	
```

---

## File Overview

# hub.go

## Purpose and Responsibility
This file implements a WebSocket `Hub` that manages client connections, broadcasts messages to all connected clients, and handles client registration and disconnection.

## Key Exports and Public Interface
- **Hub**: Manages the WebSocket server's state, including registered clients, message broadcasting, and logging.
  - `NewHub`: Creates a new Hub instance with a logger.
  - `Run`: Starts the hub's main loop to handle client connections and broadcasts.
  - `Broadcast`: Sends a message to all connected clients.
  - `ClientCount`: Returns the number of currently connected clients.

- **Client**: Represents an individual WebSocket connection.
  - `WritePump`: Handles sending messages from the client to other clients.
  - `ReadPump`: Handles receiving messages from the client and closing the connection on errors or context cancellation.

## How It Fits into the Project
This file is a core component of the WebSocket server, responsible for maintaining the state of connected clients and facilitating communication between them. The Hub manages the lifecycle of connections and ensures that messages are broadcasted efficiently to all active clients. This implementation uses channels for asynchronous message handling and context-aware goroutines to manage client lifecycles.

## Notable Design Decisions
- **Channels**: Utilizes channels (`register`, `unregister`, `broadcast`) for concurrent communication between the Hub and its Clients.
- **Context Management**: Uses context.Context to handle timeouts and cancellations, ensuring graceful shutdowns.
- **Error Handling**: Implements robust error handling with logging to manage issues like channel fullness or connection errors.
- **Synchronization**: Ensures thread safety through mutexes (`sync.RWMutex`) for concurrent access to the client registry.

---

*Generated by CodeWorm on 2026-02-20 00:13*
