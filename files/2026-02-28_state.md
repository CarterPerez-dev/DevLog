# state

**Type:** File Overview
**Repository:** CodeWorm
**File:** codeworm/core/state.py
**Language:** python
**Lines:** 1-256
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
state.py
"""
import hashlib
import sqlite3
import uuid
from datetime import datetime, timedelta
from pathlib import Path

from codeworm.models import CodeSnippet, DocType, DocumentedSnippet


SCHEMA = """
CREATE TABLE IF NOT EXISTS documented_snippets (
    id TEXT PRIMARY KEY,
    source_repo TEXT NOT NULL,
    source_file TEXT NOT NULL,
    function_name TEXT,
    class_name TEXT,
    code_hash TEXT NOT NULL,
    documented_at TIMESTAMP NOT NULL,
    snippet_path TEXT NOT NULL,
    git_commit TEXT,
    doc_type TEXT NOT NULL DEFAULT 'function_doc'
);

CREATE INDEX IF NOT EXISTS idx_code_hash ON documented_snippets(code_hash);
CREATE INDEX IF NOT EXISTS idx_source ON documented_snippets(source_repo, source_file);
CREATE INDEX IF NOT EXISTS idx_function ON documented_snippets(source_file, function_name);
"""


class StateManager:
    """
    Manages persistent state in SQLite
    This is the daemon's memory - tracks what has been documented
    """
    def __init__(self, db_path: Path) -> None:
        """
        Initialize state manager with database path
        """
        self.db_path = db_path
        self.db_path.parent.mkdir(parents = True, exist_ok = True)
        self._init_db()

    def _init_db(self) -> None:
        """
        Initialize database schema and run migrations
        """
        with sqlite3.connect(self.db_path) as conn:
            conn.executescript(SCHEMA)
            self._migrate_add_doc_type(conn)
            conn.commit()

    def _migrate_add_doc_type(self, conn: sqlite3.Connection) -> None:
        """
        Add doc_type column if it does not exist
        """
        cursor = conn.execute("PRAGMA table_info(documented_snippets)")
        columns = {row[1] for row in cursor.fetchall()}
        if "doc_type" not in columns:
            conn.execute(
                "ALTER TABLE documented_snippets "
                "ADD COLUMN doc_type TEXT NOT NULL DEFAULT 'function_doc'"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_dedup "
                "ON documented_snippets(source_file, function_name, class_name, doc_type)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_doc_type "
                "ON documented_snippets(doc_type)"
            )

    def _get_conn(self) -> sqlite3.Connection:
        """
        Get a database connection with row factory
        """
        conn = sqlite3.connect(self.db_path, timeout = 10)
        conn.row_factory = sqlite3.Row
        return conn

    @staticmethod
    def hash_code(source: str) -> str:
        """
        Generate SHA256 hash of source code for deduplication
        """
        return hashlib.sha256(source.encode("utf-8")).hexdigest()

    def is_documented(self, snippet: CodeSnippet) -> bool:
        """
        Check if this exact code has already been documented
        """
        code_hash = self.hash_code(snippet.source)
        with self._get_conn() as con
```

---

## File Overview

### state.py

**Purpose and Responsibility:**
This Python file manages persistent state using SQLite, tracking documented code snippets within a software repository. It ensures that each unique code snippet is only documented once per type (e.g., function documentation) by leveraging deduplication based on SHA256 hashes.

**Key Exports/Public Interface:**
- `StateManager`: A class responsible for managing the database state.
  - `__init__(db_path: Path)`: Initializes the state manager with a specified database path.
  - `_init_db()`: Sets up or migrates the database schema.
  - `_migrate_add_doc_type(conn: sqlite3.Connection)`: Adds the `doc_type` column if it does not exist.
  - `_get_conn() -> sqlite3.Connection`: Returns a connection to the SQLite database with row factory enabled.
  - `hash_code(source: str) -> str`: Generates a SHA256 hash of source code for deduplication.
  - `is_documented(snippet: CodeSnippet) -> bool`: Checks if a snippet has already been documented.
  - `get_existing_doc(snippet: CodeSnippet) -> DocumentedSnippet | None`: Retrieves existing documentation for a given snippet.
  - `should_document(snippet: CodeSnippet, doc_type: DocType = DocType.FUNCTION_DOC, redocument_after_days: int = 90) -> bool`: Determines if a snippet should be documented based on deduplication and age.

**How it Fits into the Project:**
This file is crucial for maintaining consistency in documentation across the project. It integrates with `CodeSnippet` and `DocumentedSnippet` models to ensure that only unique code snippets are documented, reducing redundancy and improving efficiency.

**Notable Design Decisions:**
- **Deduplication:** Uses SHA256 hashes of source code to track uniqueness.
- **Indexing:** Efficiently indexes the database for quick lookups using `code_hash`, `source_repo`, `source_file`, etc., ensuring fast query performance.
- **Migrations:** Automatically adds necessary columns and indexes during initialization, supporting schema evolution without manual intervention.
```

This documentation provides an overview of the file's role in the project, its public interface, and key design decisions.

---

*Generated by CodeWorm on 2026-02-28 15:35*
