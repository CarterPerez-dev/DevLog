# ws

**Type:** File Overview
**Repository:** CodeWorm
**File:** dashboard/backend/ws.py
**Language:** python
**Lines:** 1-119
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
dashboard/backend/ws.py
"""
from __future__ import annotations

import asyncio
import contextlib
import os
from collections import deque
from typing import Any

import orjson
from fastapi import APIRouter, WebSocket, WebSocketDisconnect

router = APIRouter()

LOG_BUFFER_SIZE = 200


class ConnectionManager:
    def __init__(self) -> None:
        self.active: list[WebSocket] = []
        self.log_buffer: deque[dict[str, Any]] = deque(maxlen=LOG_BUFFER_SIZE)

    async def connect(self, websocket: WebSocket) -> None:
        await websocket.accept()
        self.active.append(websocket)
        if self.log_buffer:
            history = orjson.dumps({
                "channel": "codeworm:history",
                "data": list(self.log_buffer),
            }).decode("utf-8")
            try:
                await websocket.send_text(history)
            except Exception:
                pass

    def disconnect(self, websocket: WebSocket) -> None:
        if websocket in self.active:
            self.active.remove(websocket)

    async def broadcast(self, message: dict[str, Any]) -> None:
        if message.get("channel") in ("codeworm:logs", "codeworm:events"):
            self.log_buffer.append(message)
        payload = orjson.dumps(message).decode("utf-8")
        disconnected: list[WebSocket] = []
        for ws in self.active:
            try:
                await ws.send_text(payload)
            except Exception:
                disconnected.append(ws)
        for ws in disconnected:
            self.disconnect(ws)


manager = ConnectionManager()

_subscriber_task: asyncio.Task | None = None


async def start_redis_subscriber() -> None:
    global _subscriber_task
    redis_url = os.environ.get("REDIS_URL", "redis://localhost:6379")

    try:
        import redis.asyncio as aioredis

        client = aioredis.from_url(redis_url, decode_responses=True)
        await client.ping()
    except Exception:
        return

    async def _subscribe() -> None:
        pubsub = client.pubsub()
        await pubsub.subscribe(
            "codeworm:logs",
            "codeworm:events",
            "codeworm:stats",
        )

        async for message in pubsub.listen():
            if message["type"] != "message":
                continue

            channel = message["channel"]
            try:
                data = orjson.loads(message["data"])
            except Exception:
                data = {"raw": message["data"]}

            await manager.broadcast({
                "channel": channel,
                "data": data,
            })

    _subscriber_task = asyncio.create_task(_subscribe())


async def stop_redis_subscriber() -> None:
    global _subscriber_task
    if _subscriber_task and not _subscriber_task.done():
        _subscriber_task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await _subscriber_task
    _subscriber_task = None


@router.websocket("/ws")
async def websocket_endp
```

---

## File Overview

### Purpose and Responsibility

This Python source file, `ws.py`, is responsible for managing WebSocket connections and handling real-time communication within the CodeWorm application. It integrates with a Redis server to subscribe to various channels (`codeworm:logs`, `codeworm:events`, etc.), broadcasting received messages to connected clients.

### Key Exports and Public Interface

- **ConnectionManager**: Manages active WebSocket connections, log buffers, and handles connection/disconnection events.
- **start_redis_subscriber()**: Starts a background task to subscribe to Redis channels and broadcast messages.
- **stop_redis_subscriber()**: Stops the Redis subscriber task gracefully.
- **router.websocket("/ws")**: The WebSocket endpoint for handling client connections.

### How It Fits in the Project

This file is part of the backend WebSocket server, facilitating real-time data streaming. It works alongside other components to provide a dynamic and interactive user experience by keeping clients updated with real-time events from the application.

### Notable Design Decisions

- **Use of `orjson`**: Efficient JSON serialization/deserialization for performance-critical operations.
- **Asyncio Tasks**: Asynchronous tasks are used to handle WebSocket connections and Redis subscriptions, ensuring non-blocking behavior.
- **Context Managers and Decorators**: Context managers (`contextlib.suppress`) and decorators (e.g., `@router.websocket("/ws")`) enhance code readability and robustness.
- **Type Hints and Annotations**: Python type hints and annotations are used to improve code clarity and maintainability, especially for complex data structures like JSON messages.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and notable design choices.

---

*Generated by CodeWorm on 2026-02-21 07:59*
