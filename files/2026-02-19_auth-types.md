# auth.types

**Type:** File Overview
**Repository:** fullstack-template
**File:** frontends/react-native-ios/src/api/types/auth.types.ts
**Language:** typescript
**Lines:** 1-158
**Complexity:** 0.0

---

## Source Code

```typescript
/**
 * @AngelaMos | 2026
 * auth.types.ts
 */

import { z } from 'zod'
import { PASSWORD_CONSTRAINTS } from '@/core/config'

export const UserRole = {
  UNKNOWN: 'unknown',
  USER: 'user',
  ADMIN: 'admin',
} as const

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

export const userResponseSchema = z.object({
  id: z.string().uuid(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullable(),
  email: z.string().email(),
  full_name: z.string().nullable(),
  is_active: z.boolean(),
  is_verified: z.boolean(),
  role: z.nativeEnum(UserRole),
})

export const tokenResponseSchema = z.object({
  access_token: z.string(),
  token_type: z.string(),
})

export const tokenWithRefreshResponseSchema = z.object({
  access_token: z.string(),
  refresh_token: z.string(),
  token_type: z.string(),
})

export const tokenWithUserResponseSchema = tokenResponseSchema.extend({
  user: userResponseSchema,
})

export const mobileLoginResponseSchema = z.object({
  access_token: z.string(),
  refresh_token: z.string().optional(),
  token_type: z.string(),
  user: userResponseSchema,
})

export const loginRequestSchema = z.object({
  username: z.string().email(),
  password: z
    .string()
    .min(PASSWORD_CONSTRAINTS.MIN_LENGTH)
    .max(PASSWORD_CONSTRAINTS.MAX_LENGTH),
})

export const registerRequestSchema = z.object({
  email: z.string().email(),
  password: z
    .string()
    .min(PASSWORD_CONSTRAINTS.MIN_LENGTH)
    .max(PASSWORD_CONSTRAINTS.MAX_LENGTH),
  full_name: z.string().max(255).optional(),
})

export const passwordChangeRequestSchema = z.object({
  current_password: z.string(),
  new_password: z
    .string()
    .min(PASSWORD_CONSTRAINTS.MIN_LENGTH)
    .max(PASSWORD_CONSTRAINTS.MAX_LENGTH),
})

export const logoutAllResponseSchema = z.object({
  revoked_sessions: z.number(),
})

export type UserResponse = z.infer<typeof userResponseSchema>
export type TokenResponse = z.infer<typeof tokenResponseSchema>
export type TokenWithRefreshResponse = z.infer<
  typeof tokenWithRefreshResponseSchema
>
export type TokenWithUserResponse = z.infer<typeof tokenWithUserResponseSchema>
export type MobileLoginResponse = z.infer<typeof mobileLoginResponseSchema>
export type LoginRequest = z.infer<typeof loginRequestSchema>
export type RegisterRequest = z.infer<typeof registerRequestSchema>
export type PasswordChangeRequest = z.infer<typeof passwordChangeRequestSchema>
export type LogoutAllResponse = z.infer<typeof logoutAllResponseSchema>

export const isValidUserResponse = (data: unknown): data is UserResponse => {
  if (data === null || data === undefined) return false
  if (typeof data !== 'object') return false

  const result = userResponseSchema.safeParse(data)
  return result.success
}

export const isValidTokenResponse = (data: unknown): data is TokenResponse => {
  if (data === null || data === undefined) return false
  if (typeof data !== 'object') return false

  const result = tokenResponseSchema.safeParse(data)
 
```

---

## File Overview

### Documentation for `auth.types.ts`

**Purpose and Responsibility:**
This TypeScript file defines schemas and utility functions for handling authentication responses, requests, and error messages. It ensures data integrity by validating incoming data against predefined schemas.

**Key Exports and Public Interface:**
- **UserRoles:** Enum defining user roles.
- **Schemas:** Zod validation schemas for various authentication-related responses and requests.
- **Validation Functions:** Functions to check if a given object matches the schema.
- **Error Classes:** Custom error class `AuthResponseError` with predefined error messages.

**How it Fits in the Project:**
This file is crucial for maintaining consistent data handling across the application. It ensures that all authentication-related operations adhere to strict validation rules, which helps prevent errors and maintain data integrity. The schemas are used throughout the project wherever user or token data needs to be validated or parsed from API responses.

**Notable Design Decisions:**
- **Zod Schemas:** Utilizes Zod for schema validation, ensuring type safety and robust error handling.
- **Custom Error Class:** Provides a standardized way to handle authentication-related errors, making the code more maintainable and easier to debug.

---

*Generated by CodeWorm on 2026-02-19 16:59*
