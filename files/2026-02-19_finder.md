# finder

**Type:** File Overview
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/scanner/finder.go
**Language:** go
**Lines:** 1-359
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
finder.go
*/

package scanner

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/compose-spec/compose-go/v2/cli"

	"github.com/carterperez-dev/holophyly/internal/model"
)

type Scanner struct {
	paths   []string
	exclude []string
	mu      sync.RWMutex
	cache   map[string]*CachedProject
}

type CachedProject struct {
	Project  *model.Project
	ModTime  time.Time
	CheckSum string
}

type ScanResult struct {
	Projects []*model.Project
	Errors   []ScanError
	Duration time.Duration
}

type ScanError struct {
	Path  string `json:"path"`
	Error string `json:"error"`
}

// NewScanner creates a scanner for discovering compose files.
func NewScanner(paths, exclude []string) *Scanner {
	if len(exclude) == 0 {
		exclude = defaultExcludes()
	}

	return &Scanner{
		paths:   paths,
		exclude: exclude,
		cache:   make(map[string]*CachedProject),
	}
}

// Scan discovers all compose files in configured paths.
// Uses content-based detection - parses YAML and checks for services key.
func (s *Scanner) Scan(ctx context.Context) (*ScanResult, error) {
	start := time.Now()
	result := &ScanResult{
		Projects: make([]*model.Project, 0),
		Errors:   make([]ScanError, 0),
	}

	logger := slog.Default()

	yamlFiles := make([]string, 0)

	for _, scanPath := range s.paths {
		expanded := expandPath(scanPath)

		err := filepath.WalkDir(
			expanded,
			func(path string, d fs.DirEntry, err error) error {
				if err != nil {
					return nil
				}

				select {
				case <-ctx.Done():
					return ctx.Err()
				default:
				}

				if d.IsDir() {
					if s.shouldExcludeDir(d.Name()) {
						return filepath.SkipDir
					}
					return nil
				}

				if isYAMLFile(path) {
					yamlFiles = append(yamlFiles, path)
				}

				return nil
			},
		)

		if err != nil && err != context.Canceled {
			result.Errors = append(result.Errors, ScanError{
				Path:  scanPath,
				Error: fmt.Sprintf("walking directory: %v", err),
			})
		}
	}

	for _, yamlPath := range yamlFiles {
		select {
		case <-ctx.Done():
			result.Duration = time.Since(start)
			return result, ctx.Err()
		default:
		}

		proj, err := s.parseComposeFile(ctx, yamlPath)
		if err != nil {
			logger.Debug("skipping compose file", "path", yamlPath, "error", err)
			continue
		}

		if proj != nil {
			result.Projects = append(result.Projects, proj)
		}
	}

	result.Duration = time.Since(start)
	return result, nil
}

// parseComposeFile attempts to parse a YAML file as a compose file.
// Returns nil if the file is not a valid compose file.
func (s *Scanner) parseComposeFile(
	ctx context.Context,
	path string,
) (*model.Project, error) {
	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	checksum, err := fileChecksum(path)
	if err != nil {
		return nil, err
	}

	s.mu.RLock()
	cached, exists := s.cache[path]
	s.mu.RUnlock()

	if exists && cached.ModTime.Equal(info.ModTime()) &&
		cached.CheckSum == checksum {
```

---

## File Overview

# finder.go

## Purpose and Responsibility
This Go source file defines a `Scanner` struct responsible for discovering Docker Compose files across specified paths within a project. The scanner uses content-based detection to parse YAML files, ensuring that only valid compose files are processed.

## Key Exports and Public Interface
- **NewScanner**: Creates a new `Scanner` instance with configurable paths and exclusions.
- **Scan**: Discovers all Docker Compose files in the configured paths and parses them into `model.Project` objects.
- **GetPaths**, **SetPaths**: Get and set the scan paths.
- **ClearCache**: Clears the internal cache of scanned projects.

## How It Fits Into the Project
The `finder.go` file is part of the `scanner` package, which is crucial for project discovery in a larger operations management system. It integrates with other components like `model.Project`, which represents discovered projects, and `cli.NewProjectOptions`, which handles parsing Compose files.

## Notable Design Decisions
- **Content-Based Detection**: The scanner uses content-based detection to ensure only valid compose files are processed.
- **Caching**: Projects are cached based on file modification times and checksums to avoid redundant processing.
- **Error Handling**: Context cancellation is handled gracefully, allowing the scan to terminate early if necessary.
- **Concurrency Safety**: Use of `sync.RWMutex` ensures thread-safe access to the cache.
```

This documentation provides a high-level overview of the file's purpose, key exports, integration within the project, and notable design decisions.

---

*Generated by CodeWorm on 2026-02-19 18:39*
