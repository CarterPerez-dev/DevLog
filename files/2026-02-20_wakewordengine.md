# WakeWordEngine

**Type:** File Overview
**Repository:** angelamos-3d
**File:** frontend/src/lib/wakeword/WakeWordEngine.ts
**Language:** typescript
**Lines:** 1-275
**Complexity:** 0.0

---

## Source Code

```typescript
/**
 * Â© AngelaMos | 2026
 * Uses Angela-Wake WebSocket server for "angela" wake word detection.
 */

import { getAngelaConfig } from "../../config";
import { logger } from "../debug";

const CHUNK_MS = 80;

export class WakeWordEngine {
	private ws: WebSocket | null = null;
	private audioContext: AudioContext | null = null;
	private workletNode: AudioWorkletNode | null = null;
	private stream: MediaStream | null = null;
	private sourceNode: MediaStreamAudioSourceNode | null = null;
	private isListening = false;
	private reconnectTimer: number | null = null;

	public onWakeWord?: () => void;

	async initialize(): Promise<void> {
		const config = getAngelaConfig();
		const wsEndpoint = `${config.api.wsBaseUrl}/ws/wake`;

		try {
			logger.wake.log("Connecting to Angela-Wake...");
			await this.connect(wsEndpoint);

			this.stream = await navigator.mediaDevices.getUserMedia({
				audio: {
					channelCount: 1,
					echoCancellation: true,
					noiseSuppression: true,
				},
			});

			this.audioContext = new AudioContext();
			const sampleRate = this.audioContext.sampleRate;
			const chunkSamples = Math.floor((sampleRate * CHUNK_MS) / 1000);

			logger.wake.log(
				`Audio sample rate: ${sampleRate}Hz, chunk size: ${chunkSamples}`,
			);

			const workletCode = `
        class AudioChunkProcessor extends AudioWorkletProcessor {
          constructor() {
            super()
            this.buffer = new Float32Array(0)
            this.chunkSize = ${chunkSamples}
            this.enabled = false
            this.port.onmessage = (e) => {
              if (e.data === 'start') {
                this.buffer = new Float32Array(0)
                this.enabled = true
              } else if (e.data === 'stop') {
                this.enabled = false
              }
            }
          }

          process(inputs) {
            if (!this.enabled) return true
            const input = inputs[0]
            if (input.length > 0 && input[0].length > 0) {
              const samples = input[0]
              const newBuffer = new Float32Array(this.buffer.length + samples.length)
              newBuffer.set(this.buffer)
              newBuffer.set(samples, this.buffer.length)
              this.buffer = newBuffer

              while (this.buffer.length >= this.chunkSize) {
                const chunk = this.buffer.slice(0, this.chunkSize)
                this.buffer = this.buffer.slice(this.chunkSize)

                const int16 = new Int16Array(chunk.length)
                for (let i = 0; i < chunk.length; i++) {
                  int16[i] = Math.max(-32768, Math.min(32767, Math.floor(chunk[i] * 32767)))
                }
                this.port.postMessage(int16.buffer, [int16.buffer])
              }
            }
            return true
          }
        }
        registerProcessor('audio-chunk-processor', AudioChunkProcessor)
      `;

			const blob = new Blob([workletCode], { type: "application/javascript" });
			const url = URL.createObjectURL(b
```

---

## File Overview

### WakeWordEngine.ts

**Purpose and Responsibility:**
This TypeScript file implements a `WakeWordEngine` class responsible for integrating with an Angela-Wake WebSocket server to detect wake words. It handles audio processing, WebSocket communication, and reconnection logic.

**Key Exports and Public Interface:**
- **Class:** `WakeWordEngine`
  - **Methods:**
    - `initialize()`: Initializes the wake word detection engine.
    - `start()`: Starts listening for wake words.
    - `onWakeWord?: () => void`: Optional callback for when a wake word is detected.

**How It Fits in the Project:**
This file is part of the frontend module responsible for audio processing and wake word detection. It integrates with the backend Angela-Wake service to provide real-time wake word detection capabilities, enhancing user interaction within the application.

**Notable Design Decisions:**
- **WebSocket Integration:** Utilizes WebSocket for real-time communication between the client and server.
- **Audio Processing Worklet:** Employs an AudioWorkletNode for efficient audio chunk processing.
- **Reconnection Logic:** Implements a retry mechanism to ensure continuous service availability even if the connection is lost.
- **Error Handling:** Robust error handling ensures that any issues are logged and appropriately managed, maintaining application stability.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and significant design choices.

---

*Generated by CodeWorm on 2026-02-20 23:25*
