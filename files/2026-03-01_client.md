# client

**Type:** File Overview
**Repository:** Yoshi-Audit
**File:** internal/docker/client.go
**Language:** go
**Lines:** 1-280
**Complexity:** 0.0

---

## Source Code

```go
// Â©AngelaMos | 2026
// client.go

package docker

import (
	"context"
	"strings"
	"time"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/image"
	"github.com/docker/docker/client"
)

type ImageInfo struct {
	ID         string
	Repository string
	Tag        string
	Size       int64
	SharedSize int64
	UniqueSize int64
	Containers int64
	Created    time.Time
	Dangling   bool
}

type ContainerInfo struct {
	ID      string
	Name    string
	Image   string
	Status  string
	State   string
	Size    int64
	Created time.Time
	Running bool
}

type VolumeInfo struct {
	Name    string
	Size    int64
	Links   int
	Created time.Time
}

type NetworkInfo struct {
	ID   string
	Name string
}

type BuildCacheInfo struct {
	TotalSize int64
}

type Client struct {
	cli *client.Client
}

func NewClient() (*Client, error) {
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return nil, err
	}
	return &Client{cli: cli}, nil
}

func (c *Client) Close() error {
	return c.cli.Close()
}

func (c *Client) ListImages() ([]ImageInfo, error) {
	ctx := context.Background()
	summaries, err := c.cli.ImageList(ctx, image.ListOptions{All: true})
	if err != nil {
		return nil, err
	}

	var images []ImageInfo
	for _, s := range summaries {
		repo := "<none>"
		tag := "<none>"
		if len(s.RepoTags) > 0 {
			parts := strings.SplitN(s.RepoTags[0], ":", 2)
			repo = parts[0]
			if len(parts) > 1 {
				tag = parts[1]
			}
		}

		dangling := repo == "<none>" && s.Containers == 0

		images = append(images, ImageInfo{
			ID:         s.ID,
			Repository: repo,
			Tag:        tag,
			Size:       s.Size,
			SharedSize: s.SharedSize,
			UniqueSize: s.Size - s.SharedSize,
			Containers: s.Containers,
			Created:    time.Unix(s.Created, 0),
			Dangling:   dangling,
		})
	}
	return images, nil
}

func (c *Client) ListContainers() ([]ContainerInfo, error) {
	ctx := context.Background()
	summaries, err := c.cli.ContainerList(ctx, container.ListOptions{All: true})
	if err != nil {
		return nil, err
	}

	var containers []ContainerInfo
	for _, s := range summaries {
		name := ""
		if len(s.Names) > 0 {
			name = strings.TrimPrefix(s.Names[0], "/")
		}

		containers = append(containers, ContainerInfo{
			ID:      s.ID,
			Name:    name,
			Image:   s.Image,
			Status:  s.Status,
			State:   s.State,
			Size:    s.SizeRw,
			Created: time.Unix(s.Created, 0),
			Running: s.State == "running",
		})
	}
	return containers, nil
}

func (c *Client) ListVolumes() ([]VolumeInfo, error) {
	ctx := context.Background()
	resp, err := c.cli.VolumeList(ctx, volumeListOptions())
	if err != nil {
		return nil, err
	}

	var volumes []VolumeInfo
	for _, v := range resp.Volumes {
		var size int64
		var links int
		if v.UsageData != nil {
			size = v.UsageData.Size
			links = int(v.UsageData.RefCount)
		}

		var created time.Time
		if v.CreatedAt != "" {
			created, _ = time.Parse(time.RFC3339, v
```

---

## File Overview

# client.go

## Purpose and Responsibility
This Go source file defines a Docker client wrapper, providing high-level access to Docker's image, container, volume, and build cache management functionalities.

## Key Exports and Public Interface
- `Client`: A struct encapsulating the Docker client.
- `NewClient() (*Client, error)`: Creates a new Docker client instance.
- `Close() error`: Closes the underlying Docker client connection.
- `ListImages() ([]ImageInfo, error)`: Lists all Docker images with detailed information.
- `ListContainers() ([]ContainerInfo, error)`: Lists all Docker containers with detailed information.
- `ListVolumes() ([]VolumeInfo, error)`: Lists all Docker volumes with detailed information.
- `GetDiskUsage() ([]ImageInfo, []ContainerInfo, []VolumeInfo, BuildCacheInfo, error)`: Retrieves disk usage statistics for images, containers, and volumes.

## How It Fits in the Project
This file serves as a central hub for interacting with Docker resources within the project. It abstracts away low-level Docker API calls, providing a more user-friendly interface for managing Docker assets such as images, containers, and volumes. This abstraction is crucial for maintaining clean code and ensuring that changes to the Docker client do not propagate throughout the entire application.

## Notable Design Decisions
- **Error Handling**: Errors are consistently returned from each method, allowing callers to handle failures gracefully.
- **Context Usage**: Contexts are used in API calls to manage cancellation and timeouts effectively.
- **Struct Definitions**: Custom structs (`ImageInfo`, `ContainerInfo`, etc.) are defined to encapsulate relevant Docker resource information, promoting clarity and ease of use.
- **Dependency Injection**: The client is initialized with a `client.Client` instance, allowing for potential mocking or replacement during testing.

---

*Generated by CodeWorm on 2026-03-01 10:28*
