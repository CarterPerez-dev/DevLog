# notifier

**Type:** File Overview
**Repository:** Telehook
**File:** src/telehook/notifier.py
**Language:** python
**Lines:** 1-73
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2026
notifier.py
"""

import asyncio

from telehook.config import TelehookConfig
from telehook.message import Message
from telehook.middleware.base import (
    Middleware,
    SendFunc,
    build_chain,
)
from telehook.transport import Transport


class Notifier:
    def __init__(
        self,
        config: TelehookConfig | None = None,
        middleware: list[Middleware] | None = None,
    ):
        self._config = config or TelehookConfig.from_env()
        self._transport = Transport(self._config)
        self._middleware_list = (
            middleware if middleware is not None else self._default_middleware()
        )
        self._chain: SendFunc = build_chain(
            self._middleware_list,
            self._transport_send
        )

    def _default_middleware(self) -> list[Middleware]:
        from telehook.middleware.rate_limiter import RateLimiter
        from telehook.middleware.retry import Retry

        return [RateLimiter(), Retry()]

    async def _transport_send(self, message: Message) -> None:
        await self._transport.send(message)

    async def send(self, content: str | Message) -> None:
        if isinstance(content, str):
            content = Message(text = content)
        await self._chain(content)

    def send_sync(self, content: str | Message) -> None:
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = None

        if loop and loop.is_running():
            import concurrent.futures

            with concurrent.futures.ThreadPoolExecutor(max_workers = 1) as pool:
                pool.submit(asyncio.run, self.send(content)).result()
        else:
            asyncio.run(self.send(content))

    async def close(self) -> None:
        for mw in self._middleware_list:
            if hasattr(mw, "close"):
                await mw.close()
        await self._transport.close()

    async def __aenter__(self) -> "Notifier":
        return self

    async def __aexit__(self, *exc: object) -> None:
        await self.close()

```

---

## File Overview

### notifier.py

**Purpose:**  
This file implements the `Notifier` class, responsible for sending messages via configured transports with middleware support.

**Key Exports:**
- **Notifier Class**: The main interface for sending notifications.
  - Methods:
    - `__init__`: Initializes the Notifier with configuration and middleware.
    - `_default_middleware`: Sets up default middleware.
    - `_transport_send`: Sends a message through the transport layer.
    - `send`: Asynchronously sends a message or constructs it from text.
    - `send_sync`: Synchronously sends a message, handling event loops carefully.
    - `close`: Closes all middleware and transports.
    - `__aenter__` & `__aexit__`: Context manager support for asynchronous cleanup.

**Project Fit:**
- The Notifier class is central to the Telehook project, facilitating the sending of messages through configured transport mechanisms with optional middleware for additional functionality like rate limiting and retries. It integrates seamlessly with other components such as `TelehookConfig`, `Message`, and `Transport`.

**Design Decisions:**
- **Middleware Chain**: Uses a chain pattern to apply multiple middleware functions before sending a message, allowing flexible and modular processing.
- **Asynchronous Handling**: Supports both asynchronous and synchronous methods for sending messages, ensuring compatibility with various use cases.
- **Context Manager Support**: Provides context manager support (`__aenter__`, `__aexit__`) for clean resource management during the lifecycle of the Notifier instance.
```

This documentation provides a high-level overview of the file's purpose, key exports, integration within the project, and notable design choices.

---

*Generated by CodeWorm on 2026-02-28 22:04*
