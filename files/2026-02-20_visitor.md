# visitor

**Type:** File Overview
**Repository:** docksec
**File:** internal/parser/visitor.go
**Language:** go
**Lines:** 1-139
**Complexity:** 0.0

---

## Source Code

```go
/*
CarterPerez-dev | 2025
visitor.go
*/

package parser

import (
	"github.com/CarterPerez-dev/docksec/internal/finding"
)

type RuleVisitor struct {
	Target   finding.Target
	Findings finding.Collection
	rules    []Rule
}

type Rule interface {
	ID() string
	Check(ctx *RuleContext) []*finding.Finding
}

type RuleContext struct {
	Target      finding.Target
	Dockerfile  *DockerfileAST
	ComposeFile *ComposeFile
}

func NewRuleVisitor(target finding.Target, rules ...Rule) *RuleVisitor {
	return &RuleVisitor{
		Target: target,
		rules:  rules,
	}
}

func (v *RuleVisitor) VisitDockerfile(ast *DockerfileAST) {
	ctx := &RuleContext{
		Target:     v.Target,
		Dockerfile: ast,
	}

	for _, rule := range v.rules {
		findings := rule.Check(ctx)
		v.Findings = append(v.Findings, findings...)
	}
}

func (v *RuleVisitor) VisitCompose(cf *ComposeFile) {
	ctx := &RuleContext{
		Target:      v.Target,
		ComposeFile: cf,
	}

	for _, rule := range v.rules {
		findings := rule.Check(ctx)
		v.Findings = append(v.Findings, findings...)
	}
}

func (v *RuleVisitor) VisitCommand(cmd Command) {
}

func (v *RuleVisitor) VisitService(name string, svc *Service) {
}

func (v *RuleVisitor) Results() finding.Collection {
	return v.Findings
}

type BaseRule struct {
	RuleID      string
	Title       string
	Severity    finding.Severity
	Category    string
	Description string
	Remediation string
	References  []string
}

func (r *BaseRule) ID() string {
	return r.RuleID
}

func (r *BaseRule) NewFinding(target finding.Target) *finding.Finding {
	return finding.New(r.RuleID, r.Title, r.Severity, target).
		WithDescription(r.Description).
		WithCategory(r.Category).
		WithRemediation(r.Remediation).
		WithReferences(r.References...)
}

type DockerfileRule struct {
	BaseRule
	CheckFunc func(ast *DockerfileAST, target finding.Target) []*finding.Finding
}

func (r *DockerfileRule) Check(ctx *RuleContext) []*finding.Finding {
	if ctx.Dockerfile == nil {
		return nil
	}
	return r.CheckFunc(ctx.Dockerfile, ctx.Target)
}

type ComposeRule struct {
	BaseRule
	CheckFunc func(cf *ComposeFile, target finding.Target) []*finding.Finding
}

func (r *ComposeRule) Check(ctx *RuleContext) []*finding.Finding {
	if ctx.ComposeFile == nil {
		return nil
	}
	return r.CheckFunc(ctx.ComposeFile, ctx.Target)
}

type MultiRule struct {
	BaseRule
	DockerfileCheck func(ast *DockerfileAST, target finding.Target) []*finding.Finding
	ComposeCheck    func(cf *ComposeFile, target finding.Target) []*finding.Finding
}

func (r *MultiRule) Check(ctx *RuleContext) []*finding.Finding {
	var findings []*finding.Finding

	if ctx.Dockerfile != nil && r.DockerfileCheck != nil {
		findings = append(
			findings,
			r.DockerfileCheck(ctx.Dockerfile, ctx.Target)...)
	}

	if ctx.ComposeFile != nil && r.ComposeCheck != nil {
		findings = append(
			findings,
			r.ComposeCheck(ctx.ComposeFile, ctx.Target)...)
	}

	return findings
}

```

---

## File Overview

## visitor.go

### Purpose and Responsibility
This Go source file defines a `RuleVisitor` that iterates over Dockerfile and Compose files to apply security rules defined by various `Rule` implementations. It collects findings based on these rules and provides methods for visiting different types of configurations.

### Key Exports and Public Interface
- **RuleVisitor**: Manages the application of security rules to target configurations.
  - Methods: `NewRuleVisitor`, `VisitDockerfile`, `VisitCompose`, `Results`.
- **RuleContext**: Context passed to each rule during evaluation.
  - Fields: `Target`, `Dockerfile`, and `ComposeFile`.
- **BaseRule, DockerfileRule, ComposeRule, MultiRule**: Abstract base classes for defining security rules with specific implementations.

### How It Fits into the Project
This file is a crucial component of the `parser` package in the `docksec` project. It integrates with other modules responsible for parsing and analyzing Dockerfiles and Compose files to identify potential security vulnerabilities. The `RuleVisitor` acts as a central hub, delegating rule checks to specific implementations based on the type of configuration being analyzed.

### Notable Design Decisions
- **Error Handling**: While not explicitly shown in this snippet, error handling is critical for robustness. Each method should return errors if encountered.
- **Goroutines**: Although not demonstrated here, goroutines could be used for concurrent rule evaluation to improve performance.
- **Interfaces and Polymorphism**: The use of interfaces (`Rule`, `RuleContext`) enables flexible rule implementations and dynamic dispatching based on the configuration type being analyzed.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and notable design choices.

---

*Generated by CodeWorm on 2026-02-20 20:37*
