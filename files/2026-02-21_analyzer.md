# analyzer

**Type:** File Overview
**Repository:** CodeWorm
**File:** codeworm/analysis/analyzer.py
**Language:** python
**Lines:** 1-268
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
analysis/analyzer.py
"""
from __future__ import annotations

import random
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

from git import InvalidGitRepositoryError, Repo

from codeworm.analysis.complexity import ComplexityAnalyzer, ComplexityMetrics
from codeworm.analysis.parser import CodeExtractor, ParsedFunction, ParserManager
from codeworm.analysis.scanner import RepoScanner, ScannedFile, WeightedRepoSelector
from codeworm.analysis.scoring import GitStats, InterestScore, InterestScorer
from codeworm.models import CodeSnippet

if TYPE_CHECKING:
    from collections.abc import Iterator

    from codeworm.core.config import AnalyzerSettings, RepoEntry


@dataclass
class AnalysisCandidate:
    """
    A code snippet candidate for documentation
    """
    snippet: CodeSnippet
    parsed_function: ParsedFunction
    complexity: ComplexityMetrics | None
    git_stats: GitStats
    interest_score: InterestScore
    scanned_file: ScannedFile

    @property
    def score(self) -> float:
        return self.interest_score.total

    @property
    def is_worth_documenting(self) -> bool:
        """
        Check if this candidate meets minimum thresholds
        """
        return self.score >= 25 and self.snippet.line_count >= 10


class CodeAnalyzer:
    """
    Main code analysis engine
    Combines parsing, complexity analysis, and interest scoring
    """
    def __init__(
        self,
        repos: list[RepoEntry],
        settings: AnalyzerSettings | None = None,
    ) -> None:
        """
        Initialize analyzer with repository configurations
        """
        self.repos = repos
        self.settings = settings
        self.repo_selector = WeightedRepoSelector(repos)
        self.scanner = RepoScanner(
            include_patterns = settings.include_patterns if settings else None,
            exclude_patterns = settings.exclude_patterns if settings else None,
        )
        self.complexity_analyzer = ComplexityAnalyzer()
        self.scorer = InterestScorer()

        self._git_repos: dict[Path, Repo | None] = {}

        ParserManager.initialize()

    def _get_git_repo(self, repo_path: Path) -> Repo | None:
        """
        Get or create git repo instance for a path
        """
        if repo_path not in self._git_repos:
            try:
                self._git_repos[repo_path] = Repo(repo_path)
            except InvalidGitRepositoryError:
                self._git_repos[repo_path] = None
        return self._git_repos[repo_path]

    def analyze_file(self,
                     scanned_file: ScannedFile) -> Iterator[AnalysisCandidate]:
        """
        Analyze a single file and yield documentation candidates
        """
        try:
            source = scanned_file.path.read_text(encoding = "utf-8")
        except Exception:
            return

        extractor = CodeExtractor(source, scanned_file.language)
        complexity_results = self.complexity_an
```

---

## File Overview

### analyzer.py

**Purpose and Responsibility:**
This Python file serves as the core analysis engine for CodeWorm, a tool designed to automate code documentation. It integrates various components like complexity analysis, parsing, and interest scoring to identify functions worth documenting.

**Key Exports and Public Interface:**
- **`AnalysisCandidate`:** A dataclass representing a potential candidate for documentation.
- **`CodeAnalyzer`:** The main class responsible for analyzing repositories, extracting functions, calculating complexity metrics, and scoring their relevance for documentation.

**How it Fits in the Project:**
This file is central to CodeWorm's functionality. It leverages other modules like `ComplexityAnalyzer`, `ParserManager`, and `InterestScorer` to process code snippets from multiple repositories. The results are used by higher-level components to generate documentation recommendations.

**Notable Design Decisions:**
- **Modular Architecture:** The file is structured into distinct classes for different responsibilities, promoting reusability and maintainability.
- **Lazy Initialization:** Git repository instances are lazily loaded to optimize performance when dealing with large numbers of repositories.
- **Type Hints and Data Classes:** Extensive use of type hints and dataclasses ensures clear definitions and immutability where appropriate, enhancing code readability and reliability.
```

This documentation provides a high-level overview of the file's role within the project, its key components, and important design choices.

---

*Generated by CodeWorm on 2026-02-21 07:07*
