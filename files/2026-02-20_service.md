# service

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/cleanup/service.go
**Language:** go
**Lines:** 1-153
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
service.go
*/

package cleanup

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"go.mongodb.org/mongo-driver/v2/bson"
	"go.mongodb.org/mongo-driver/v2/mongo"
)

type Service struct {
	client         *mongo.Client
	database       string
	retentionDays  int
	logger         *slog.Logger
}

func NewService(client *mongo.Client, database string, retentionDays int, logger *slog.Logger) *Service {
	return &Service{
		client:        client,
		database:      database,
		retentionDays: retentionDays,
		logger:        logger,
	}
}

type CleanupResult struct {
	Collection    string
	DeletedCount  int64
	Duration      time.Duration
	Error         error
}

func (s *Service) CleanOldDocuments(ctx context.Context) ([]CleanupResult, error) {
	s.logger.Info("starting cleanup task", "retention_days", s.retentionDays)

	collectionsWithRetention := []string{
		"perfSamples",
		"auditLogs",
		"admin_request_logs",
		"uniqueUserRequests",
		"watchList",
		"globalRateLimits",
		"scanAttempts",
	}

	legacyCollections := []string{
		"honeypot_interactions",
	}

	var results []CleanupResult

	cutoffDate := time.Now().AddDate(0, 0, -s.retentionDays)

	for _, collName := range collectionsWithRetention {
		result := s.cleanCollectionByDate(ctx, collName, cutoffDate)
		results = append(results, result)
	}

	for _, collName := range legacyCollections {
		result := s.dropAllDocuments(ctx, collName)
		results = append(results, result)
	}

	s.logCleanupResults(results)

	return results, nil
}

func (s *Service) cleanCollectionByDate(ctx context.Context, collName string, cutoffDate time.Time) CleanupResult {
	start := time.Now()
	result := CleanupResult{
		Collection: collName,
	}

	coll := s.client.Database(s.database).Collection(collName)

	filter := bson.D{
		{Key: "timestamp", Value: bson.D{{Key: "$lt", Value: cutoffDate}}},
	}

	deleteResult, err := coll.DeleteMany(ctx, filter)
	if err != nil {
		result.Error = fmt.Errorf("delete old documents: %w", err)
		result.Duration = time.Since(start)
		return result
	}

	result.DeletedCount = deleteResult.DeletedCount
	result.Duration = time.Since(start)

	return result
}

func (s *Service) dropAllDocuments(ctx context.Context, collName string) CleanupResult {
	start := time.Now()
	result := CleanupResult{
		Collection: collName,
	}

	coll := s.client.Database(s.database).Collection(collName)

	deleteResult, err := coll.DeleteMany(ctx, bson.D{})
	if err != nil {
		result.Error = fmt.Errorf("drop all documents: %w", err)
		result.Duration = time.Since(start)
		return result
	}

	result.DeletedCount = deleteResult.DeletedCount
	result.Duration = time.Since(start)

	return result
}

func (s *Service) logCleanupResults(results []CleanupResult) {
	totalDeleted := int64(0)
	successCount := 0
	errorCount := 0

	for _, result := range results {
		if result.Error != nil {
			s.logger.Error("cleanup failed",
				"collection", result.Collection,
				"error", result.Error,
				"duration", result.Duration,
			)
			errorCount++

```

---

## File Overview

# service.go

## Purpose and Responsibility
This Go source file defines a `Service` struct for managing document cleanup tasks within a MongoDB database. The primary responsibilities include cleaning old documents based on retention policies and dropping all documents from legacy collections.

## Key Exports and Public Interface
- **NewService**: Constructs a new `Service` instance with necessary dependencies.
- **CleanOldDocuments**: Executes the main cleanup task, iterating over specified collections to delete or drop documents older than a certain date.
- **CleanupResult**: A struct representing the outcome of each cleanup operation.

## How It Fits into the Project
The `service.go` file is part of the `cleanup` package and integrates with other modules responsible for database operations. It leverages MongoDB's Go driver to interact with the database, ensuring that old or unnecessary documents are removed according to predefined retention policies. This service is crucial for maintaining data integrity and reducing storage costs.

## Notable Design Decisions
- **Error Handling**: Uses `fmt.Errorf` to create detailed error messages.
- **Logging**: Utilizes `slog` for logging cleanup results, providing clear insights into the operations performed.
- **Concurrency**: While goroutines are not explicitly used in this file, the operations can be easily parallelized if needed.
- **Modularity**: The service is designed to be modular, allowing easy addition or removal of collections from the cleanup process.
```

This documentation provides an overview of the `service.go` file's role within the project, its key components, and important design choices.

---

*Generated by CodeWorm on 2026-02-20 00:26*
