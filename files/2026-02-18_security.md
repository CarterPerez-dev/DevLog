# security

**Type:** File Overview
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/app/core/security.py
**Language:** python
**Lines:** 1-195
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
security.py
"""

import asyncio
import hashlib
import secrets
from datetime import (
    UTC,
    datetime,
    timedelta,
)
from typing import Any
from uuid import UUID

import jwt
from fastapi import Response
from pwdlib import PasswordHash

from config import (
    API_PREFIX,
    settings,
    TokenType,
)


password_hasher = PasswordHash.recommended()


async def hash_password(password: str) -> str:
    """
    Hash password using Argon2id

    Runs in thread pool to avoid blocking the async event loop
    since Argon2 is CPU intensive by design
    """
    return await asyncio.to_thread(password_hasher.hash, password)


async def verify_password(plain_password: str,
                          hashed_password: str) -> tuple[bool,
                                                         str | None]:
    """
    Verify password and check if rehash is needed

    Returns:
        Tuple of (is_valid, new_hash_if_needs_rehash)
        If password is valid but hash params are outdated, returns new hash
    """
    try:
        return await asyncio.to_thread(
            password_hasher.verify_and_update,
            plain_password,
            hashed_password
        )
    except Exception:
        return False, None


DUMMY_HASH = password_hasher.hash(
    "dummy_password_for_timing_attack_prevention"
)


async def verify_password_with_timing_safety(
    plain_password: str,
    hashed_password: str | None,
) -> tuple[bool,
           str | None]:
    """
    Verify password with constant time behavior to prevent user enumeration

    If no hash is provided (user doesn't exist), still performs a dummy
    hash operation to prevent timing attacks
    """
    if hashed_password is None:
        await asyncio.to_thread(
            password_hasher.verify,
            plain_password,
            DUMMY_HASH
        )
        return False, None
    return await verify_password(plain_password, hashed_password)


def create_access_token(
    user_id: UUID,
    token_version: int,
    extra_claims: dict[str,
                       Any] | None = None,
) -> str:
    """
    Create a short lived access token
    """
    now = datetime.now(UTC)
    payload = {
        "sub": str(user_id),
        "type": TokenType.ACCESS.value,
        "token_version": token_version,
        "iat": now,
        "exp":
        now + timedelta(minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES),
    }
    if extra_claims:
        payload.update(extra_claims)

    return jwt.encode(
        payload,
        settings.SECRET_KEY.get_secret_value(),
        algorithm = settings.JWT_ALGORITHM,
    )


def create_refresh_token(
    user_id: UUID,
    family_id: UUID,
) -> tuple[str,
           str,
           datetime]:
    """
    Create a long lived refresh token

    Returns:
        Tuple of (raw_token, token_hash, expires_at)
        Raw token is sent to client, hash is stored in database
    """
    raw_token = secrets.token_urlsafe(32)
    token_hash = hashlib
```

---

## File Overview

### security.py

**Purpose and Responsibility:**
This file contains core security functionalities for user authentication and token management, including password hashing, token creation, validation, and cookie handling.

**Key Exports and Public Interface:**
- `hash_password`: Asynchronously hashes a password using Argon2id.
- `verify_password`: Verifies a password and checks if rehashing is needed.
- `verify_password_with_timing_safety`: Ensures constant time behavior to prevent timing attacks.
- `create_access_token`: Generates a short-lived access token with specified user ID, token version, and extra claims.
- `create_refresh_token`: Creates a long-lived refresh token with associated raw token, hash, and expiration date.
- `decode_access_token`: Decodes and validates an access token.
- `hash_token`: Hashes a token for secure storage.
- `generate_secure_token`: Generates a cryptographically secure random token.
- `set_refresh_cookie`: Sets the refresh token as an HttpOnly cookie in the response.
- `clear_refresh_cookie`: Clears the refresh token cookie from the response.

**How It Fits into the Project:**
This file is crucial for managing user authentication and session management. It integrates with other modules like FastAPI, JWT, and configuration settings to ensure secure and efficient token-based authentication. The functions handle password hashing, token creation, validation, and cookie handling, making it a central component of the backend security infrastructure.

**Notable Design Decisions:**
- **Asynchronous Operations:** Functions use `asyncio.to_thread` for CPU-intensive tasks like password hashing, ensuring non-blocking execution.
- **Constant Time Verification:** The `verify_password_with_timing_safety` function ensures constant time behavior to prevent timing attacks.
- **Secure Token Handling:** Tokens are securely hashed and stored, with HttpOnly cookies used to protect sensitive information from client-side access.
- **JWT Implementation:** JWT tokens are created and validated using the `jwt` library, ensuring secure and verifiable token-based authentication.
```

This documentation provides a high-level overview of the file's purpose, key exports, integration within the project, and notable design decisions.

---

*Generated by CodeWorm on 2026-02-18 07:39*
