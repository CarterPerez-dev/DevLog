# security

**Type:** File Overview
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/examples/minimal-production/backend/app/core/security.py
**Language:** python
**Lines:** 1-112
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
security.py
"""

import asyncio
from datetime import (
    UTC,
    datetime,
    timedelta,
)
from typing import Any
from uuid import UUID

import jwt
from pwdlib import PasswordHash

from config import (
    settings,
    TokenType,
)


password_hasher = PasswordHash.recommended()


async def hash_password(password: str) -> str:
    """
    Hash password using Argon2id
    """
    return await asyncio.to_thread(password_hasher.hash, password)


async def verify_password(plain_password: str,
                          hashed_password: str) -> tuple[bool,
                                                         str | None]:
    """
    Verify password and check if rehash is needed
    """
    try:
        return await asyncio.to_thread(
            password_hasher.verify_and_update,
            plain_password,
            hashed_password
        )
    except Exception:
        return False, None


DUMMY_HASH = password_hasher.hash(
    "dummy_password_for_timing_attack_prevention"
)


async def verify_password_with_timing_safety(
    plain_password: str,
    hashed_password: str | None,
) -> tuple[bool,
           str | None]:
    """
    Verify password with constant time behavior to prevent user enumeration
    """
    if hashed_password is None:
        await asyncio.to_thread(
            password_hasher.verify,
            plain_password,
            DUMMY_HASH
        )
        return False, None
    return await verify_password(plain_password, hashed_password)


def create_access_token(
    user_id: UUID,
    extra_claims: dict[str,
                       Any] | None = None,
) -> str:
    """
    Create a short lived access token
    """
    now = datetime.now(UTC)
    payload = {
        "sub": str(user_id),
        "type": TokenType.ACCESS.value,
        "iat": now,
        "exp":
        now + timedelta(minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES),
    }
    if extra_claims:
        payload.update(extra_claims)

    return jwt.encode(
        payload,
        settings.SECRET_KEY.get_secret_value(),
        algorithm = settings.JWT_ALGORITHM,
    )


def decode_access_token(token: str) -> dict[str, Any]:
    """
    Decode and validate an access token
    """
    return jwt.decode(
        token,
        settings.SECRET_KEY.get_secret_value(),
        algorithms = [settings.JWT_ALGORITHM],
        options = {"require": ["exp",
                               "sub",
                               "iat",
                               "type"]},
    )

```

---

## File Overview

### security.py

**Purpose and Responsibility:**
This Python file is responsible for handling user authentication and authorization within a web application. It includes functions for password hashing, verification, token creation, and decoding.

**Key Exports or Public Interface:**
- `hash_password`: Asynchronously hashes a plain text password.
- `verify_password`: Verifies a password and checks if rehashing is needed.
- `verify_password_with_timing_safety`: Ensures constant time behavior during password verification to prevent timing attacks.
- `create_access_token`: Generates an access token for user authentication, including optional extra claims.
- `decode_access_token`: Decodes and validates an access token.

**How it Fits in the Project:**
This file is a crucial component of the application's security infrastructure. It integrates with other modules like `config` to manage settings and provides essential functions for secure user management. The tokens generated here are used throughout the application to authenticate users, ensuring that sensitive operations can only be performed by authorized individuals.

**Notable Design Decisions:**
- **Asynchronous Operations:** Functions use `asyncio.to_thread` to offload CPU-intensive tasks like hashing and verification to separate threads.
- **Timing Safety:** The `verify_password_with_timing_safety` function ensures constant time behavior during password checks, mitigating timing attack risks.
- **JWT Implementation:** Tokens are created using the `jwt` library with configurable settings from the application's configuration file.
```

This documentation provides a high-level overview of the file's purpose, key functions, and integration within the project. It highlights important design choices to ensure security and performance.

---

*Generated by CodeWorm on 2026-02-18 20:44*
