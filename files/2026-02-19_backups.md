# backups

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/handler/backups.go
**Language:** go
**Lines:** 1-166
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
backups.go
*/

package handler

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi/v5"

	"github.com/carterperez-dev/templates/go-backend/internal/core"
	"github.com/carterperez-dev/templates/go-backend/internal/sqlite"
)

type backupService interface {
	TriggerBackup(ctx context.Context, dbName, triggeredBy string) (*sqlite.Backup, error)
	RestoreBackup(ctx context.Context, backupID string) error
	ListBackups(ctx context.Context, limit int) ([]*sqlite.Backup, error)
	GetBackup(ctx context.Context, id string) (*sqlite.Backup, error)
	DeleteBackup(ctx context.Context, id string) error
}

type BackupsHandler struct {
	service  backupService
	database string
}

func NewBackupsHandler(service backupService, database string) *BackupsHandler {
	return &BackupsHandler{
		service:  service,
		database: database,
	}
}

func (h *BackupsHandler) RegisterRoutes(r chi.Router) {
	r.Route("/api/backups", func(r chi.Router) {
		r.Get("/", h.List)
		r.Post("/", h.Create)
		r.Get("/{id}", h.Get)
		r.Delete("/{id}", h.Delete)
		r.Post("/{id}/restore", h.Restore)
	})
}

type BackupResponse struct {
	ID           string     `json:"id"`
	DatabaseName string     `json:"database_name"`
	FilePath     string     `json:"file_path"`
	SizeBytes    int64      `json:"size_bytes"`
	SizeMB       float64    `json:"size_mb"`
	StartedAt    time.Time  `json:"started_at"`
	CompletedAt  *time.Time `json:"completed_at,omitempty"`
	Status       string     `json:"status"`
	ErrorMessage string     `json:"error_message,omitempty"`
	TriggeredBy  string     `json:"triggered_by"`
}

func toBackupResponse(b *sqlite.Backup) *BackupResponse {
	resp := &BackupResponse{
		ID:           b.ID,
		DatabaseName: b.DatabaseName,
		FilePath:     b.FilePath,
		SizeBytes:    b.SizeBytes,
		SizeMB:       float64(b.SizeBytes) / (1024 * 1024),
		StartedAt:    b.StartedAt,
		Status:       b.Status,
		TriggeredBy:  b.TriggeredBy,
	}
	if b.CompletedAt.Valid {
		resp.CompletedAt = &b.CompletedAt.Time
	}
	if b.ErrorMessage.Valid {
		resp.ErrorMessage = b.ErrorMessage.String
	}
	return resp
}

func (h *BackupsHandler) List(w http.ResponseWriter, r *http.Request) {
	limit := 50
	if l := r.URL.Query().Get("limit"); l != "" {
		if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 && parsed <= 100 {
			limit = parsed
		}
	}

	backups, err := h.service.ListBackups(r.Context(), limit)
	if err != nil {
		core.InternalServerError(w, err)
		return
	}

	response := make([]*BackupResponse, len(backups))
	for i, b := range backups {
		response[i] = toBackupResponse(b)
	}

	core.OK(w, response)
}

type CreateBackupRequest struct {
	DatabaseName string `json:"database_name"`
}

func (h *BackupsHandler) Create(w http.ResponseWriter, r *http.Request) {
	var req CreateBackupRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		req.DatabaseName = h.database
	}

	if req.DatabaseName == "" {
		req.DatabaseName = h.database
	}

	backup, err := h.serv
```

---

## File Overview

### Purpose and Responsibility

This file, `backups.go`, is responsible for managing database backups within a Go backend application. It provides an API to trigger, list, get details of, delete, and restore database backups.

### Key Exports and Public Interface

- **BackupsHandler**: A handler struct that registers routes for backup operations.
- **CreateBackupRequest**: A request structure for creating new backups.
- `List`, `Create`, `Get`, `Delete`, and `Restore` methods: These handle HTTP requests related to backup management.

### How It Fits into the Project

This file is part of the handler package, which contains business logic for various operations. The `BackupsHandler` integrates with a `backupService` interface to interact with database backups stored in SQLite. It registers routes under `/api/backups`, allowing external clients to manage backups via HTTP requests.

### Notable Design Decisions

- **Dependency Injection**: The `BackupsHandler` constructor accepts an implementation of the `backupService` interface, promoting loose coupling.
- **Error Handling**: Errors are handled using custom error responses (`InternalServerError`, `NotFound`, etc.), ensuring consistent error management across handlers.
- **Pagination and Filtering**: The `List` method supports pagination through query parameters.
- **JSON Marshaling**: Custom marshaling logic in `toBackupResponse` ensures that backup data is returned in a structured JSON format suitable for API consumption.

---

*Generated by CodeWorm on 2026-02-19 23:47*
