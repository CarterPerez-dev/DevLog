# api.config

**Type:** File Overview
**Repository:** ios-test
**File:** red-recon/src/core/api/api.config.ts
**Language:** typescript
**Lines:** 1-205
**Complexity:** 0.0

---

## Source Code

```typescript
// ===================
// Â© AngelaMos | 2026
// api.config.ts
// ===================

import { API_ENDPOINTS, HTTP_STATUS } from '@/core/config'
import { SECURE_KEYS, secureStorage } from '@/core/storage'
import axios, {
  type AxiosError,
  type AxiosInstance,
  type InternalAxiosRequestConfig,
} from 'axios'
import { ApiError, ApiErrorCode, transformAxiosError } from './errors'

interface RequestConfig extends InternalAxiosRequestConfig {
  _retry?: boolean
}

interface RefreshSubscriber {
  resolve: (token: string) => void
  reject: (error: Error) => void
}

interface RefreshResponse {
  access_token: string
  refresh_token: string
}

const YOUR_DEV_IP = '192.168.1.167'
const YOUR_DEV_PORT = '8501'
const YOUR_PROD_API_URL = 'https://api.carterperez-dev.com'


const getBaseURL = (): string => {
  if (__DEV__) {
    return `http://${YOUR_DEV_IP}:${YOUR_DEV_PORT}`
  }
  return YOUR_PROD_API_URL
}

export const apiClient: AxiosInstance = axios.create({
  baseURL: getBaseURL(),
  timeout: 15000,
  headers: { 'Content-Type': 'application/json' },
})

let isRefreshing = false
let refreshSubscribers: RefreshSubscriber[] = []
let accessToken: string | null = null

export const setAccessToken = (token: string | null): void => {
  accessToken = token
}

export const getAccessToken = (): string | null => {
  return accessToken
}

const processRefreshQueue = (error: Error | null, token: string | null): void => {
  refreshSubscribers.forEach((subscriber) => {
    if (error !== null) {
      subscriber.reject(error)
    } else if (token !== null) {
      subscriber.resolve(token)
    }
  })
  refreshSubscribers = []
}

const addRefreshSubscriber = (
  resolve: (token: string) => void,
  reject: (error: Error) => void
): void => {
  refreshSubscribers.push({ resolve, reject })
}

const handleTokenRefresh = async (): Promise<RefreshResponse> => {
  const refreshToken = await secureStorage.getItem(SECURE_KEYS.REFRESH_TOKEN)

  if (!refreshToken) {
    throw new ApiError(
      'No refresh token',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  const response = await apiClient.post<RefreshResponse>(
    API_ENDPOINTS.AUTH.REFRESH_MOBILE,
    { refresh_token: refreshToken }
  )

  if (
    response.data === null ||
    response.data === undefined ||
    typeof response.data !== 'object'
  ) {
    throw new ApiError(
      'Invalid refresh response',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  const { access_token, refresh_token: newRefreshToken } = response.data

  if (typeof access_token !== 'string' || access_token.length === 0) {
    throw new ApiError(
      'Invalid access token',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  await secureStorage.setItem(SECURE_KEYS.REFRESH_TOKEN, newRefreshToken)

  return response.data
}

let onAuthFailure: (() => void) | null = null

export const setAuthFailureHandler = (handler: () => void): void => {
  onA
```

---

## File Overview

# api.config.ts

## Purpose and Responsibility
This TypeScript file configures and manages the Axios instance for API requests, handling authentication, token refreshing, and error management.

## Key Exports and Public Interface
- **`apiClient: AxiosInstance`**: The configured Axios instance used throughout the application.
- **`setAccessToken(token: string | null): void`**: Sets the access token.
- **`getAccessToken(): string | null`**: Retrieves the current access token.
- **`handleTokenRefresh(): Promise<RefreshResponse>`**: Handles refreshing the access token.
- **`setAuthFailureHandler(handler: () => void): void`**: Sets a handler for authentication failures.

## How it Fits in the Project
This file is central to API interactions, ensuring consistent and secure communication with the backend. It integrates with other core modules like storage and error handling, making it a crucial component of the application's network layer.

## Notable Design Decisions
- **Token Refresh Queue**: A queue for refreshing tokens ensures that multiple requests during token refresh are handled gracefully.
- **Interceptors**: Request and response interceptors manage headers and errors, enhancing maintainability and reducing boilerplate code.
- **Conditional Retry Mechanism**: The retry mechanism only triggers on unauthorized responses from non-auth endpoints, optimizing performance and user experience.
```

This documentation provides a high-level overview of the file's role in the project, its key exports, and notable design choices.

---

*Generated by CodeWorm on 2026-02-20 14:56*
