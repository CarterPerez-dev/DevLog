# api.config

**Type:** File Overview
**Repository:** social-media-notes
**File:** frontend/src/core/api/api.config.ts
**Language:** typescript
**Lines:** 1-158
**Complexity:** 0.0

---

## Source Code

```typescript
/**
 * AngelaMos | 2025
 * api.config.ts
 */

import axios, {
  type AxiosError,
  type AxiosInstance,
  type InternalAxiosRequestConfig,
} from 'axios'
import { router } from 'expo-router'
import { API_BASE_URL, API_ENDPOINTS, HTTP_STATUS } from '@/config'
import { useAuthStore } from '@/core/lib'
import { ApiError, ApiErrorCode, transformAxiosError } from './errors'

interface RequestConfig extends InternalAxiosRequestConfig {
  _retry?: boolean
}

interface RefreshSubscriber {
  resolve: (token: string) => void
  reject: (error: Error) => void
}

export const apiClient: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 15000,
  headers: { 'Content-Type': 'application/json' },
  withCredentials: true,
})

let isRefreshing = false
let refreshSubscribers: RefreshSubscriber[] = []

const processRefreshQueue = (error: Error | null, token: string | null): void => {
  refreshSubscribers.forEach((subscriber) => {
    if (error !== null) {
      subscriber.reject(error)
    } else if (token !== null) {
      subscriber.resolve(token)
    }
  })
  refreshSubscribers = []
}

const addRefreshSubscriber = (
  resolve: (token: string) => void,
  reject: (error: Error) => void
): void => {
  refreshSubscribers.push({ resolve, reject })
}

const handleTokenRefresh = async (): Promise<string> => {
  const response = await apiClient.post<{ access_token: string }>(
    API_ENDPOINTS.AUTH.REFRESH
  )

  if (
    response.data === null ||
    response.data === undefined ||
    typeof response.data !== 'object'
  ) {
    throw new ApiError(
      'Invalid refresh response',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  const accessToken = response.data.access_token
  if (typeof accessToken !== 'string' || accessToken.length === 0) {
    throw new ApiError(
      'Invalid access token',
      ApiErrorCode.AUTHENTICATION_ERROR,
      HTTP_STATUS.UNAUTHORIZED
    )
  }

  return accessToken
}

const handleAuthFailure = (): void => {
  useAuthStore.getState().logout()
  router.replace('/login')
}

apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig): InternalAxiosRequestConfig => {
    const token = useAuthStore.getState().accessToken
    if (token !== null && token.length > 0) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error: unknown): Promise<never> => {
    return Promise.reject(error)
  }
)

apiClient.interceptors.response.use(
  (response) => response,
  async (error: AxiosError): Promise<unknown> => {
    const originalRequest = error.config as RequestConfig | undefined

    if (originalRequest === undefined) {
      return Promise.reject(transformAxiosError(error))
    }

    const isUnauthorized = error.response?.status === HTTP_STATUS.UNAUTHORIZED
    const isNotRetried = originalRequest._retry !== true
    const isNotRefreshEndpoint =
      originalRequest.url?.includes(API_ENDPOINTS.AUTH.REFRESH) !== true

    if (isUnauthorized && isNo
```

---

## File Overview

### Documenting `api.config.ts`

**Purpose and Responsibility:**
This file configures and manages Axios instances for API requests, handling authentication tokens, token refreshes, and error management within a TypeScript application.

**Key Exports or Public Interface:**
- **`apiClient`:** An Axios instance configured with base URL, headers, and timeout.
- **`handleTokenRefresh()`:** A function to handle token refreshing on unauthorized access.
- **Interceptors:** Request and response interceptors for adding authentication tokens, handling errors, and managing token refreshes.

**How it Fits in the Project:**
This file is crucial for maintaining a consistent API client across the application. It integrates with the `useAuthStore` to manage user authentication states and redirects users to the login page upon unauthorized access. The Axios instance is used throughout the project for making HTTP requests, ensuring that all API calls are properly authenticated.

**Notable Design Decisions:**
- **Token Refresh Queue:** A queue system ensures that multiple refresh attempts do not overlap.
- **Error Handling:** Custom error handling and transformation to provide meaningful errors using `ApiError`.
- **Interceptors:** Utilizing Axios interceptors for request and response management, ensuring consistent behavior across all API calls.

---

*Generated by CodeWorm on 2026-02-20 21:52*
