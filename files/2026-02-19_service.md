# service

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/backup/service.go
**Language:** go
**Lines:** 1-182
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
service.go
*/

package backup

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/google/uuid"

	"github.com/carterperez-dev/templates/go-backend/internal/sqlite"
)

type backupRepository interface {
	Create(ctx context.Context, b *sqlite.Backup) error
	UpdateStatus(ctx context.Context, id, status, filePath string, sizeBytes int64, errorMsg string) error
	GetByID(ctx context.Context, id string) (*sqlite.Backup, error)
	ListRecent(ctx context.Context, limit int) ([]*sqlite.Backup, error)
	Delete(ctx context.Context, id string) error
	DeleteOlderThan(ctx context.Context, days int) (int64, error)
}

type Service struct {
	executor      *Executor
	scheduler     *Scheduler
	repo          backupRepository
	retentionDays int
	logger        *slog.Logger
}

func NewService(executor *Executor, scheduler *Scheduler, repo backupRepository, retentionDays int, logger *slog.Logger) *Service {
	s := &Service{
		executor:      executor,
		scheduler:     scheduler,
		repo:          repo,
		retentionDays: retentionDays,
		logger:        logger,
	}

	scheduler.SetBackupFunc(s.runBackup)

	return s
}

func (s *Service) TriggerBackup(ctx context.Context, dbName, triggeredBy string) (*sqlite.Backup, error) {
	return s.createBackup(ctx, dbName, triggeredBy)
}

func (s *Service) runBackup(ctx context.Context, dbName string) error {
	_, err := s.createBackup(ctx, dbName, "scheduled")
	return err
}

func (s *Service) createBackup(ctx context.Context, dbName, triggeredBy string) (*sqlite.Backup, error) {
	backup := &sqlite.Backup{
		ID:           uuid.New().String(),
		DatabaseName: dbName,
		FilePath:     "",
		SizeBytes:    0,
		StartedAt:    time.Now(),
		Status:       "running",
		TriggeredBy:  triggeredBy,
	}

	if err := s.repo.Create(ctx, backup); err != nil {
		return nil, fmt.Errorf("create backup record: %w", err)
	}

	result, err := s.executor.Execute(ctx, dbName)
	if err != nil {
		s.repo.UpdateStatus(ctx, backup.ID, "failed", "", 0, err.Error())
		return nil, fmt.Errorf("execute backup: %w", err)
	}

	backup.FilePath = result.FilePath
	backup.SizeBytes = result.SizeBytes
	backup.Status = "completed"

	if err := s.repo.UpdateStatus(ctx, backup.ID, "completed", result.FilePath, result.SizeBytes, ""); err != nil {
		return nil, fmt.Errorf("update backup status: %w", err)
	}

	s.logger.Info("backup completed",
		"id", backup.ID,
		"database", dbName,
		"size_bytes", result.SizeBytes,
		"duration", result.Duration,
	)

	go s.cleanupOldBackups()

	return backup, nil
}

func (s *Service) RestoreBackup(ctx context.Context, backupID string) error {
	backup, err := s.repo.GetByID(ctx, backupID)
	if err != nil {
		return fmt.Errorf("get backup: %w", err)
	}
	if backup == nil {
		return fmt.Errorf("backup not found")
	}

	if err := s.executor.Restore(ctx, backup.FilePath, backup.DatabaseName); err != nil {
		return fmt.Errorf("restore backup: %w", err)
	}

	s.logger.Info("backup restored", "id", backupID, "database", backup.DatabaseName)
	retur
```

---

## File Overview

# service.go

## Purpose and Responsibility
This Go source file defines the `Service` struct for managing database backups within a larger application. It handles creating, restoring, listing, and cleaning up backup records.

## Key Exports and Public Interface
- **Service**: The primary interface for interacting with backup operations.
  - `NewService`: Initializes the service with necessary dependencies.
  - `TriggerBackup`, `runBackup`: Triggers a backup manually or via scheduling.
  - `createBackup`: Executes the backup process and updates its status.
  - `RestoreBackup`: Restores a previously created backup.
  - `ListBackups`, `GetBackup`, `DeleteBackup`: Manage backup records in the database.
  - `cleanupOldBackups`: Cleans up old backups based on retention policy.
  - `SetupDailyBackup`, `StartScheduler`, `StopScheduler`: Configure and control the scheduler for automated backups.

## How it Fits into the Project
The `Service` struct is a central component that interacts with both the database via the `backupRepository` interface and the backup execution logic through the `Executor`. It integrates with the scheduler to automate backup processes, ensuring data integrity and availability. The service provides a clean API for other parts of the application to interact with backup operations.

## Notable Design Decisions
- **Error Handling**: Errors are handled using Go's idiomatic error propagation.
- **Context Usage**: Context is used throughout to manage lifecycle and timeouts.
- **Goroutines**: Background tasks like cleanup are executed in goroutines for non-blocking behavior.
- **Interfaces**: The `backupRepository` interface decouples the service from specific database implementations, promoting flexibility and testability.

---

*Generated by CodeWorm on 2026-02-19 23:32*
