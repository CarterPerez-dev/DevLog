# service

**Type:** File Overview
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/user/service.go
**Language:** go
**Lines:** 1-257
**Complexity:** 0.0

---

## Source Code

```go
// AngelaMos | 2026
// service.go

package user

import (
	"context"
	"fmt"
	"strings"

	"github.com/google/uuid"

	"github.com/carterperez-dev/templates/go-backend/internal/auth"
	"github.com/carterperez-dev/templates/go-backend/internal/core"
)

type Service struct {
	repo Repository
}

func NewService(repo Repository) *Service {
	return &Service{repo: repo}
}

func (s *Service) GetByID(
	ctx context.Context,
	id string,
) (*auth.UserInfo, error) {
	user, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return toUserInfo(user), nil
}

func (s *Service) GetByEmail(
	ctx context.Context,
	email string,
) (*auth.UserInfo, error) {
	user, err := s.repo.GetByEmail(ctx, strings.ToLower(email))
	if err != nil {
		return nil, err
	}

	return toUserInfo(user), nil
}

func (s *Service) Create(
	ctx context.Context,
	email, passwordHash, name string,
) (*auth.UserInfo, error) {
	user := &User{
		ID:           uuid.New().String(),
		Email:        strings.ToLower(email),
		PasswordHash: passwordHash,
		Name:         name,
		Role:         RoleUser,
		Tier:         TierFree,
	}

	if err := s.repo.Create(ctx, user); err != nil {
		return nil, err
	}

	return toUserInfo(user), nil
}

func (s *Service) IncrementTokenVersion(
	ctx context.Context,
	userID string,
) error {
	return s.repo.IncrementTokenVersion(ctx, userID)
}

func (s *Service) UpdatePassword(
	ctx context.Context,
	userID, passwordHash string,
) error {
	return s.repo.UpdatePassword(ctx, userID, passwordHash)
}

func (s *Service) GetUser(ctx context.Context, id string) (*User, error) {
	return s.repo.GetByID(ctx, id)
}

func (s *Service) UpdateUser(
	ctx context.Context,
	id string,
	req UpdateUserRequest,
) (*User, error) {
	user, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	if req.Name != nil {
		user.Name = *req.Name
	}

	if err := s.repo.Update(ctx, user); err != nil {
		return nil, err
	}

	return user, nil
}

func (s *Service) UpdateUserRole(
	ctx context.Context,
	id, role string,
) (*User, error) {
	if role != RoleUser && role != RoleAdmin {
		return nil, fmt.Errorf(
			"update role: invalid role %q: %w",
			role,
			core.ErrInvalidInput,
		)
	}

	user, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	user.Role = role

	if err := s.repo.Update(ctx, user); err != nil {
		return nil, err
	}

	return user, nil
}

func (s *Service) UpdateUserTier(
	ctx context.Context,
	id, tier string,
) (*User, error) {
	if tier != TierFree && tier != TierPro && tier != TierEnterprise {
		return nil, fmt.Errorf(
			"update tier: invalid tier %q: %w",
			tier,
			core.ErrInvalidInput,
		)
	}

	user, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	user.Tier = tier

	if err := s.repo.Update(ctx, user); err != nil {
		return nil, err
	}

	return user, nil
}

func (s *Service) DeleteUser(ctx context.Context, id string) error {
	return s.repo.SoftDelete(ctx, id)
}

func (s *Service) ListUsers(
	ctx context.Context,
	params
```

---

## File Overview

# service.go

## Purpose and Responsibility
This Go source file defines the `Service` struct for managing user operations within the application. It provides a high-level abstraction layer over the `Repository`, handling CRUD (Create, Read, Update, Delete) operations and other user-related functionalities.

## Key Exports and Public Interface
The key public methods include:
- `GetByID`: Retrieves a user by ID.
- `GetByEmail`: Fetches a user by email.
- `Create`: Registers a new user.
- `IncrementTokenVersion`, `UpdatePassword`: Update token version and password for a user.
- `UpdateUser`, `UpdateUserRole`, `UpdateUserTier`: Modify user attributes.
- `DeleteUser`, `ListUsers`: Delete or list users.
- `GetMe`, `UpdateMe`, `DeleteMe`: Handle authenticated user operations.
- `EmailExists`: Checks if an email is already registered.
- `CanDeleteUser`: Validates permission to delete a user.

## How It Fits in the Project
This service layer sits between the repository and higher-level controllers or services, ensuring that business logic related to users is encapsulated. It leverages interfaces from the `auth` package for authentication purposes and interacts with the `Repository` to persist data.

## Notable Design Decisions
- **Error Handling**: Errors are returned using standard Go error handling practices.
- **Context Usage**: Contexts are used throughout to manage cancellation, deadlines, and other request-scoped values.
- **ID Generation**: UUIDs are generated for new user IDs.
- **Role and Tier Validation**: Functions validate role and tier updates against predefined constants.
- **Soft Delete**: Users can be soft-deleted using the `repo.SoftDelete` method.

---

*Generated by CodeWorm on 2026-02-19 16:39*
