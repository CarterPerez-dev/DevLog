# lib

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/lib.rs
**Language:** rust
**Lines:** 1-301
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Â©AngelaMos | 2025
 * Core Library Module
 */

pub mod database;
pub mod models;
pub mod routes;
pub mod services;
pub mod utils;

pub use utils::{
    config::Config,
    error::{AppError, Result},
    metrics::MetricsCollector,
};

pub use database::{
    connection::{DatabasePool, create_pool},
};

pub use models::{
    github::{Repository, RepositoryStats, GitHubUser},
    fractals::{FractalRequest, FractalResponse, FractalType},
    performance::{PerformanceMetric, SystemInfo, BenchmarkResult},
};

pub use services::{
    github_service::GitHubService,
    fractal_service::FractalService,
    performance_service::PerformanceService,
    cache_service::CacheService,
};

#[derive(Clone)]
pub struct AppState {
    pub db_pool: DatabasePool,
    pub redis_client: redis::Client,
    pub github_service: GitHubService,
    pub fractal_service: FractalService,
    pub performance_service: PerformanceService,
    pub cache_service: CacheService,
    pub config: Config,
    pub metrics: MetricsCollector,
}

impl AppState {
    pub async fn new(config: Config) -> Result<Self> {
        let db_pool = create_pool(&config.database_url).await?;

        let redis_client = redis::Client::open(config.redis_url.clone())
            .map_err(|e| AppError::DatabaseError(format!("Redis connection failed: {}", e)))?;

        let metrics = MetricsCollector::new()?;

        let cache_service = CacheService::new(redis_client.clone());
        let github_service = GitHubService::new(
            config.github_token.clone(),
            cache_service.clone(),
        );
        let fractal_service = FractalService::new();
        let performance_service = PerformanceService::new(
            db_pool.clone(),
        );

        Ok(AppState {
            db_pool,
            redis_client,
            github_service,
            fractal_service,
            performance_service,
            cache_service,
            config,
            metrics,
        })
    }

    pub async fn health_check(&self) -> Result<serde_json::Value> {
        use sqlx::Row;

        let db_status = match sqlx::query("SELECT 1 as test")
            .fetch_one(&self.db_pool)
            .await
        {
            Ok(_) => "healthy",
            Err(_) => "unhealthy",
        };

        let mut conn = self.redis_client.get_async_connection().await
            .map_err(|e| AppError::DatabaseError(format!("Redis connection failed: {}", e)))?;

        let redis_status = match redis::cmd("PING")
            .query_async::<_, String>(&mut conn)
            .await
        {
            Ok(_) => "healthy",
            Err(_) => "unhealthy",
        };

        let system_info_json = self.performance_service.get_system_info().await?;

        Ok(serde_json::json!({
            "status": if db_status == "healthy" && redis_status == "healthy" { "healthy" } else { "unhealthy" },
            "timestamp": chrono::Utc::now(),
            "services": {
                "database": db_status,
        
```

---

## File Overview

# File Documentation for `src/lib.rs`

## Purpose and Responsibility

This file serves as the core module of the `kill-pr0cess.inc` backend, providing essential components and services required by the application. It includes modules for database operations, model definitions, API routes, service implementations, and utility functions.

## Key Exports and Public Interface

- **AppState**: A struct representing the state of the application, containing references to various services and utilities.
- **Result**: An alias for `std::result::Result` with custom error handling using `AppError`.
- **Config**: Configuration settings used throughout the application.
- **MetricsCollector**: A utility for collecting and reporting metrics.
- **time_operation!**: A macro for timing operations and recording durations in metrics.
- **cached_operation!**: A macro for caching operation results to reduce redundant computations.

## How It Fits into the Project

This file acts as a central hub, importing and exporting necessary components from various sub-modules. `AppState` is used by the main application entry point to manage state across different services. The utility macros provide convenient ways to handle timing and caching, enhancing performance and observability.

## Notable Design Decisions

- **Ownership and Borrowing**: `AppState` holds references to services and utilities, ensuring proper resource management.
- **Result/Option Patterns**: Custom error handling using `AppError` ensures robust error propagation.
- **Dependencies and Lifetimes**: Proper lifetimes are managed to prevent dangling references and ensure safe usage of shared resources like database connections and Redis clients.

This design supports a modular and maintainable architecture, facilitating easier testing and scalability.

---

*Generated by CodeWorm on 2026-02-19 21:05*
