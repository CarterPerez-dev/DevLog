# categorize

**Type:** File Overview
**Repository:** Yoshi-Audit
**File:** internal/docker/categorize.go
**Language:** go
**Lines:** 1-104
**Complexity:** 0.0

---

## Source Code

```go
// Â©AngelaMos | 2026
// categorize.go

package docker

import (
	"strings"
)

type SafetyCategory int

const (
	CategorySafe         SafetyCategory = 1
	CategoryProbablySafe SafetyCategory = 2
	CategoryCheckFirst   SafetyCategory = 3
	CategoryDoNotTouch   SafetyCategory = 4
)

func CategorizeImage(img ImageInfo, protectionPatterns []string) SafetyCategory {
	if img.Dangling && img.Containers == 0 {
		return CategorySafe
	}

	if img.Containers > 0 {
		return CategoryDoNotTouch
	}

	pe := NewProtectionEngine(protectionPatterns)
	fullName := img.Repository
	if img.Tag != "<none>" {
		fullName = img.Repository + ":" + img.Tag
	}
	if pe.MatchesPattern(fullName) || pe.MatchesPattern(img.Repository) {
		return CategoryDoNotTouch
	}

	return CategoryProbablySafe
}

func CategorizeVolume(vol VolumeInfo, protectionPatterns []string) SafetyCategory {
	pe := NewProtectionEngine(protectionPatterns)
	if pe.MatchesPattern(vol.Name) {
		return CategoryDoNotTouch
	}

	if strings.Contains(strings.ToLower(vol.Name), "backup") {
		return CategoryCheckFirst
	}

	if vol.Links > 0 {
		return CategoryDoNotTouch
	}

	if looksLikeHash(vol.Name) && vol.Size <= 0 {
		return CategorySafe
	}

	if vol.Name != "" && vol.Size > 0 {
		return CategoryProbablySafe
	}

	return CategorySafe
}

func CategorizeContainer(ctr ContainerInfo, protectionPatterns []string) SafetyCategory {
	if ctr.Running {
		return CategoryDoNotTouch
	}

	pe := NewProtectionEngine(protectionPatterns)
	if pe.MatchesPattern(ctr.Name) || pe.MatchesPattern(ctr.Image) {
		return CategoryDoNotTouch
	}

	return CategoryProbablySafe
}

func CategoryLabel(cat SafetyCategory) string {
	switch cat {
	case CategorySafe:
		return "SAFE"
	case CategoryProbablySafe:
		return "PROBABLY SAFE"
	case CategoryCheckFirst:
		return "CHECK FIRST"
	case CategoryDoNotTouch:
		return "DO NOT TOUCH"
	default:
		return "UNKNOWN"
	}
}

func looksLikeHash(name string) bool {
	if len(name) < 32 {
		return false
	}
	for _, c := range name {
		if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {
			return false
		}
	}
	return true
}

```

---

## File Overview

# categorize.go

## Purpose and Responsibility
This Go source file is responsible for categorizing Docker images, volumes, and containers based on their properties and protection patterns defined by security policies. The categorization helps determine the safety level of these Docker objects, guiding users on whether they should interact with them or not.

## Key Exports and Public Interface
- `CategorizeImage`: Determines the safety category for a given image.
- `CategorizeVolume`: Evaluates the safety category for a volume.
- `CategorizeContainer`: Classifies the safety category of a container.
- `CategoryLabel`: Converts a `SafetyCategory` to its corresponding label.

## How It Fits in the Project
This file is part of the `docker` package within the `Yoshi-Audit` project. It provides essential functionality for assessing Docker assets, which is crucial for security audits and compliance checks. The categorization logic ensures that sensitive or critical objects are handled with care, while less risky ones can be managed more freely.

## Notable Design Decisions
- **Safety Categories**: Uses an enumerated type `SafetyCategory` to represent different levels of safety.
- **Protection Patterns**: Utilizes a `ProtectionEngine` to match patterns against object names and images, ensuring flexibility in defining security policies.
- **Error Handling and Goroutines**: While not explicitly shown here, the design follows Go idioms for error handling and goroutine usage, though this file focuses on synchronous operations.
- **String Manipulation**: Functions like `looksLikeHash` demonstrate a pragmatic approach to pattern recognition, leveraging string processing techniques common in Go.
```

This documentation provides an overview of the file's purpose, key functionalities, integration within the project, and notable design choices.

---

*Generated by CodeWorm on 2026-03-01 11:20*
