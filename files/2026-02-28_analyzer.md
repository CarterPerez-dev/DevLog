# analyzer

**Type:** File Overview
**Repository:** CodeWorm
**File:** codeworm/analysis/analyzer.py
**Language:** python
**Lines:** 1-297
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
analysis/analyzer.py
"""
from __future__ import annotations

import random
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

from git import InvalidGitRepositoryError, Repo

from codeworm.analysis.complexity import ComplexityAnalyzer, ComplexityMetrics
from codeworm.analysis.parser import CodeExtractor, ParsedFunction, ParserManager
from codeworm.analysis.scanner import RepoScanner, ScannedFile, WeightedRepoSelector
from codeworm.analysis.scoring import GitStats, InterestScore, InterestScorer
from codeworm.models import CodeSnippet

if TYPE_CHECKING:
    from collections.abc import Iterator

    from codeworm.core.config import AnalyzerSettings, RepoEntry


@dataclass
class AnalysisCandidate:
    """
    A code snippet candidate for documentation
    """
    snippet: CodeSnippet
    parsed_function: ParsedFunction
    complexity: ComplexityMetrics | None
    git_stats: GitStats
    interest_score: InterestScore
    scanned_file: ScannedFile

    @property
    def score(self) -> float:
        return self.interest_score.total

    @property
    def is_worth_documenting(self) -> bool:
        """
        Check if this candidate meets minimum thresholds
        """
        return self.score >= 25 and self.snippet.line_count >= 10


class CodeAnalyzer:
    """
    Main code analysis engine
    Combines parsing, complexity analysis, and interest scoring
    """
    def __init__(
        self,
        repos: list[RepoEntry],
        settings: AnalyzerSettings | None = None,
    ) -> None:
        """
        Initialize analyzer with repository configurations
        """
        self.repos = repos
        self.settings = settings
        self.repo_selector = WeightedRepoSelector(repos)
        self.scanner = RepoScanner(
            include_patterns = settings.include_patterns if settings else None,
            exclude_patterns = settings.exclude_patterns if settings else None,
        )
        self.complexity_analyzer = ComplexityAnalyzer()
        self.scorer = InterestScorer()

        self._git_repos: dict[Path, Repo | None] = {}

        ParserManager.initialize()

    def _get_git_repo(self, repo_path: Path) -> Repo | None:
        """
        Get or create git repo instance for a path
        """
        if repo_path in self._git_repos:
            return self._git_repos[repo_path]
        try:
            repo = Repo(repo_path, search_parent_directories=True)
            git_root = Path(repo.working_dir)
            if git_root in self._git_repos:
                repo.close()
                self._git_repos[repo_path] = self._git_repos[git_root]
            else:
                self._git_repos[git_root] = repo
                self._git_repos[repo_path] = repo
        except InvalidGitRepositoryError:
            self._git_repos[repo_path] = None
        return self._git_repos[repo_path]

    def close_repos(self) -> None:
        """
        Close all cached git repo handles and 
```

---

## File Overview

### analyzer.py

**Purpose and Responsibility:**
This Python file serves as the central analysis engine for CodeWorm, a tool designed to automate code documentation. It integrates various components like complexity analysis, parsing, and interest scoring to identify and prioritize code snippets worthy of documentation.

**Key Exports and Public Interface:**
- **AnalysisCandidate:** A data class representing a candidate code snippet for documentation.
- **CodeAnalyzer:** The main analysis engine that combines parsing, complexity analysis, and interest scoring. It initializes with repository configurations and provides methods to analyze files and close cached git repositories.

**How it Fits into the Project:**
`analyzer.py` acts as the core module in CodeWorm's analysis pipeline. It leverages other modules such as `complexity`, `parser`, and `scoring` for detailed code analysis. The `CodeAnalyzer` class orchestrates these components, making decisions on which code snippets are worth documenting based on complexity metrics and interest scores.

**Notable Design Decisions:**
- **Decoupling:** The design separates concerns by using data classes like `AnalysisCandidate`, ensuring that the core logic remains clean and focused.
- **Lazy Initialization:** Git repository instances are lazily created to optimize resource usage, especially when dealing with multiple repositories.
- **Error Handling:** Robust error handling ensures that exceptions do not disrupt the analysis process, making the tool more resilient.
```

This documentation provides a high-level overview of the file's role within the project and highlights key design choices.

---

*Generated by CodeWorm on 2026-02-28 09:05*
