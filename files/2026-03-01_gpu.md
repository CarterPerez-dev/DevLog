# gpu

**Type:** File Overview
**Repository:** Yoshi-Audit
**File:** internal/system/gpu.go
**Language:** go
**Lines:** 1-110
**Complexity:** 0.0

---

## Source Code

```go
// Â©AngelaMos | 2026
// gpu.go

package system

import (
	"fmt"
	"os/exec"
	"strconv"
	"strings"
)

type GPUInfo struct {
	Utilization float64
	UsedVRAM    uint64
	TotalVRAM   uint64
}

func (g GPUInfo) VRAMPercent() float64 {
	if g.TotalVRAM == 0 {
		return 0
	}
	return float64(g.UsedVRAM) / float64(g.TotalVRAM) * 100
}

type GPUProcess struct {
	PID      int
	UsedVRAM uint64
}

func GetGPUInfo() (GPUInfo, error) {
	out, err := exec.Command(
		"nvidia-smi",
		"--query-gpu=utilization.gpu,memory.used,memory.total",
		"--format=csv,noheader,nounits",
	).Output()
	if err != nil {
		return GPUInfo{}, fmt.Errorf("nvidia-smi failed: %w", err)
	}

	line := strings.TrimSpace(string(out))
	parts := strings.Split(line, ",")
	if len(parts) < 3 {
		return GPUInfo{}, fmt.Errorf("unexpected nvidia-smi output: %q", line)
	}

	util, err := strconv.ParseFloat(strings.TrimSpace(parts[0]), 64)
	if err != nil {
		return GPUInfo{}, fmt.Errorf("failed to parse utilization: %w", err)
	}

	usedMiB, err := strconv.ParseUint(strings.TrimSpace(parts[1]), 10, 64)
	if err != nil {
		return GPUInfo{}, fmt.Errorf("failed to parse used memory: %w", err)
	}

	totalMiB, err := strconv.ParseUint(strings.TrimSpace(parts[2]), 10, 64)
	if err != nil {
		return GPUInfo{}, fmt.Errorf("failed to parse total memory: %w", err)
	}

	return GPUInfo{
		Utilization: util,
		UsedVRAM:    usedMiB * 1024 * 1024,
		TotalVRAM:   totalMiB * 1024 * 1024,
	}, nil
}

func GetGPUProcesses() ([]GPUProcess, error) {
	out, err := exec.Command(
		"nvidia-smi",
		"--query-compute-apps=pid,used_memory",
		"--format=csv,noheader,nounits",
	).Output()
	if err != nil {
		return nil, fmt.Errorf("nvidia-smi failed: %w", err)
	}

	var procs []GPUProcess
	lines := strings.Split(strings.TrimSpace(string(out)), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "[") {
			continue
		}

		parts := strings.Split(line, ",")
		if len(parts) < 2 {
			continue
		}

		pid, err := strconv.Atoi(strings.TrimSpace(parts[0]))
		if err != nil {
			continue
		}

		memMiB, err := strconv.ParseUint(strings.TrimSpace(parts[1]), 10, 64)
		if err != nil {
			continue
		}

		procs = append(procs, GPUProcess{
			PID:      pid,
			UsedVRAM: memMiB * 1024 * 1024,
		})
	}

	return procs, nil
}

```

---

## File Overview

# gpu.go

## Purpose and Responsibility
This Go source file is responsible for retrieving GPU utilization, memory usage, and associated processes on systems with NVIDIA GPUs using `nvidia-smi` commands.

## Key Exports and Public Interface
- **GetGPUInfo() (GPUInfo, error)**: Returns a structured `GPUInfo` object containing the current GPU utilization, used VRAM, and total VRAM.
- **GetGPUProcesses() ([]GPUProcess, error)**: Returns a list of `GPUProcess` objects representing processes using the GPU, including their PID and used VRAM.

## How It Fits into the Project
This file is part of the `internal/system` package in the Yoshi-Audit repository. It provides critical system-level information about GPU usage, which can be utilized for performance monitoring or resource management within the application.

## Notable Design Decisions
- **Error Handling**: Errors are handled using Go's idiomatic error propagation via return values.
- **Command Execution**: Utilizes `exec.Command` to execute shell commands safely and parse their output.
- **Data Structures**: Uses simple structs (`GPUInfo`, `GPUProcess`) for clear data representation, adhering to Go's preference for explicit types.
- **Memory Conversion**: Converts memory usage from MiB to bytes by multiplying with 1024 * 1024, ensuring accurate VRAM values.
```

This documentation provides a high-level overview of the file's purpose, key exports, integration within the project, and design choices.

---

*Generated by CodeWorm on 2026-03-01 12:07*
