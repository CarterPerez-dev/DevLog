# archive_service

**Type:** File Overview
**Repository:** CertGames-Core
**File:** backend/api/core/services/archive/archive_service.py
**Language:** python
**Lines:** 1-234
**Complexity:** 0.0

---

## Source Code

```python
"""
Universal Archive Service
/api/core/services/archive/archive_service.py
"""

from bson import ObjectId
from typing import Any, cast
from mongoengine import get_db

from api.core.validation.exceptions import (
    NotFoundError,
    ValidationError,
    BusinessRuleError,
)
from .Archive import Archive, ArchiveReason


class ArchiveService:
    """
    Static methods for archiving/restoring documents from any collection
    """
    @staticmethod
    def archive_document(
        collection_name: str,
        document_id: str | ObjectId,
        reason: ArchiveReason,
        archived_by: str | ObjectId,
        additional_data: dict[str,
                              Any] | None = None
    ) -> dict[str,
              Any]:
        """
        Archive a document by moving it from its original collection to archives
        """
        if not collection_name or not document_id or not reason or not archived_by:
            raise ValidationError(
                "Missing required parameters for archiving"
            )

        doc_id = ObjectId(document_id) if isinstance(
            document_id,
            str
        ) else document_id
        admin_id = ObjectId(archived_by) if isinstance(
            archived_by,
            str
        ) else archived_by

        db = get_db()

        original_doc = db[collection_name].find_one({"_id": doc_id})
        if not original_doc:
            raise NotFoundError(
                f"Document not found in {collection_name}",
                str(doc_id)
            )

        archive_data = {
            "originalId": doc_id,
            "originalCollection": collection_name,
            "archivedBy": admin_id,
            "reason": reason.value,
            "originalData": original_doc
        }

        if additional_data:
            archive_data["originalData"]["_archive_metadata"
                                         ] = additional_data

        archive = Archive(**archive_data)
        archive.save()

        db[collection_name].delete_one({"_id": doc_id})

        return {
            "archive_id": str(archive.id),
            "original_id": str(doc_id),
            "collection": collection_name,
            "reason": reason.value,
            "archived_at": archive.archivedAt.isoformat(),
        }

    @staticmethod
    def restore_document(
        archive_id: str | ObjectId,
        restored_by: str | ObjectId
    ) -> dict[str,
              Any]:
        """
        Restore an archived document back to its original collection
        """
        arch_id = ObjectId(archive_id) if isinstance(
            archive_id,
            str
        ) else archive_id

        archive = Archive.objects(id = arch_id).first()
        if not archive:
            raise NotFoundError("Archive record", str(arch_id))

        db = get_db()

        original_data = archive.originalData.copy()

        if "_archive_metadata" in original_data:
            del original_data["_archive_metadata"]

        exis
```

---

## File Overview

### Universal Archive Service

**Purpose:** This file provides a service for archiving, restoring, and searching documents across various collections within a MongoDB database.

**Key Exports:**
- `archive_document`: Archives a document by moving it to the archives collection.
- `restore_document`: Restores an archived document back to its original collection.
- `get_archive_by_id`: Retrieves a specific archive record by ID.
- `search_archives`: Searches for archived documents using various filters.

**Project Fit:**
This service is part of the core backend infrastructure, handling operations related to archiving and restoring documents. It interacts with MongoDB through `mongoengine` and provides a high-level interface for managing document lifecycle events.

**Design Decisions:**
- **Static Methods:** All methods are static to ensure they can be called without instantiating the class.
- **Validation:** Uses custom exceptions like `ValidationError`, `NotFoundError`, and `BusinessRuleError` for robust error handling.
- **MongoDB Interactions:** Utilizes `mongoengine` to interact with MongoDB, ensuring type safety and ease of use.
- **Pagination Support:** The `search_archives` method supports pagination through the `page` and `limit` parameters.

This service ensures that documents can be safely archived and restored while maintaining data integrity and providing clear error handling mechanisms.

---

*Generated by CodeWorm on 2026-02-19 11:15*
