# hub

**Type:** File Overview
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/websocket/hub.go
**Language:** go
**Lines:** 1-167
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
hub.go
*/

package websocket

import (
	"context"
	"encoding/json"
	"log/slog"
	"sync"
	"time"
)

type Hub struct {
	clients    map[*Client]bool
	register   chan *Client
	unregister chan *Client
	broadcast  chan []byte
	logger     *slog.Logger
	mu         sync.RWMutex
}

// NewHub creates a WebSocket hub for managing client connections.
func NewHub(logger *slog.Logger) *Hub {
	return &Hub{
		clients:    make(map[*Client]bool),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		broadcast:  make(chan []byte, 256),
		logger:     logger,
	}
}

// Run starts the hub's main event loop.
// Should be run in a goroutine.
func (h *Hub) Run(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			h.mu.Lock()
			for client := range h.clients {
				close(client.send)
				delete(h.clients, client)
			}
			h.mu.Unlock()
			return

		case client := <-h.register:
			h.mu.Lock()
			h.clients[client] = true
			h.mu.Unlock()
			h.logger.Debug("client connected", "addr", client.conn.RemoteAddr())

		case client := <-h.unregister:
			h.mu.Lock()
			if _, ok := h.clients[client]; ok {
				delete(h.clients, client)
				close(client.send)
			}
			h.mu.Unlock()
			h.logger.Debug(
				"client disconnected",
				"addr",
				client.conn.RemoteAddr(),
			)

		case message := <-h.broadcast:
			h.mu.RLock()
			for client := range h.clients {
				select {
				case client.send <- message:
				default:
					close(client.send)
					delete(h.clients, client)
				}
			}
			h.mu.RUnlock()
		}
	}
}

// Broadcast sends a message to all connected clients.
func (h *Hub) Broadcast(msg *Message) {
	data, err := json.Marshal(msg)
	if err != nil {
		h.logger.Error("failed to marshal broadcast message", "error", err)
		return
	}

	select {
	case h.broadcast <- data:
	default:
		h.logger.Warn("broadcast channel full, dropping message")
	}
}

// BroadcastToSubscribers sends a message to clients subscribed to a specific project.
func (h *Hub) BroadcastToSubscribers(projectID string, msg *Message) {
	data, err := json.Marshal(msg)
	if err != nil {
		h.logger.Error("failed to marshal message", "error", err)
		return
	}

	h.mu.RLock()
	defer h.mu.RUnlock()

	for client := range h.clients {
		if client.IsSubscribed(projectID) {
			select {
			case client.send <- data:
			default:
			}
		}
	}
}

// ClientCount returns the number of connected clients.
func (h *Hub) ClientCount() int {
	h.mu.RLock()
	defer h.mu.RUnlock()
	return len(h.clients)
}

// Register adds a client to the hub.
func (h *Hub) Register(client *Client) {
	h.register <- client
}

// Unregister removes a client from the hub.
func (h *Hub) Unregister(client *Client) {
	h.unregister <- client
}

// StartStatsStreamer begins streaming container stats to subscribed clients.
func (h *Hub) StartStatsStreamer(
	ctx context.Context,
	getStats func(context.Context) (map[string]any, error),
) {
	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			ret
```

---

## File Overview

### Hub.go

**Purpose:**
This file defines a WebSocket hub responsible for managing client connections, broadcasting messages, and handling subscriptions to specific projects.

**Key Exports & Public Interface:**
- `NewHub`: Creates a new WebSocket hub with logging.
- `Run`: Starts the main event loop of the hub.
- `Broadcast`: Sends a message to all connected clients.
- `BroadcastToSubscribers`: Sends a message to clients subscribed to a specific project.
- `ClientCount`: Returns the number of currently connected clients.
- `Register`: Adds a client to the hub.
- `Unregister`: Removes a client from the hub.
- `StartStatsStreamer`: Streams container stats to subscribed clients.

**How it Fits in the Project:**
The `Hub` struct acts as the central manager for WebSocket connections, facilitating communication between clients and the server. It integrates with other components of the project by handling client registration, disconnection, and message broadcasting. The hub is designed to be run in a goroutine, ensuring efficient event processing.

**Notable Design Decisions:**
- **Concurrency**: The use of channels for registering, unregistering, and broadcasting ensures thread-safe operations.
- **Error Handling**: Errors during message marshaling are logged but do not halt the program, allowing graceful degradation.
- **Logging**: Comprehensive logging is integrated using `slog`, providing detailed insights into client connections and disconnections.
- **Rate Limiting**: The broadcast channel has a buffer to prevent overflow, ensuring messages are dropped only when absolutely necessary.
```

This documentation provides an overview of the file's purpose, key exports, integration within the project, and notable design decisions.

---

*Generated by CodeWorm on 2026-02-19 19:35*
