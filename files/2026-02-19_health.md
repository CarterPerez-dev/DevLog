# health

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/routes/health.rs
**Language:** rust
**Lines:** 1-606
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Â©AngelaMos | 2025
 */

use axum::{
    response::IntoResponse,
    extract::State,
    http::StatusCode,
    Json,
    response::Json as JsonResponse,
};
use serde::{Deserialize, Serialize};
use std::time::{Duration, Instant};
use tracing::{info, warn, error};
use sqlx::Row;

use crate::{
    utils::error::{AppError, Result},
    AppState,
};

/// Comprehensive health check response for monitoring systems
/// I'm providing detailed health information for production monitoring and alerting
#[derive(Debug, Serialize)]
pub struct HealthCheckResponse {
    pub status: ServiceStatus,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub uptime_seconds: u64,
    pub version: VersionInfo,
    pub services: ServiceHealthStatus,
    pub system: SystemHealth,
    pub performance: PerformanceMetrics,
    pub checks: Vec<HealthCheck>,
}

#[derive(Debug, Clone, Serialize)]
pub enum ServiceStatus {
    Healthy,
    Degraded,
    Unhealthy,
}

#[derive(Debug, Serialize)]
pub struct VersionInfo {
    pub version: String,
    pub build_time: String,
    pub git_commit: String,
    pub rust_version: String,
}

#[derive(Debug, Serialize)]
pub struct ServiceHealthStatus {
    pub database: ComponentStatus,
    pub redis: ComponentStatus,
    pub github_api: ComponentStatus,
    pub fractal_engine: ComponentStatus,
}

#[derive(Debug, Serialize)]
pub struct ComponentStatus {
    pub status: ServiceStatus,
    pub response_time_ms: Option<u64>,
    pub last_check: chrono::DateTime<chrono::Utc>,
    pub error_message: Option<String>,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Serialize)]
pub struct SystemHealth {
    pub cpu_usage_percent: f64,
    pub memory_usage_percent: f64,
    pub disk_usage_percent: f64,
    pub active_connections: u32,
    pub load_average: Vec<f64>,
}

#[derive(Debug, Serialize)]
pub struct PerformanceMetrics {
    pub requests_per_second: f64,
    pub average_response_time_ms: f64,
    pub error_rate_percent: f64,
    pub fractal_computations_last_hour: u32,
    pub github_api_calls_last_hour: u32,
}
#[derive(Debug, Clone, Serialize)]
pub struct HealthCheck {
    pub name: String,
    pub status: ServiceStatus,
    pub duration_ms: u64,
    pub message: String,
}

/// Simple health check endpoint for load balancers
/// I'm providing a lightweight endpoint for basic availability checks
pub async fn health_check(
    State(app_state): State<AppState>,
) -> Result<JsonResponse<HealthCheckResponse>> {
    let start_time = Instant::now();
    info!("Performing comprehensive health check");

    // I'm collecting health information from all critical services
    let mut checks = Vec::new();
    let mut overall_status = ServiceStatus::Healthy;

    // Database health check
    let (database_status, database_check) = check_database_health(&app_state).await;
    checks.push(database_check);

    // Redis health check
    let (redis_status, redis_check) = check_redis_health(&app_state).await;
    checks.push(redis_check);

```

---

## File Overview

# health.rs Documentation

**Purpose and Responsibility:**
This file defines the comprehensive health check and readiness probe endpoints for the `kill-pr0cess.inc` backend service. It ensures that critical services are functioning correctly and provides detailed health information for monitoring systems.

**Key Exports or Public Interface:**
- `health_check`: A comprehensive health check endpoint that returns a detailed health response.
- `rea... (readiness probe)`: An incomplete readiness probe endpoint intended to indicate when the service is ready to accept traffic.

**How It Fits in the Project:**
This file is part of the backend module, responsible for monitoring and ensuring the availability and performance of critical services. The health check endpoint is crucial for external monitoring systems, while the readiness probe helps Kubernetes manage the deployment lifecycle effectively.

**Notable Design Decisions:**
- **Service Status Enum**: Uses `ServiceStatus` to categorize service health (Healthy, Degraded, Unhealthy).
- **Detailed Health Information**: Provides extensive details such as uptime, version information, and performance metrics.
- **Async/Await Pattern**: Utilizes `async/await` for non-blocking I/O operations, ensuring efficient handling of multiple checks concurrently.
- **Tracing and Logging**: Employs `tracing` for detailed logging to aid in debugging and monitoring.
```

This documentation covers the essential aspects of the file, highlighting its role within the project and key design choices.

---

*Generated by CodeWorm on 2026-02-19 21:29*
