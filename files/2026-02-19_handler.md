# handler

**Type:** File Overview
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/user/handler.go
**Language:** go
**Lines:** 1-289
**Complexity:** 0.0

---

## Source Code

```go
// AngelaMos | 2026
// handler.go

package user

import (
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	"github.com/go-playground/validator/v10"

	"github.com/carterperez-dev/templates/go-backend/internal/core"
	"github.com/carterperez-dev/templates/go-backend/internal/middleware"
)

type Handler struct {
	service   *Service
	validator *validator.Validate
}

func NewHandler(service *Service) *Handler {
	return &Handler{
		service:   service,
		validator: validator.New(validator.WithRequiredStructEnabled()),
	}
}

func (h *Handler) RegisterRoutes(
	r chi.Router,
	authenticator func(http.Handler) http.Handler,
) {
	r.Route("/users", func(r chi.Router) {
		r.Use(authenticator)

		r.Get("/me", h.GetMe)
		r.Put("/me", h.UpdateMe)
		r.Delete("/me", h.DeleteMe)
	})
}

func (h *Handler) GetMe(w http.ResponseWriter, r *http.Request) {
	userID := middleware.GetUserID(r.Context())

	user, err := h.service.GetMe(r.Context(), userID)
	if err != nil {
		if errors.Is(err, core.ErrNotFound) {
			core.NotFound(w, "user")
			return
		}
		core.InternalServerError(w, err)
		return
	}

	core.OK(w, ToUserResponse(user))
}

func (h *Handler) UpdateMe(w http.ResponseWriter, r *http.Request) {
	userID := middleware.GetUserID(r.Context())

	var req UpdateUserRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		core.BadRequest(w, "invalid request body")
		return
	}

	if err := h.validator.Struct(req); err != nil {
		core.BadRequest(w, core.FormatValidationError(err))
		return
	}

	user, err := h.service.UpdateMe(r.Context(), userID, req)
	if err != nil {
		if errors.Is(err, core.ErrNotFound) {
			core.NotFound(w, "user")
			return
		}
		core.InternalServerError(w, err)
		return
	}

	core.OK(w, ToUserResponse(user))
}

func (h *Handler) DeleteMe(w http.ResponseWriter, r *http.Request) {
	userID := middleware.GetUserID(r.Context())

	if err := h.service.DeleteMe(r.Context(), userID); err != nil {
		if errors.Is(err, core.ErrNotFound) {
			core.NotFound(w, "user")
			return
		}
		core.InternalServerError(w, err)
		return
	}

	core.NoContent(w)
}

// RegisterAdminRoutes registers admin-only user management endpoints.
func (h *Handler) RegisterAdminRoutes(
	r chi.Router,
	authenticator, adminOnly func(http.Handler) http.Handler,
) {
	r.Route("/admin/users", func(r chi.Router) {
		r.Use(authenticator)
		r.Use(adminOnly)

		r.Get("/", h.ListUsers)
		r.Get("/{userID}", h.GetUser)
		r.Put("/{userID}", h.UpdateUser)
		r.Put("/{userID}/role", h.UpdateUserRole)
		r.Put("/{userID}/tier", h.UpdateUserTier)
		r.Delete("/{userID}", h.DeleteUser)
	})
}

// ListUsers returns a paginated list of users with optional filtering.
func (h *Handler) ListUsers(w http.ResponseWriter, r *http.Request) {
	params := ListUsersParams{
		Page:     parseIntQuery(r, "page", 1),
		PageSize: parseIntQuery(r, "page_size", 20),
		Search:   r.URL.Query().Get("search"),
		Role:     r.URL.Query().Get("role"),
		Tier:     r.URL.Query().Get("tier"),
	}

	users, to
```

---

## File Overview

### Purpose and Responsibility

This Go source file, `handler.go`, is responsible for defining and managing HTTP handlers for user-related operations within a backend application. It integrates with services to handle CRUD (Create, Read, Update, Delete) operations for users, both by authenticated users and administrators.

### Key Exports and Public Interface

- **Handler**: A struct that encapsulates the handler logic.
- `NewHandler`: A constructor function that initializes a new instance of `Handler`.
- `RegisterRoutes` & `RegisterAdminRoutes`: Functions to register user-related routes for both regular and admin users.
- Various HTTP handlers (`GetMe`, `UpdateMe`, `DeleteMe`, etc.) that handle specific CRUD operations.

### How It Fits into the Project

This file is a critical component of the backend service, providing a clear separation between business logic (handled by services) and API endpoints. It leverages middleware for authentication and validation, ensuring secure and consistent handling of user requests across different roles.

### Notable Design Decisions

- **Error Handling**: Errors are consistently handled using custom error types (`core.ErrNotFound`, `core.InternalServerError`) to provide clear feedback.
- **Validation**: The use of Go's `validator` package ensures that request bodies are validated before being passed to service methods, enhancing data integrity.
- **Contextual Error Messages**: Custom error messages are formatted and returned appropriately based on the type of error encountered.

This design promotes a modular and maintainable architecture, making it easier to extend or modify the user management functionality as needed.

---

*Generated by CodeWorm on 2026-02-19 16:33*
