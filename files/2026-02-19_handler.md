# handler

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/health/handler.go
**Language:** go
**Lines:** 1-197
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2025
handler.go
*/

package health

import (
	"context"
	"encoding/json"
	"net/http"
	"sync"
	"sync/atomic"
	"time"

	"github.com/go-chi/chi/v5"
)

type Checker interface {
	Ping(ctx context.Context) error
}

type Handler struct {
	mongo    Checker
	sqlite   Checker
	ready    atomic.Bool
	shutdown atomic.Bool
}

func NewHandler(mongo, sqlite Checker) *Handler {
	h := &Handler{
		mongo:  mongo,
		sqlite: sqlite,
	}
	h.ready.Store(true)
	return h
}

func (h *Handler) RegisterRoutes(r chi.Router) {
	r.Get("/healthz", h.Liveness)
	r.Get("/livez", h.Liveness)
	r.Get("/readyz", h.Readiness)
}

func (h *Handler) Liveness(w http.ResponseWriter, r *http.Request) {
	if h.shutdown.Load() {
		h.writeStatus(w, http.StatusServiceUnavailable, StatusResponse{
			Status: "shutting_down",
		})
		return
	}

	h.writeStatus(w, http.StatusOK, StatusResponse{
		Status: "ok",
	})
}

func (h *Handler) Readiness(w http.ResponseWriter, r *http.Request) {
	if h.shutdown.Load() {
		h.writeStatus(w, http.StatusServiceUnavailable, StatusResponse{
			Status: "shutting_down",
		})
		return
	}

	if !h.ready.Load() {
		h.writeStatus(w, http.StatusServiceUnavailable, StatusResponse{
			Status: "not_ready",
		})
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	checks := h.runHealthChecks(ctx)

	allHealthy := true
	for _, check := range checks {
		if !check.Healthy {
			allHealthy = false
			break
		}
	}

	status := "ok"
	statusCode := http.StatusOK
	if !allHealthy {
		status = "degraded"
		statusCode = http.StatusServiceUnavailable
	}

	h.writeStatus(w, statusCode, ReadinessResponse{
		Status: status,
		Checks: checks,
	})
}

func (h *Handler) runHealthChecks(ctx context.Context) []HealthCheck {
	var wg sync.WaitGroup
	checks := make([]HealthCheck, 2)

	wg.Add(2)

	go func() {
		defer wg.Done()
		checks[0] = h.checkMongo(ctx)
	}()

	go func() {
		defer wg.Done()
		checks[1] = h.checkSQLite(ctx)
	}()

	wg.Wait()
	return checks
}

func (h *Handler) checkMongo(ctx context.Context) HealthCheck {
	check := HealthCheck{
		Name:    "mongodb",
		Healthy: true,
	}

	if h.mongo == nil {
		check.Healthy = false
		check.Message = "mongodb checker not configured"
		return check
	}

	start := time.Now()
	err := h.mongo.Ping(ctx)
	check.Latency = time.Since(start).String()

	if err != nil {
		check.Healthy = false
		check.Message = "ping failed"
	}

	return check
}

func (h *Handler) checkSQLite(ctx context.Context) HealthCheck {
	check := HealthCheck{
		Name:    "sqlite",
		Healthy: true,
	}

	if h.sqlite == nil {
		check.Healthy = false
		check.Message = "sqlite checker not configured"
		return check
	}

	start := time.Now()
	err := h.sqlite.Ping(ctx)
	check.Latency = time.Since(start).String()

	if err != nil {
		check.Healthy = false
		check.Message = "ping failed"
	}

	return check
}

func (h *Handler) SetReady(ready bool) {
	h.ready.Store(ready)
}

func (h *Handler) SetShutdown(shutdown bool) {
	h.shutdown.Store(shutdown)
}

func (
```

---

## File Overview

### Purpose and Responsibility

This Go source file, `handler.go`, is responsible for handling health checks and readiness probes for a distributed system. It exposes endpoints to check the liveness and readiness of services, ensuring that they are operational and ready to handle requests.

### Key Exports and Public Interface

- **Handler**: The main struct representing the health handler.
  - Methods: `NewHandler`, `RegisterRoutes`, `Liveness`, `Readiness`, `runHealthChecks`, `SetReady`, `SetShutdown`, `writeStatus`.

- **Checker Interface**: Defines the `Ping` method for checking service health.

### How It Fits in the Project

This file is part of a larger backend system, specifically handling health checks. The `Handler` struct registers routes to `/healthz`, `/livez`, and `/readyz`. These endpoints are crucial for monitoring and managing the state of services within the application. The `Checker` interface ensures that any service can be pinged to verify its health.

### Notable Design Decisions

- **Concurrency**: Goroutines are used to concurrently run health checks, improving response time.
- **Error Handling**: Errors from service pings are handled gracefully and reported in the response.
- **Latency Measurement**: Each check measures latency, providing insights into performance.
- **Atomic Flags**: `ready` and `shutdown` use atomic flags for thread-safe state management.

This design ensures that the health checks are robust, efficient, and provide comprehensive information about service states.

---

*Generated by CodeWorm on 2026-02-19 23:42*
