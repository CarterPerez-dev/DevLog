# Base

**Type:** File Overview
**Repository:** vuemantics
**File:** backend/models/Base.py
**Language:** python
**Lines:** 1-230
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
Base.py
"""

from datetime import datetime
from typing import Any, TypeVar
from uuid import UUID

from asyncpg import Record

import config
import database


T = TypeVar("T", bound = "BaseModel")


class BaseModel:
    """
    Base class for all database models

    Provides:
    - Common fields: id, created_at, updated_at
    - CRUD operations: create, save, delete
    - Query helpers: find_by_id, find_all
    - Serialization: to_dict, from_record
    """
    __tablename__: str = ""
    __table_created__: bool = False

    def __init__(self, **kwargs: Any) -> None:
        """
        Initialize model instance with field values
        """
        self.id: UUID | None = kwargs.get("id")
        self.created_at: datetime | None = kwargs.get("created_at")
        self.updated_at: datetime | None = kwargs.get("updated_at")

    @classmethod
    async def create_table(cls) -> None:
        """
        Create the table if it doesn't exist.

        Must be implemented by subclasses with their specific schema.
        """
        raise NotImplementedError(
            "Subclasses must implement create_table()"
        )

    @classmethod
    async def ensure_table_exists(cls) -> None:
        """
        Ensure table exists, create if not
        """
        if not cls.__table_created__:
            await cls.create_table()
            cls.__table_created__ = True

    @classmethod
    def from_record(cls: type[T], record: Record | None) -> T | None:
        """
        Create model instance from asyncpg Record
        """
        if record is None:
            return None

        return cls(**dict(record))

    @classmethod
    def from_records(cls: type[T], records: list[Record]) -> list[T]:
        """
        Create multiple model instances from asyncpg Records
        """
        result: list[T] = []
        for record in records:
            if record is not None:
                instance = cls.from_record(record)
                if instance is not None:
                    result.append(instance)
        return result

    def to_dict(self, exclude: set[str] | None = None) -> dict[str, Any]:
        """
        Convert model instance to dictionary
        """
        exclude = exclude or set()

        result = {}
        for key, value in self.__dict__.items():
            if key.startswith("_") or key in exclude:
                continue

            if isinstance(value, UUID):
                result[key] = str(value)
            elif isinstance(value, datetime):
                result[key] = value.isoformat()
            else:
                result[key] = value

        return result

    @classmethod
    async def find_by_id(cls: type[T], id: UUID | str) -> T | None:
        """
        Find a record by ID
        """
        await cls.ensure_table_exists()

        if isinstance(id, str):
            id = UUID(id)

        query = f"""
            SELECT * FROM {cls.__tablename__}
            WHERE id = $1
        "
```

---

## File Overview

## Base.py

**Purpose and Responsibility:**
This file defines a base class `BaseModel` for database models, providing common fields, CRUD operations, and utility methods. It ensures consistency across all model implementations by enforcing table creation and offering query helpers.

**Key Exports and Public Interface:**
- **Class:** `BaseModel`
  - Common fields (`id`, `created_at`, `updated_at`)
  - CRUD operations (create, save, delete)
  - Query helpers (find_by_id, find_all, count)
  - Serialization methods (to_dict)

**How it Fits in the Project:**
`BaseModel` serves as a foundational class for all database models. It centralizes common logic and ensures that each model adheres to a consistent structure and behavior. This abstraction simplifies development by reducing boilerplate code and promoting reuse.

**Notable Design Decisions:**
- **Table Creation:** The `create_table` method must be implemented by subclasses, ensuring that each model defines its schema.
- **Lazy Table Creation:** `ensure_table_exists` checks if the table has been created before attempting to perform operations.
- **Query Flexibility:** Methods like `find_all`, `count`, and `from_records` provide flexible querying capabilities with optional filters and pagination.
- **Serialization:** The `to_dict` method converts model instances to dictionaries, facilitating easy data serialization and transmission.

This design promotes a modular and maintainable architecture within the project.

---

*Generated by CodeWorm on 2026-02-20 12:40*
