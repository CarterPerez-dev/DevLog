# cache

**Type:** File Overview
**Repository:** CertGames-Core
**File:** backend/api/core/decorators/cache.py
**Language:** python
**Lines:** 1-194
**Complexity:** 0.0

---

## Source Code

```python
"""
Caching decorators for route optimization
/api/core/lib/cache.py
"""

import os
import time
import redis
import json
import logging
from settings import Cache, Redis
from functools import wraps
from flask import current_app
from collections.abc import Callable
from typing import Any, TypeVar, cast


logger = logging.getLogger(__name__)

cache_storage: dict[str, Any] = {}
cache_timestamps: dict[str, float] = {}

_redis_conn: redis.StrictRedis | None = None

T = TypeVar("T")


def get_redis_connection() -> redis.StrictRedis | None:
    """
    Get Redis connection using Flask app's shared Redis client
    """
    try:
        return current_app.extensions.get("redis_client")
    except Exception:
        global _redis_conn
        if _redis_conn is None and redis:
            try:
                REDIS_PASSWORD: str | None = os.getenv("REDIS_PASSWORD")
                _redis_conn = redis.StrictRedis(
                    host = Redis.DEFAULT_HOST,
                    port = Redis.DEFAULT_PORT,
                    db = Redis.DEFAULT_DB,
                    password = REDIS_PASSWORD,
                    decode_responses = True,
                    socket_connect_timeout = Redis.SOCKET_CONNECT_TIMEOUT,
                    socket_timeout = Redis.SOCKET_TIMEOUT
                )
                _redis_conn.ping()
            except Exception:
                _redis_conn = None
        return _redis_conn


def redis_cache_set(
    key: str,
    value: Any,
    ttl: int = Redis.DEFAULT_CACHE_TTL_SECONDS
) -> None:
    """
    Set value in Redis cache with TTL
    """
    conn: redis.StrictRedis | None = get_redis_connection()
    if conn:
        try:
            serialized: str = json.dumps(value, default = str)
            conn.setex(key, ttl, serialized)
        except Exception as e:
            logger.warning("Failed to set cache for key %s: %s", key, e)


def redis_cache_get(key: str) -> Any:
    """
    Get value from Redis cache
    """
    conn: redis.StrictRedis | None = get_redis_connection()
    if conn:
        try:
            data: bytes | None = conn.get(key)
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            logger.warning("Failed to get cache for key %s: %s", key, e)
            return None
    return None


def cached_route(
    cache_duration_seconds: int = Cache.
    DEFAULT_ROUTE_CACHE_DURATION_SECONDS,
) -> Callable[[Callable[...,
                        T]],
              Callable[...,
                       T]]:
    """
    Decorator to cache route responses
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> T:
            cache_key: str = f"{func.__name__}_{str(args)}_{str(sorted(kwargs.items()))}"

            now: float = time.time()

            if (cache_key in cache_storage
                    and cache_key in cache_timestamps and now -
                    
```

---

## File Overview

### Purpose and Responsibility
This Python source file, `cache.py`, provides caching mechanisms for route optimization within a Flask application. It includes decorators and utility functions to cache function results and manage Redis-based caching.

### Key Exports and Public Interface
- **Decorators:**
  - `cached_route`: A decorator that caches the result of route functions.
  - `invalidate_cache`: Clears or invalidates specific cache entries based on a pattern.
  
- **Utility Functions:**
  - `get_redis_connection`: Retrieves a Redis connection from the Flask app's shared client.
  - `redis_cache_set`: Sets a value in the Redis cache with an expiration time.
  - `redis_cache_get`: Retrieves a cached value from Redis.
  - `get_cache_stats`: Returns statistics about the local cache.

- **Classes:**
  - `LeaderboardCache`: A specialized class for caching leaderboard data, including methods to check cache validity and set new cache values.

### How It Fits in the Project
This file is crucial for optimizing performance by reducing the number of expensive operations. The caching mechanisms are used across various routes, ensuring that frequently accessed or computed data can be quickly retrieved from a cache rather than recalculated each time.

### Notable Design Decisions
- **Redis Integration**: Utilizes Redis for distributed caching to ensure data consistency and scalability.
- **Local Cache**: Implements an in-memory cache (`cache_storage`) as a fallback, providing fast access within the application.
- **Custom Decorator**: `cached_route` is designed to be flexible, allowing developers to specify custom cache durations per route.
- **Cache Invalidation**: Provides mechanisms to invalidate caches either globally or based on patterns, ensuring that stale data does not persist.

---

*Generated by CodeWorm on 2026-02-19 00:41*
