# handler

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/websocket/handler.go
**Language:** go
**Lines:** 1-104
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
handler.go
*/

package websocket

import (
	"context"
	"log/slog"
	"net/http"
	"time"

	"github.com/coder/websocket"
	"github.com/google/uuid"
)

type Handler struct {
	hub    *Hub
	logger *slog.Logger
}

func NewHandler(hub *Hub, logger *slog.Logger) *Handler {
	return &Handler{
		hub:    hub,
		logger: logger,
	}
}

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	conn, err := websocket.Accept(w, r, &websocket.AcceptOptions{
		OriginPatterns: []string{"*"},
	})
	if err != nil {
		h.logger.Error("websocket accept failed", "error", err)
		return
	}

	clientID := uuid.New().String()[:8]

	client := &Client{
		hub:      h.hub,
		conn:     conn,
		send:     make(chan []byte, 256),
		clientID: clientID,
	}

	h.hub.register <- client

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go client.WritePump(ctx)
	client.ReadPump(ctx)
}

func (h *Handler) GetHub() *Hub {
	return h.hub
}

type MetricsBroadcaster struct {
	hub           *Hub
	metricsGetter func(ctx context.Context) (any, error)
	intervalMs    int
	logger        *slog.Logger
}

func NewMetricsBroadcaster(hub *Hub, getter func(ctx context.Context) (any, error), intervalMs int, logger *slog.Logger) *MetricsBroadcaster {
	return &MetricsBroadcaster{
		hub:           hub,
		metricsGetter: getter,
		intervalMs:    intervalMs,
		logger:        logger,
	}
}

func (b *MetricsBroadcaster) Start(ctx context.Context) {
	go b.run(ctx)
}

func (b *MetricsBroadcaster) run(ctx context.Context) {
	ticker := time.NewTicker(time.Duration(b.intervalMs) * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			if b.hub.ClientCount() == 0 {
				continue
			}

			metrics, err := b.metricsGetter(ctx)
			if err != nil {
				b.logger.Error("failed to get metrics for broadcast", "error", err)
				continue
			}

			b.hub.Broadcast("metrics", metrics)
		}
	}
}

```

---

## File Overview

# handler.go

## Purpose and Responsibility
This file defines a WebSocket server handler for managing client connections and broadcasting metrics. It integrates with a central `Hub` to manage clients and handle WebSocket communication.

## Key Exports and Public Interface
- **Handler**: Manages WebSocket connections, serving HTTP requests and handling client communication.
- **MetricsBroadcaster**: Periodically fetches metrics from a provided function and broadcasts them to connected clients.

## How It Fits in the Project
The `handler.go` file is part of the WebSocket module responsible for establishing and managing real-time connections. It interacts with the central `Hub`, which maintains a list of all active client connections, ensuring that any updates or messages are broadcasted efficiently across all connected clients.

## Notable Design Decisions
- **Error Handling**: Errors during WebSocket acceptance and metric fetching are logged but do not halt execution.
- **Concurrency**: Goroutines are used for handling client communication (writing and reading) to ensure non-blocking I/O operations.
- **Context Management**: Contexts are utilized for graceful shutdown of goroutines, ensuring clean termination when necessary.
- **Metrics Broadcasting**: A separate `MetricsBroadcaster` struct manages periodic metric fetching and broadcasting, decoupling this functionality from the main handler logic.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and notable design choices.

---

*Generated by CodeWorm on 2026-02-20 00:56*
