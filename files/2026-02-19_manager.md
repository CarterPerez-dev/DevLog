# manager

**Type:** File Overview
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/project/manager.go
**Language:** go
**Lines:** 1-446
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
manager.go
*/

package project

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/carterperez-dev/holophyly/internal/docker"
	"github.com/carterperez-dev/holophyly/internal/model"
	"github.com/carterperez-dev/holophyly/internal/scanner"
	"github.com/carterperez-dev/holophyly/internal/store"
)

type Manager struct {
	docker         *docker.Client
	scanner        *scanner.Scanner
	statsCollector *docker.StatsCollector
	store          *store.Store
	projects       map[string]*model.Project
	protection     *ProtectionConfig
	mu             sync.RWMutex
}

// NewManager creates a project manager that orchestrates docker and scanner.
func NewManager(
	dockerClient *docker.Client,
	fileScanner *scanner.Scanner,
	protection *ProtectionConfig,
	prefStore *store.Store,
) *Manager {
	return &Manager{
		docker:         dockerClient,
		scanner:        fileScanner,
		statsCollector: docker.NewStatsCollector(dockerClient),
		store:          prefStore,
		projects:       make(map[string]*model.Project),
		protection:     protection,
	}
}

// Refresh scans for compose files and updates project state with running containers.
func (m *Manager) Refresh(ctx context.Context) error {
	result, err := m.scanner.Scan(ctx)
	if err != nil {
		return fmt.Errorf("scanning for projects: %w", err)
	}

	containersByProject, err := m.docker.GetContainersByComposeProject(ctx)
	if err != nil {
		return fmt.Errorf("getting containers: %w", err)
	}

	var prefs map[string]*store.ProjectPreference
	if m.store != nil {
		prefs, _ = m.store.GetAllPreferences()
	}

	m.mu.Lock()
	defer m.mu.Unlock()

	newProjects := make(map[string]*model.Project)

	for _, proj := range result.Projects {
		existing, exists := m.projects[proj.ID]
		if exists {
			proj.Protected = existing.Protected
			proj.ProtectionReason = existing.ProtectionReason
		}

		if prefs != nil {
			if pref, ok := prefs[proj.ID]; ok {
				proj.DisplayName = pref.DisplayName
				proj.Hidden = pref.Hidden
			}
		}

		projectName := docker.GetComposeProjectName(proj.ComposeFilePath)
		if containers, ok := containersByProject[projectName]; ok {
			proj.Containers = containers
			proj.Status = determineProjectStatus(containers)
		} else {
			proj.Status = model.StatusStopped
			proj.Containers = []model.Container{}
		}

		m.applyProtection(proj)

		proj.UpdatedAt = time.Now()
		newProjects[proj.ID] = proj
	}

	m.projects = newProjects
	return nil
}

// ListProjects returns all discovered projects sorted by name.
func (m *Manager) ListProjects() []*model.Project {
	m.mu.RLock()
	defer m.mu.RUnlock()

	projects := make([]*model.Project, 0, len(m.projects))
	for _, proj := range m.projects {
		projects = append(projects, proj)
	}

	// Sort by name, then by compose filename for stable ordering
	for i := 0; i < len(projects); i++ {
		for j := i + 1; j < len(projects); j++ {
			swapNeeded := false

			if projects[i].Name > projects[j].Name {
				swapNeeded = true
			} else if projects[i].Name == projects[j].Name {

```

---

## File Overview

### manager.go

**Purpose and Responsibility:**
This Go file defines the `Manager` struct, which orchestrates the interaction between Docker services, file scanning, and project management within the `project` package of the `angelamos-operations` repository. The `Manager` handles operations such as refreshing project states, listing projects, starting/stopping/restarting projects, and applying protection configurations.

**Key Exports/Interface:**
- `NewManager`: Creates a new instance of the `Manager`.
- `Refresh`: Scans for compose files and updates project states.
- `ListProjects`: Returns all discovered projects sorted by name.
- `GetProject`: Retrieves a single project by ID.
- `StartProject`, `StopProject`, `RestartProject`: Manage the lifecycle of Docker projects.

**How it Fits in the Project:**
The `Manager` acts as the central hub for project management, integrating with Docker clients and file scanners to ensure that all projects are up-to-date and managed according to user preferences. It leverages dependencies from other packages like `docker`, `scanner`, and `store` to provide a cohesive interface for project operations.

**Notable Design Decisions:**
- **Concurrency Safety**: The `Manager` uses `sync.RWMutex` to ensure thread-safe access to the project map.
- **Error Handling**: Errors are propagated using standard Go error handling practices, ensuring that any issues during operation are properly communicated.
- **Configuration Management**: Protection configurations and preferences are managed through interfaces, allowing for flexible and extensible behavior.

---

*Generated by CodeWorm on 2026-02-19 18:44*
