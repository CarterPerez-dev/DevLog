# ErrorBoundary

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** frontend/src/components/UI/ErrorBoundary.tsx
**Language:** tsx
**Lines:** 1-473
**Complexity:** 0.0

---

## Source Code

```tsx
/*
 * Robust error boundary component providing graceful error handling and recovery for the entire application with contextual error reporting.
 * I'm implementing comprehensive error catching, logging, and user-friendly fallback interfaces that maintain the dark aesthetic while providing actionable error information and recovery options.
 */

import {
  type Component,
  type JSX,
  createSignal,
  createEffect,
  Show,
  onMount,
} from 'solid-js';
import { Card } from './Card';

interface ErrorInfo {
  error: Error;
  timestamp: Date;
  component?: string;
  context?: string;
  userAgent?: string;
  url?: string;
  stackTrace?: string;
}

interface ErrorBoundaryProps {
  children: JSX.Element;
  fallback?: (error: ErrorInfo, retry: () => void) => JSX.Element;
  onError?: (error: ErrorInfo) => void;
  context?: string;
  level?: 'page' | 'component' | 'critical';
}

export const ErrorBoundary: Component<ErrorBoundaryProps> = (props) => {
  const [error, setError] = createSignal<ErrorInfo | null>(null);
  const [retryCount, setRetryCount] = createSignal(0);

  // I'm setting up global error handlers for comprehensive error catching
  onMount(() => {
    // Handle unhandled promise rejections
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      const errorInfo: ErrorInfo = {
        error: new Error(`Unhandled Promise Rejection: ${event.reason}`),
        timestamp: new Date(),
        context: props.context || 'Promise Rejection',
        userAgent: navigator.userAgent,
        url: window.location.href,
        stackTrace: event.reason?.stack || 'No stack trace available',
      };

      handleError(errorInfo);
      event.preventDefault();
    };

    // Handle general JavaScript errors
    const handleJSError = (event: ErrorEvent) => {
      const errorInfo: ErrorInfo = {
        error: event.error || new Error(event.message),
        timestamp: new Date(),
        context: props.context || 'JavaScript Error',
        userAgent: navigator.userAgent,
        url: window.location.href,
        stackTrace: event.error?.stack || 'No stack trace available',
      };

      handleError(errorInfo);
    };

    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    window.addEventListener('error', handleJSError);

    return () => {
      window.removeEventListener(
        'unhandledrejection',
        handleUnhandledRejection,
      );
      window.removeEventListener('error', handleJSError);
    };
  });

  const handleError = (errorInfo: ErrorInfo) => {
    console.error('Error caught by boundary:', errorInfo);

    // I'm logging the error for debugging and monitoring
    if (props.onError) {
      props.onError(errorInfo);
    }

    // Send error to monitoring service (would be implemented in production)
    reportError(errorInfo);

    setError(errorInfo);
  };

  const retry = () => {
    setError(null);
    setRetryCount((prev) => prev + 1);
  };

  const reportError = (errorInfo: ErrorInfo)
```

---

## File Overview

### ErrorBoundary Component Documentation

**Purpose:**
This component acts as a robust error boundary for the entire application, providing comprehensive error handling and recovery mechanisms with contextual error reporting.

**Key Exports/Interface:**
- **ErrorBoundary**: A Solid.js component that handles errors globally. It accepts `children`, an optional `fallback` function, and additional props like `context` and `level`.

**Project Integration:**
The `ErrorBoundary` is crucial for maintaining the application's stability by catching and reporting errors gracefully. It ensures that even if a critical error occurs, the user interface remains functional with clear fallback interfaces.

**Design Decisions:**
- **Global Error Handling**: The component sets up global event listeners to catch unhandled promise rejections and general JavaScript errors.
- **Contextual Reporting**: It logs detailed error information including context, user agent, URL, and stack trace. This helps in identifying the root cause of issues.
- **Retry Mechanism**: Users can retry actions after an error occurs, which is particularly useful for transient issues like network failures.
- **Fallback UIs**: Different fallback interfaces are provided based on the severity of the error (`critical`, `page`, or default `component` level).

This component enhances the overall user experience by ensuring that errors do not crash the application and providing actionable recovery options.

---

*Generated by CodeWorm on 2026-02-19 20:42*
