# proc

**Type:** File Overview
**Repository:** docksec
**File:** internal/proc/proc.go
**Language:** go
**Lines:** 1-336
**Complexity:** 0.0

---

## Source Code

```go
/*
CarterPerez-dev | 2025
proc.go
*/

package proc

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

type ProcessInfo struct {
	PID          int
	Name         string
	State        string
	PPID         int
	UID          int
	GID          int
	Threads      int
	VmSize       int64
	VmRSS        int64
	Cmdline      []string
	Cgroups      []CgroupEntry
	Namespaces   map[string]uint64
	Capabilities *CapabilitySet
	SeccompMode  string
	NoNewPrivs   bool
}

type CgroupEntry struct {
	HierarchyID int
	Controllers []string
	Path        string
}

func GetProcessInfo(pid int) (*ProcessInfo, error) {
	procPath := fmt.Sprintf("/proc/%d", pid)

	if _, err := os.Stat(procPath); os.IsNotExist(err) {
		return nil, fmt.Errorf("process %d does not exist", pid)
	}

	info := &ProcessInfo{
		PID:        pid,
		Namespaces: make(map[string]uint64),
	}

	if err := info.readStatus(procPath); err != nil {
		return nil, fmt.Errorf("reading status: %w", err)
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := info.readCmdline(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := info.readCgroups(procPath); err != nil {
	}

	//nolint:staticcheck // graceful degradation - errors intentionally ignored
	if err := info.readNamespaces(procPath); err != nil {
	}

	return info, nil
}

func (p *ProcessInfo) readStatus(procPath string) error {
	file, err := os.Open(filepath.Join(procPath, "status"))
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		parts := strings.SplitN(line, ":", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "Name":
			p.Name = value
		case "State":
			p.State = strings.Split(value, " ")[0]
		case "PPid":
			p.PPID, _ = strconv.Atoi(value)
		case "Uid":
			fields := strings.Fields(value)
			if len(fields) > 0 {
				p.UID, _ = strconv.Atoi(fields[0])
			}
		case "Gid":
			fields := strings.Fields(value)
			if len(fields) > 0 {
				p.GID, _ = strconv.Atoi(fields[0])
			}
		case "Threads":
			p.Threads, _ = strconv.Atoi(value)
		case "VmSize":
			p.VmSize = parseMemValue(value)
		case "VmRSS":
			p.VmRSS = parseMemValue(value)
		case "CapInh":
			if p.Capabilities == nil {
				p.Capabilities = &CapabilitySet{}
			}
			p.Capabilities.Inheritable, _ = strconv.ParseUint(value, 16, 64)
		case "CapPrm":
			if p.Capabilities == nil {
				p.Capabilities = &CapabilitySet{}
			}
			p.Capabilities.Permitted, _ = strconv.ParseUint(value, 16, 64)
		case "CapEff":
			if p.Capabilities == nil {
				p.Capabilities = &CapabilitySet{}
			}
			p.Capabilities.Effective, _ = strconv.ParseUint(value, 16, 64)
		case "CapBnd":
			if p.Capabilities == nil {
				p.Capabilities = &CapabilitySet{}
			}
			p.Capabilities.Bounding, _ = strconv.ParseUint(value, 16, 64)
		case "
```

---

## File Overview

### proc.go

**Purpose and Responsibility:**
This Go source file is responsible for gathering detailed information about a Linux process, including its state, memory usage, capabilities, namespaces, and cgroups. It provides a structured representation of process metadata that can be used by other parts of the `docksec` project.

**Key Exports or Public Interface:**
- `GetProcessInfo(pid int) (*ProcessInfo, error)`: A public function to retrieve comprehensive details about a given process ID.
- `ProcessInfo`: A struct representing detailed information about a process.
- `IsInContainer() bool`: A method to determine if the process is running within a container based on cgroup paths.

**How it Fits in the Project:**
This file is part of the `proc` package, which is crucial for analyzing and monitoring processes. It integrates with other components that might need detailed process information, such as security checks or performance analysis tools. The `GetProcessInfo` function serves as a central point for fetching process data, making it easily accessible to various parts of the project.

**Notable Design Decisions:**
- **Graceful Degradation**: Errors in reading certain fields are handled gracefully by ignoring them, ensuring that the overall process information is still usable even if some details cannot be retrieved.
- **Separate Concerns**: The file uses separate methods for reading different types of data (status, cmdline, cgroups, namespaces), promoting clear and maintainable code.
- **Error Handling**: Errors are properly handled using `fmt.Errorf` to provide meaningful error messages. This helps in debugging and understanding the failure points during process information retrieval.
```

This documentation provides a high-level overview of the file's purpose, key exports, integration within the project, and notable design decisions.

---

*Generated by CodeWorm on 2026-02-20 19:40*
