# logs

**Type:** File Overview
**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/docker/logs.go
**Language:** go
**Lines:** 1-229
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
logs.go
*/

package docker

import (
	"bytes"
	"context"
	"fmt"
	"io"

	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/pkg/stdcopy"
)

type LogOutput struct {
	Stdout string `json:"stdout"`
	Stderr string `json:"stderr"`
}

type LogOptions struct {
	Tail       string
	Since      string
	Until      string
	Timestamps bool
	Follow     bool
}

// GetLogs retrieves logs from a container with proper stdout/stderr demultiplexing.
// Non-TTY containers multiplex streams with header bytes that must be separated.
func (c *Client) GetLogs(
	ctx context.Context,
	containerID string,
	opts LogOptions,
) (*LogOutput, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	logOpts := container.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Timestamps: opts.Timestamps,
		Follow:     false,
		Tail:       opts.Tail,
		Since:      opts.Since,
		Until:      opts.Until,
	}

	if logOpts.Tail == "" {
		logOpts.Tail = "100"
	}

	reader, err := c.cli.ContainerLogs(ctx, containerID, logOpts)
	if err != nil {
		return nil, fmt.Errorf("getting logs for %s: %w", containerID, err)
	}
	defer func() { _ = reader.Close() }()

	info, err := c.cli.ContainerInspect(ctx, containerID)
	if err != nil {
		return nil, fmt.Errorf(
			"inspecting container %s for TTY check: %w",
			containerID,
			err,
		)
	}

	var stdoutBuf, stderrBuf bytes.Buffer

	if info.Config != nil && info.Config.Tty {
		if _, err := io.Copy(&stdoutBuf, reader); err != nil {
			return nil, fmt.Errorf("reading TTY logs: %w", err)
		}
	} else {
		if _, err := stdcopy.StdCopy(&stdoutBuf, &stderrBuf, reader); err != nil {
			return nil, fmt.Errorf("demultiplexing logs: %w", err)
		}
	}

	return &LogOutput{
		Stdout: stdoutBuf.String(),
		Stderr: stderrBuf.String(),
	}, nil
}

// StreamLogs streams logs from a container in real-time.
// Returns separate channels for stdout and stderr.
func (c *Client) StreamLogs(
	ctx context.Context,
	containerID string,
	opts LogOptions,
) (<-chan string, <-chan string, <-chan error) {
	stdoutCh := make(chan string, 100)
	stderrCh := make(chan string, 100)
	errCh := make(chan error, 1)

	go func() {
		defer close(stdoutCh)
		defer close(stderrCh)
		defer close(errCh)

		c.mu.RLock()
		cli := c.cli
		c.mu.RUnlock()

		logOpts := container.LogsOptions{
			ShowStdout: true,
			ShowStderr: true,
			Timestamps: opts.Timestamps,
			Follow:     true,
			Tail:       opts.Tail,
			Since:      opts.Since,
		}

		if logOpts.Tail == "" {
			logOpts.Tail = "50"
		}

		reader, err := cli.ContainerLogs(ctx, containerID, logOpts)
		if err != nil {
			errCh <- fmt.Errorf("streaming logs for %s: %w", containerID, err)
			return
		}
		defer func() { _ = reader.Close() }()

		info, err := cli.ContainerInspect(ctx, containerID)
		if err != nil {
			errCh <- fmt.Errorf("inspecting container for TTY: %w", err)
			return
		}

		isTTY := info.Config != nil && info.Config.Tty

		if isTTY {
			streamTTYLogs(ctx, reader, stdoutCh)
		} else {
			streamMultiplexedLogs
```

---

## File Overview

### Purpose and Responsibility

This file, `logs.go`, is responsible for managing log retrieval from Docker containers within the `docker` package of the `angelamos-operations` repository. It provides both synchronous and asynchronous methods to fetch logs, ensuring proper demultiplexing and handling of TTY vs non-TTY containers.

### Key Exports and Public Interface

The key exports are:
- `GetLogs`: A function that retrieves logs from a container in a single batch.
- `StreamLogs`: A function that streams logs from a container in real-time, returning separate channels for stdout and stderr.

These functions are part of the public API and are used by other components within the project to manage logging operations.

### How It Fits into the Larger Project

This file is integral to the `docker` package, which provides high-level abstractions for interacting with Docker containers. The `GetLogs` and `StreamLogs` functions are called by higher-level modules that need to inspect or monitor container logs in various ways, such as logging services or monitoring tools.

### Notable Design Decisions

1. **Error Handling**: Errors are handled gracefully using `fmt.Errorf`, ensuring clear error messages.
2. **Concurrency**: The use of goroutines and channels (`StreamLogs`) allows for efficient real-time log streaming without blocking the main thread.
3. **Demultiplexing**: For non-TTY containers, logs are demultiplexed into stdout and stderr streams using `stdcopy.StdCopy`.
4. **Context Management**: Contexts are used to manage lifecycle and cancellation of operations, ensuring resources are properly cleaned up.

These design choices ensure robust and efficient log management within the Docker environment.

---

*Generated by CodeWorm on 2026-02-19 20:05*
