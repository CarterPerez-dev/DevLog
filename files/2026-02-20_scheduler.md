# scheduler

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/backup/scheduler.go
**Language:** go
**Lines:** 1-97
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
scheduler.go
*/

package backup

import (
	"context"
	"log/slog"
	"sync"

	"github.com/robfig/cron/v3"
)

type Scheduler struct {
	cron       *cron.Cron
	runBackup  func(ctx context.Context, dbName string) error
	jobs       map[string]cron.EntryID
	mu         sync.RWMutex
	logger     *slog.Logger
}

func NewScheduler(logger *slog.Logger) *Scheduler {
	return &Scheduler{
		cron:   cron.New(cron.WithSeconds()),
		jobs:   make(map[string]cron.EntryID),
		logger: logger,
	}
}

func (s *Scheduler) SetBackupFunc(fn func(ctx context.Context, dbName string) error) {
	s.runBackup = fn
}

func (s *Scheduler) AddJob(id, cronExpr, dbName string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	if existingID, exists := s.jobs[id]; exists {
		s.cron.Remove(existingID)
	}

	entryID, err := s.cron.AddFunc(cronExpr, func() {
		s.logger.Info("scheduled backup starting", "database", dbName, "schedule_id", id)

		ctx := context.Background()
		if err := s.runBackup(ctx, dbName); err != nil {
			s.logger.Error("scheduled backup failed", "database", dbName, "error", err)
			return
		}

		s.logger.Info("scheduled backup completed", "database", dbName)
	})
	if err != nil {
		return err
	}

	s.jobs[id] = entryID
	return nil
}

func (s *Scheduler) RemoveJob(id string) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if entryID, exists := s.jobs[id]; exists {
		s.cron.Remove(entryID)
		delete(s.jobs, id)
	}
}

func (s *Scheduler) Start() {
	s.cron.Start()
	s.logger.Info("backup scheduler started")
}

func (s *Scheduler) Stop() context.Context {
	s.logger.Info("backup scheduler stopping")
	return s.cron.Stop()
}

func (s *Scheduler) ListJobs() []string {
	s.mu.RLock()
	defer s.mu.RUnlock()

	ids := make([]string, 0, len(s.jobs))
	for id := range s.jobs {
		ids = append(ids, id)
	}
	return ids
}

func (s *Scheduler) Cron() *cron.Cron {
	return s.cron
}

```

---

## File Overview

# scheduler.go

## Purpose and Responsibility
This Go source file defines a `Scheduler` struct responsible for managing scheduled database backups using the `cron` package. It provides methods to set up backup functions, schedule jobs, manage running jobs, and control the cron scheduler.

## Key Exports and Public Interface
- **NewScheduler**: Initializes a new `Scheduler` instance with a logger.
- **SetBackupFunc**: Sets the function that performs database backups.
- **AddJob**: Schedules a job to run at specified intervals.
- **RemoveJob**: Removes an existing scheduled job.
- **Start**: Starts the cron scheduler.
- **Stop**: Stops the cron scheduler and returns a context for graceful shutdown.
- **ListJobs**: Lists all currently scheduled jobs.
- **Cron**: Returns the underlying `cron` instance.

## How It Fits in the Project
This file is part of the backup module, which handles automated database backups. The `Scheduler` struct integrates with the main application to ensure that backups are executed according to predefined schedules. It leverages Go's concurrency features and error handling idioms for robust scheduling and logging.

## Notable Design Decisions
- **Concurrency**: Utilizes goroutines via the `cron` package to handle scheduled tasks asynchronously.
- **Error Handling**: Logs errors during backup execution and job management, ensuring issues are tracked and can be addressed.
- **Synchronization**: Uses a mutex (`sync.RWMutex`) to safely manage access to shared state like jobs and cron entries.
- **Modularity**: Separates concerns by providing clear methods for setting up, managing, starting, stopping, and listing scheduled jobs.
```

This documentation provides an overview of the file's purpose, key components, integration within the project, and design choices.

---

*Generated by CodeWorm on 2026-02-20 00:30*
