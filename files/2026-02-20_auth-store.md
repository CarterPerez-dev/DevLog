# auth.store

**Type:** File Overview
**Repository:** ios-test
**File:** red-recon/src/core/lib/auth.store.ts
**Language:** typescript
**Lines:** 1-94
**Complexity:** 0.0

---

## Source Code

```typescript
/**
 * @AngelaMos | 2026
 * auth.store.ts
 */

import { type UserResponse, UserRole } from '@/api/types'
import { zustandStorage } from '@/core/storage'
import { create } from 'zustand'
import { createJSONStorage, persist } from 'zustand/middleware'

const YOUR_STORAGE_KEY = 'redrecon-auth'

interface AuthState {
  user: UserResponse | null
  isAuthenticated: boolean
  isLoading: boolean
  hasHydrated: boolean
}

interface AuthActions {
  login: (user: UserResponse) => void
  logout: () => void
  setLoading: (loading: boolean) => void
  updateUser: (updates: Partial<UserResponse>) => void
  setHasHydrated: (hydrated: boolean) => void
}

type AuthStore = AuthState & AuthActions

export const useAuthStore = create<AuthStore>()(
  persist(
    (set) => ({
      user: null,
      isAuthenticated: false,
      isLoading: true,
      hasHydrated: false,

      login: (user) =>
        set({
          user,
          isAuthenticated: true,
          isLoading: false,
        }),

      logout: () =>
        set({
          user: null,
          isAuthenticated: false,
          isLoading: false,
        }),

      setLoading: (loading) => set({ isLoading: loading }),

      updateUser: (updates) =>
        set((state) => ({
          user: state.user !== null ? { ...state.user, ...updates } : null,
        })),

      setHasHydrated: (hydrated) => set({ hasHydrated: hydrated }),
    }),
    {
      name: YOUR_STORAGE_KEY,
      storage: createJSONStorage(() => zustandStorage),
      partialize: (state) =>
        ({
          user: state.user,
          isAuthenticated: state.isAuthenticated,
        }) as AuthStore,
      onRehydrateStorage: () => (state) => {
        state?.setHasHydrated(true)
        state?.setLoading(false)
      },
    }
  )
)

export const useUser = (): UserResponse | null => useAuthStore((s) => s.user)
export const useIsAuthenticated = (): boolean =>
  useAuthStore((s) => s.isAuthenticated)
export const useIsAuthLoading = (): boolean => useAuthStore((s) => s.isLoading)
export const useHasHydrated = (): boolean => useAuthStore((s) => s.hasHydrated)

export const useHasRole = (role: UserRole): boolean => {
  const user = useAuthStore((s) => s.user)
  return user !== null && user.role === role
}

export const useIsAdmin = (): boolean => {
  const user = useAuthStore((s) => s.user)
  return user !== null && user.role === UserRole.ADMIN
}

export { UserRole }

```

---

## File Overview

### Documenting `auth.store.ts`

**Purpose and Responsibility:**
This file is responsible for managing authentication state within the application using Zustand, a state management library. It handles user login, logout, and role-based checks, ensuring that the state persists across sessions via local storage.

**Key Exports and Public API:**
- **`useAuthStore`:** The main store providing access to all auth-related states and actions.
- **`useUser`, `useIsAuthenticated`, `useIsAuthLoading`, `useHasHydrated`:** Convenience hooks for accessing specific pieces of authentication state.
- **`useHasRole` and `useIsAdmin`:** Custom hooks for role-based checks.

**How it Fits into the Project:**
This store is a critical component in managing user sessions, integrating with API responses to update user data. It ensures that user authentication status is consistent across different parts of the application, enhancing usability and security.

**Notable Design Decisions:**
- **State Management:** Utilizing Zustand for state management, leveraging its middleware for persistence.
- **Partial State Handling:** The `partialize` function in `persist` allows selective storage of state slices, optimizing storage usage.
- **Role-Based Access Control:** Custom hooks like `useHasRole` and `useIsAdmin` simplify role-based access control logic throughout the application.

---

*Generated by CodeWorm on 2026-02-20 16:55*
