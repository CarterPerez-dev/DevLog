# secure

**Type:** File Overview
**Repository:** CertGames-Core
**File:** backend/api/core/decorators/secure.py
**Language:** python
**Lines:** 1-302
**Complexity:** 0.0

---

## Source Code

```python
"""
Enterprise Security Decorator
/api/core/decorators/secure.py
"""

import time
import logging
from typing import Any
from functools import wraps
from datetime import datetime, UTC
from flask import g, request, make_response, Response
from collections.abc import Callable

from ..services.logging import AuditLogger
from ..services.security import SecurityService
from ..limiters.shared_rate_limiter import SharedRateLimiterBase
from .guards import (
    RateGuard,
    PatternGuard,
    RequestSizeGuard,
    TracingGuard,
)


logger = logging.getLogger(__name__)


class SecureRateLimiter(SharedRateLimiterBase):
    """
    Rate limiter for @secure decorator
    """
    def __init__(self, rate_guard: RateGuard, endpoint_key: str) -> None:
        """
        Initialize with RateGuard config
        """
        limits = rate_guard.to_dict()
        super().__init__(endpoint_key, limits)


def secure(*guards: Any) -> Callable[[Callable[...,
                                               Any]],
                                     Callable[...,
                                              Any]]:
    """
    Security decorator combining rate limiting, pattern detection,
    size validation, and behavior tracking.
    """
    rate_guard = None
    pattern_guard = None
    size_guard = RequestSizeGuard()
    tracing_guard = TracingGuard()

    for guard in guards:
        if isinstance(guard, RateGuard):
            rate_guard = guard
        elif isinstance(guard, PatternGuard):
            pattern_guard = guard
        elif isinstance(guard, RequestSizeGuard):
            size_guard = guard
        elif isinstance(guard, TracingGuard):
            tracing_guard = guard
        else:
            raise ValueError(f"Unknown guard type: {type(guard).__name__}")

    if not rate_guard:
        raise ValueError("RateGuard is required for @secure decorator")
    if not pattern_guard:
        raise ValueError("PatternGuard is required for @secure decorator")

    def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(f)
        def decorated_function(*args: Any, **kwargs: Any) -> Any:
            start_time = time.time()

            g.security_guards = {
                "rate": str(rate_guard),
                "pattern": str(pattern_guard),
                "size": str(size_guard),
                "tracing": str(tracing_guard),
            }

            size_exceeded, size_reason = SecurityService.check_request_size(
                max_body=size_guard.max_body_bytes,
                max_params=size_guard.max_params
            )
            if size_exceeded:
                _log_security_event("size_limit_exceeded", size_reason)
                return {"error": size_reason, "type": "request_size_error"}, 413

            security_analysis = SecurityService.analyze_request(
                security_level = pattern_guard.level,
                context = pattern_guard.context
            )

            if security_analysis["suspicious"]:
   
```

---

## File Overview

### Enterprise Security Decorator

**Purpose:**
This Python file implements a security decorator for Flask endpoints, ensuring rate limiting, pattern detection, request size validation, and behavior tracking.

**Key Exports:**
- `secure`: A decorator that combines multiple security guards.
- `_get_endpoint_key`: Generates an endpoint key for rate limiting.
- `_log_security_event`, `_track_detailed_behavior`, `_log_request_complete`: Utility functions for logging security events and request completion details.

**Project Fit:**
This file is part of the `/api/core/decorators` module, which provides reusable decorators for securing API endpoints. It integrates with other modules like `services.logging` and `limiters.shared_rate_limiter` to enforce security policies across the application.

**Design Decisions:**
- **Decorator Composition:** The `secure` decorator allows combining multiple guards (RateGuard, PatternGuard, RequestSizeGuard, TracingGuard) to create a comprehensive security layer.
- **Logging:** Utilizes custom logging mechanisms for detailed tracking and auditing of requests.
- **Rate Limiting:** Implements rate limiting using a shared limiter base class, ensuring consistent behavior across different endpoints.
- **Error Handling:** Gracefully handles request size limits and suspicious patterns by returning appropriate HTTP responses.

This decorator enhances the security posture of the application by providing a flexible and robust way to enforce various security policies at the API level.

---

*Generated by CodeWorm on 2026-02-19 00:49*
