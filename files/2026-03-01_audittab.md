# audittab

**Type:** File Overview
**Repository:** Yoshi-Audit
**File:** internal/ui/audittab/audittab.go
**Language:** go
**Lines:** 1-346
**Complexity:** 0.0

---

## Source Code

```go
// Â©AngelaMos | 2026
// audittab.go

package audittab

import (
	"fmt"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"

	"github.com/CarterPerez-dev/yoshi-audit/internal/audit"
	"github.com/CarterPerez-dev/yoshi-audit/internal/config"
	"github.com/CarterPerez-dev/yoshi-audit/internal/system"
	"github.com/CarterPerez-dev/yoshi-audit/internal/ui/theme"
)

const (
	statusOKFace   = "~(^.^)~"
	statusWarnFace = ">(o.O)>"
	statusCritFace = "X(x.x)X"
)

type SummaryCount struct {
	OK   int
	Warn int
	Crit int
}

type AuditDataMsg struct {
	Findings []audit.Finding
	Summary  map[audit.FindingType]SummaryCount
	Err      error
}

type AuditTab struct {
	findings   []audit.Finding
	summary    map[audit.FindingType]SummaryCount
	cursor     int
	scanner    *audit.Scanner
	baseline   *audit.Baseline
	rssHistory map[int][]uint64
	lastScan   time.Time
	scanning   bool
	showDetail int
	err        error
}

func NewAuditTab() AuditTab {
	bl := audit.NewBaseline()
	bl.Load(config.DefaultBaselinePath())
	return AuditTab{
		findings:   nil,
		scanner:    audit.NewScanner(bl),
		baseline:   bl,
		rssHistory: make(map[int][]uint64),
		showDetail: -1,
	}
}

func (at AuditTab) Scanner() *audit.Scanner {
	return at.scanner
}

func (at AuditTab) RSSHistory() map[int][]uint64 {
	return at.rssHistory
}

func FetchAuditData(scanner *audit.Scanner, rssHistory map[int][]uint64) tea.Msg {
	procs, err := system.GetProcesses()
	if err != nil {
		return AuditDataMsg{Err: err}
	}

	gpuProcs, _ := system.GetGPUProcesses()

	for _, p := range procs {
		rssHistory[p.PID] = append(rssHistory[p.PID], p.RSS)
	}

	findings := scanner.ScanAll(procs, gpuProcs)
	findings = append(findings, scanner.ScanMemoryLeaks(procs, rssHistory)...)

	summary := make(map[audit.FindingType]SummaryCount)
	allTypes := []audit.FindingType{
		audit.FindingZombie,
		audit.FindingOrphan,
		audit.FindingDaemon,
		audit.FindingKernelThread,
		audit.FindingGPUShadow,
		audit.FindingMemoryLeak,
		audit.FindingUnknownSvc,
	}
	for _, ft := range allTypes {
		summary[ft] = SummaryCount{}
	}
	for _, f := range findings {
		sc := summary[f.Type]
		switch f.Severity {
		case audit.SeverityOK:
			sc.OK++
		case audit.SeverityWarn:
			sc.Warn++
		case audit.SeverityCrit:
			sc.Crit++
		}
		summary[f.Type] = sc
	}

	return AuditDataMsg{
		Findings: findings,
		Summary:  summary,
	}
}

func (at AuditTab) Update(msg tea.Msg) (AuditTab, tea.Cmd) {
	switch msg := msg.(type) {
	case AuditDataMsg:
		if msg.Err != nil {
			at.err = msg.Err
			at.scanning = false
			return at, nil
		}
		at.findings = msg.Findings
		at.summary = msg.Summary
		at.lastScan = time.Now()
		at.scanning = false
		at.err = nil
	case tea.KeyMsg:
		filtered := at.filteredFindings()
		switch msg.String() {
		case "r":
			at.scanning = true
			scanner := at.scanner
			rssHistory := at.rssHistory
			return at, func() tea.Msg {
				return FetchAuditData(scanner, rssHistory)
			}
		case "up", "k":
			if at.cursor > 
```

---

## File Overview

# audittab.go Documentation

## Purpose and Responsibility
This file defines the `AuditTab` struct, which manages the state and operations for an audit tab within the application. It handles fetching and displaying audit findings, managing baseline updates, and updating the UI based on user input.

## Key Exports and Public Interface
- **SummaryCount**: A struct to hold summary counts of audit findings.
- **AuditDataMsg**: A message type containing findings, a summary map, and an error.
- **AuditTab**: The main struct for managing audit data and operations. It includes methods for fetching audit data, updating state based on user input, and filtering findings.

## How it Fits into the Project
`audittab.go` is part of the `yoshi-audit` project's UI module, specifically responsible for handling real-time audits and displaying results to the user. It interacts with other modules like `audit`, `config`, and `system` to fetch and process audit data.

## Notable Design Decisions
- **Error Handling**: Errors are handled gracefully by setting an error message in `AuditTab`.
- **State Management**: The `AuditTab` struct maintains state such as findings, summary counts, cursor position, and scanning status.
- **User Interaction**: Key bindings for rescanning, navigating findings, and updating the baseline provide a responsive user interface.
- **Scanning Mechanism**: Uses goroutines to manage background scanning without blocking the UI thread.
```

This documentation provides an overview of the file's role within the project, its key components, and important design choices.

---

*Generated by CodeWorm on 2026-03-01 10:55*
