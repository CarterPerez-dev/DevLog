# server

**Type:** File Overview
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/internal/server/server.go
**Language:** go
**Lines:** 1-109
**Complexity:** 0.0

---

## Source Code

```go
// AngelaMos | 2026
// server.go

package server

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	chimw "github.com/go-chi/chi/v5/middleware"

	"github.com/carterperez-dev/templates/go-backend/internal/config"
	"github.com/carterperez-dev/templates/go-backend/internal/health"
)

type Server struct {
	httpServer    *http.Server
	router        *chi.Mux
	config        config.ServerConfig
	healthHandler *health.Handler
	logger        *slog.Logger
}

type Config struct {
	ServerConfig  config.ServerConfig
	HealthHandler *health.Handler
	Logger        *slog.Logger
}

func New(cfg Config) *Server {
	router := chi.NewRouter()

	router.Use(chimw.CleanPath)
	router.Use(chimw.StripSlashes)

	return &Server{
		httpServer: &http.Server{
			Addr:         cfg.ServerConfig.Address(),
			Handler:      router,
			ReadTimeout:  cfg.ServerConfig.ReadTimeout,
			WriteTimeout: cfg.ServerConfig.WriteTimeout,
			IdleTimeout:  cfg.ServerConfig.IdleTimeout,
		},
		router:        router,
		config:        cfg.ServerConfig,
		healthHandler: cfg.HealthHandler,
		logger:        cfg.Logger,
	}
}

func (s *Server) Router() *chi.Mux {
	return s.router
}

func (s *Server) Start() error {
	s.logger.Info("starting HTTP server",
		"addr", s.config.Address(),
		"read_timeout", s.config.ReadTimeout,
		"write_timeout", s.config.WriteTimeout,
		"idle_timeout", s.config.IdleTimeout,
	)

	if err := s.httpServer.ListenAndServe(); err != nil &&
		!errors.Is(err, http.ErrServerClosed) {
		return fmt.Errorf("http server error: %w", err)
	}

	return nil
}

func (s *Server) Shutdown(ctx context.Context, drainDelay time.Duration) error {
	s.logger.Info("initiating graceful shutdown")

	s.logger.Info("marking server as not ready")
	if s.healthHandler != nil {
		s.healthHandler.SetReady(false)
		s.healthHandler.SetShutdown(true)
	}

	s.logger.Info("waiting for load balancer to drain",
		"delay", drainDelay,
	)
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-time.After(drainDelay):
	}

	s.logger.Info("stopping HTTP server")
	shutdownCtx, cancel := context.WithTimeout(ctx, s.config.ShutdownTimeout)
	defer cancel()

	if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
		return fmt.Errorf("http server shutdown: %w", err)
	}

	s.logger.Info("HTTP server stopped gracefully")
	return nil
}

func (s *Server) Address() string {
	return s.httpServer.Addr
}

```

---

## File Overview

# server.go

## Purpose and Responsibility
This Go source file defines the `Server` struct and its associated methods, responsible for setting up and managing an HTTP server within a larger backend application. It integrates with external configurations, health checks, and logging to ensure robust and maintainable service management.

## Key Exports and Public Interface
- **Config**: A struct containing configuration parameters for the server.
- **New**: A constructor function that initializes a new `Server` instance.
- **Router**: A method returning the Chi router used by the server.
- **Start**: A method to start the HTTP server with logging and error handling.
- **Shutdown**: A method to gracefully shut down the server, allowing for controlled shutdown processes.

## How It Fits in the Project
This file serves as a central hub for initializing and managing the application's HTTP server. It leverages external packages like `go-chi` for routing and `log/slog` for structured logging, ensuring that the server is both flexible and robust. The `Server` struct encapsulates all necessary components to handle incoming requests, manage health checks, and ensure a smooth shutdown process.

## Notable Design Decisions
- **Error Handling**: Errors are handled gracefully with detailed logging and appropriate error propagation.
- **Graceful Shutdown**: A well-defined shutdown mechanism ensures that the server can be safely stopped without abrupt termination of processes.
- **Dependency Injection**: The `Config`, `HealthHandler`, and `Logger` dependencies are passed via constructor injection, promoting loose coupling and testability.

This file is crucial for setting up the application's network interface and ensuring it operates efficiently within the broader project architecture.

---

*Generated by CodeWorm on 2026-02-19 17:46*
