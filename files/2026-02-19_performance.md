# performance

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/routes/performance.rs
**Language:** rust
**Lines:** 1-414
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Performance monitoring route handlers providing real-time system metrics and benchmark capabilities for the showcase.
 * I'm implementing comprehensive performance endpoints that demonstrate system capabilities while providing valuable diagnostic information.
 */

use axum::{
    extract::{Query, State},
    http::StatusCode,
    Json,
    response::Json as JsonResponse,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tracing::{info, warn, error};
use sysinfo::{System, SystemExt, CpuExt, DiskExt, NetworkExt};

use crate::{
    utils::error::{AppError, Result},
    AppState,
};

#[derive(Debug, Deserialize)]
pub struct MetricsQuery {
    pub history_limit: Option<usize>,
    pub include_history: Option<bool>,
}

#[derive(Debug, Serialize)]
pub struct CurrentMetricsResponse {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub system: SystemPerformance,
    pub application: ApplicationPerformance,
    pub hardware: HardwareInfo,
    pub runtime: RuntimeInfo,
}

#[derive(Debug, Serialize)]
pub struct SystemPerformance {
    pub cpu_usage_percent: f64,
    pub memory_usage_percent: f64,
    pub memory_total_gb: f64,
    pub memory_available_gb: f64,
    pub disk_usage_percent: f64,
    pub load_average_1m: f64,
    pub load_average_5m: f64,
    pub load_average_15m: f64,
    pub uptime_seconds: u64,
    pub active_processes: u32,
}

#[derive(Debug, Serialize)]
pub struct ApplicationPerformance {
    pub requests_handled: u64,
    pub average_response_time_ms: f64,
    pub fractal_computations: u64,
    pub github_api_calls: u64,
    pub cache_hit_rate: f64,
    pub database_connections: u32,
    pub memory_usage_mb: f64,
}

#[derive(Debug, Serialize)]
pub struct HardwareInfo {
    pub cpu_model: String,
    pub cpu_cores: u32,
    pub cpu_threads: u32,
    pub architecture: String,
    pub total_memory_gb: f64,
}

#[derive(Debug, Serialize)]
pub struct RuntimeInfo {
    pub rust_version: String,
    pub build_type: String,
    pub optimization_level: String,
    pub features_enabled: Vec<String>,
}

/// Get current performance metrics with comprehensive system analysis
/// I'm providing real-time performance data for monitoring and display
pub async fn get_current_metrics(
    State(app_state): State<AppState>,
    Query(params): Query<MetricsQuery>,
) -> Result<JsonResponse<CurrentMetricsResponse>> {
    info!("Fetching current performance metrics");

    // Collect system metrics
    let mut system = System::new_all();
    system.refresh_all();

    let system_perf = SystemPerformance {
        cpu_usage_percent: system.global_cpu_info().cpu_usage() as f64,
        memory_usage_percent: {
            let total = system.total_memory() as f64;
            let available = system.available_memory() as f64;
            ((total - available) / total) * 100.0
        },
        memory_total_gb: system.total_memory() as f64 / (1024.0 * 1024.0 * 1024.0),
        memory_available_gb: system.available_memory() as f64 / (1
```

---

## File Overview

### Performance Monitoring Route Handlers

**Purpose and Responsibility:**
This file defines route handlers for real-time performance monitoring, providing system metrics and application performance data to demonstrate and diagnose system capabilities.

**Key Exports and Public Interface:**
- `get_current_metrics`: A handler function that fetches and returns current performance metrics.
- Data structures like `MetricsQuery`, `CurrentMetricsResponse`, `SystemPerformance`, `ApplicationPerformance`, `HardwareInfo`, and `RuntimeInfo` for structured data representation.

**How It Fits in the Project:**
This file is part of the backend API, specifically handling requests related to system performance. It integrates with other components such as database connections (`AppState`) and utility functions for error handling. The metrics collected are crucial for monitoring and debugging the application's runtime behavior.

**Notable Design Decisions:**
- **Comprehensive Metrics**: The handler collects a wide range of system and application performance data, ensuring a holistic view.
- **Error Handling**: Uses `Result` to manage potential errors gracefully, logging issues with `tracing`.
- **Lazy Initialization**: CPU core and thread counts are calculated lazily for efficiency.
- **External Dependencies**: Relies on `sysinfo` for system metrics and `axum` for HTTP request handling.
```

This documentation provides a high-level overview of the file's purpose, key components, integration within the project, and design choices.

---

*Generated by CodeWorm on 2026-02-19 21:30*
