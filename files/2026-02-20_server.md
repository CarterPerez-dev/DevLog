# server

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/internal/server/server.go
**Language:** go
**Lines:** 1-111
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2025
server.go
*/

package server

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	chimw "github.com/go-chi/chi/v5/middleware"

	"github.com/carterperez-dev/templates/go-backend/internal/config"
	"github.com/carterperez-dev/templates/go-backend/internal/health"
)

type Server struct {
	httpServer    *http.Server
	router        *chi.Mux
	config        config.ServerConfig
	healthHandler *health.Handler
	logger        *slog.Logger
}

type Config struct {
	ServerConfig  config.ServerConfig
	HealthHandler *health.Handler
	Logger        *slog.Logger
}

func New(cfg Config) *Server {
	router := chi.NewRouter()

	router.Use(chimw.CleanPath)
	router.Use(chimw.StripSlashes)

	return &Server{
		httpServer: &http.Server{
			Addr:         cfg.ServerConfig.Address(),
			Handler:      router,
			ReadTimeout:  cfg.ServerConfig.ReadTimeout,
			WriteTimeout: cfg.ServerConfig.WriteTimeout,
			IdleTimeout:  cfg.ServerConfig.IdleTimeout,
		},
		router:        router,
		config:        cfg.ServerConfig,
		healthHandler: cfg.HealthHandler,
		logger:        cfg.Logger,
	}
}

func (s *Server) Router() *chi.Mux {
	return s.router
}

func (s *Server) Start() error {
	s.logger.Info("starting HTTP server",
		"addr", s.config.Address(),
		"read_timeout", s.config.ReadTimeout,
		"write_timeout", s.config.WriteTimeout,
		"idle_timeout", s.config.IdleTimeout,
	)

	if err := s.httpServer.ListenAndServe(); err != nil &&
		!errors.Is(err, http.ErrServerClosed) {
		return fmt.Errorf("http server error: %w", err)
	}

	return nil
}

func (s *Server) Shutdown(ctx context.Context, drainDelay time.Duration) error {
	s.logger.Info("initiating graceful shutdown")

	s.logger.Info("marking server as not ready")
	if s.healthHandler != nil {
		s.healthHandler.SetReady(false)
		s.healthHandler.SetShutdown(true)
	}

	s.logger.Info("waiting for load balancer to drain",
		"delay", drainDelay,
	)
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-time.After(drainDelay):
	}

	s.logger.Info("stopping HTTP server")
	shutdownCtx, cancel := context.WithTimeout(ctx, s.config.ShutdownTimeout)
	defer cancel()

	if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
		return fmt.Errorf("http server shutdown: %w", err)
	}

	s.logger.Info("HTTP server stopped gracefully")
	return nil
}

func (s *Server) Address() string {
	return s.httpServer.Addr
}

```

---

## File Overview

### Purpose and Responsibility

This `server.go` file is responsible for initializing, starting, and shutting down a Go HTTP server. It sets up routing using the Chi router and integrates with other components like configuration, health checks, and logging.

### Key Exports and Public Interface

- **Server**: A struct representing the HTTP server instance.
- **Config**: A struct containing necessary configurations for the server.
- `New(Config) *Server`: Initializes a new server instance.
- `Router() *chi.Mux`: Returns the Chi router used by the server.
- `Start() error`: Starts the HTTP server with specified configurations and logging.
- `Shutdown(context.Context, time.Duration) error`: Gracefully shuts down the HTTP server after marking it as not ready.

### How It Fits in the Project

This file acts as a central hub for setting up and managing the HTTP server within the project. It integrates with other modules like configuration (`config` package), health checks (`health` package), and logging (`log/slog`). The Chi router is used to define routes, which are then handled by various handlers.

### Notable Design Decisions

- **Error Handling**: Errors during startup or shutdown are logged and returned as errors.
- **Graceful Shutdown**: Implements a graceful shutdown mechanism with configurable delay and timeout.
- **Dependency Injection**: Uses dependency injection for configurations, health handlers, and logging to promote testability and modularity.
- **Go Idioms**: Adheres to Go idioms such as using `context` for lifecycle management and `timeouts` for server operations.
```

This documentation provides an overview of the file's role in the project, its public interface, and key design choices.

---

*Generated by CodeWorm on 2026-02-20 01:11*
