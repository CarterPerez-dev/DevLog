# api

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** frontend/src/services/api.ts
**Language:** typescript
**Lines:** 1-382
**Complexity:** 0.0

---

## Source Code

```typescript
/*
 * Â©AngelaMos | 2025
 */

interface ApiResponse<T> {
  data: T;
  timestamp: string;
  status: number;
}

interface ApiError {
  code: string;
  message: string;
  details?: any;
  timestamp: string;
}

interface RequestConfig {
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  skipCache?: boolean;
  requireAuth?: boolean;
}

class ApiClient {
  private baseURL: string;
  private defaultTimeout: number;
  private requestInterceptors: ((config: RequestInit) => RequestInit)[];
  private responseInterceptors: ((
    response: Response,
  ) => Promise<Response>)[];
  private circuitBreaker: Map<
    string,
    { failures: number; lastFailure: number; isOpen: boolean }
  >;

  constructor() {
    const isServer = typeof window === 'undefined';
    this.baseURL = isServer ? 'http://nginx:80' : '';
    this.defaultTimeout = 30000; // 30 seconds default timeout
    this.requestInterceptors = [];
    this.responseInterceptors = [];
    this.circuitBreaker = new Map();

    this.setupDefaultInterceptors();
  }

  private setupDefaultInterceptors() {
    this.addRequestInterceptor((config: RequestInit) => {
      const correlationId =
        (typeof crypto !== 'undefined' && crypto.randomUUID?.()) ||
        `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;

      return {
        ...config,
        headers: {
          'Content-Type': 'application/json',
          'X-Correlation-ID': correlationId,
          'X-Request-Start': Date.now().toString(),
          ...config.headers,
        },
      };
    });

    this.addResponseInterceptor(async (response: Response) => {
      const requestStart = response.headers.get('X-Request-Start');
      if (requestStart) {
        const duration = Date.now() - parseInt(requestStart);
        console.debug(`API Request completed in ${duration}ms`, {
          url: response.url,
          status: response.status,
          duration,
        });
      }

      return response;
    });
  }

  addRequestInterceptor(interceptor: (config: RequestInit) => RequestInit) {
    this.requestInterceptors.push(interceptor);
  }

  addResponseInterceptor(
    interceptor: (response: Response) => Promise<Response>,
  ) {
    this.responseInterceptors.push(interceptor);
  }

  private checkCircuitBreaker(endpoint: string): boolean {
    const circuit = this.circuitBreaker.get(endpoint);
    if (!circuit) return true;

    if (circuit.isOpen && Date.now() - circuit.lastFailure > 30000) {
      circuit.isOpen = false;
      circuit.failures = 0;
    }

    return !circuit.isOpen;
  }

  private recordFailure(endpoint: string) {
    const circuit = this.circuitBreaker.get(endpoint) || {
      failures: 0,
      lastFailure: 0,
      isOpen: false,
    };
    circuit.failures++;
    circuit.lastFailure = Date.now();

    // Open circuit after 2 failures
    if (circuit.failures >= 2) {
      circuit.isOpen = true;
      console.warn(
        `Circuit breaker opened for ${endpoint} after ${circuit.failures}
```

---

## File Overview

### Purpose and Responsibility

This TypeScript source file defines an `ApiClient` class responsible for handling HTTP requests to a backend API, including error handling, circuit breaker logic, request interceptors, and response interceptors. It ensures robust and reliable communication with the server by managing retries, timeouts, and caching.

### Key Exports and Public Interface

- **Class**: `ApiClient`
  - **Methods**:
    - `addRequestInterceptor`: Adds a function to modify outgoing requests.
    - `addResponseInterceptor`: Adds a function to process incoming responses.
    - `executeRequest`: Executes an HTTP request with retry logic, circuit breaker checks, and timeout handling.

### How It Fits in the Project

This file is part of the frontend services layer. The `ApiClient` class is used throughout the application for making API calls, ensuring consistency and reliability across different components. It integrates seamlessly with other services and components that require HTTP communication, providing a centralized point for managing API interactions.

### Notable Design Decisions

- **Circuit Breaker**: Implements a circuit breaker to prevent overwhelming the server by limiting retries after a certain number of failures.
- **Exponential Backoff Retries**: Uses an exponential backoff strategy with configurable retry attempts and delays.
- **Request/Response Interceptors**: Allows for custom modifications to requests and responses, promoting loose coupling and easier maintenance.
- **Timeout Handling**: Utilizes `AbortController` to handle timeouts gracefully by aborting the request if it exceeds a specified duration.

This design ensures robust API interactions while maintaining flexibility and ease of use across the application.

---

*Generated by CodeWorm on 2026-02-19 22:44*
