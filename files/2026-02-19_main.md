# main

**Type:** File Overview
**Repository:** fullstack-template
**File:** stacks/go-react/go-backend/cmd/api/main.go
**Language:** go
**Lines:** 1-222
**Complexity:** 0.0

---

## Source Code

```go
// AngelaMos | 2026
// main.go

package main

import (
	"context"
	"flag"
	"log/slog"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-chi/chi/v5"

	"github.com/carterperez-dev/templates/go-backend/internal/admin"
	"github.com/carterperez-dev/templates/go-backend/internal/auth"
	"github.com/carterperez-dev/templates/go-backend/internal/config"
	"github.com/carterperez-dev/templates/go-backend/internal/core"
	"github.com/carterperez-dev/templates/go-backend/internal/health"
	"github.com/carterperez-dev/templates/go-backend/internal/middleware"
	"github.com/carterperez-dev/templates/go-backend/internal/server"
	"github.com/carterperez-dev/templates/go-backend/internal/user"
)

const (
	drainDelay = 5 * time.Second
)

func main() {
	configPath := flag.String("config", "config.yaml", "path to config file")
	flag.Parse()

	if err := run(*configPath); err != nil {
		slog.Error("application error", "error", err)
		os.Exit(1)
	}
}

//nolint:funlen // bootstrap code is inherently verbose
func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	var telemetry *core.Telemetry
	if cfg.Otel.Enabled {
		tel, telErr := core.NewTelemetry(ctx, cfg.Otel, cfg.App)
		if telErr != nil {
			logger.Warn("failed to initialize telemetry", "error", telErr)
		} else {
			telemetry = tel
			logger.Info("OpenTelemetry tracer initialized",
				"endpoint", cfg.Otel.Endpoint,
			)
		}
	}

	db, err := core.NewDatabase(ctx, cfg.Database)
	if err != nil {
		return err
	}
	logger.Info("database connected",
		"max_open_conns", cfg.Database.MaxOpenConns,
		"max_idle_conns", cfg.Database.MaxIdleConns,
	)

	redis, err := core.NewRedis(ctx, cfg.Redis)
	if err != nil {
		return err
	}
	logger.Info("redis connected",
		"pool_size", cfg.Redis.PoolSize,
	)

	jwtManager, err := auth.NewJWTManager(cfg.JWT)
	if err != nil {
		return err
	}
	logger.Info("JWT manager initialized",
		"algorithm", "ES256",
		"key_id", jwtManager.GetKeyID(),
	)

	userRepo := user.NewRepository(db.DB)
	userSvc := user.NewService(userRepo)
	userHandler := user.NewHandler(userSvc)

	authRepo := auth.NewRepository(db.DB)
	authSvc := auth.NewService(authRepo, jwtManager, userSvc, redis.Client)
	authHandler := auth.NewHandler(authSvc)

	healthHandler := health.NewHandler(db, redis)

	adminHandler := admin.NewHandler(admin.HandlerConfig{
		DBStats:    db.Stats,
		RedisStats: redis.PoolStats,
		DBPing:     db.Ping,
		RedisPing:  redis.Ping,
	})

	srv := server.New(server.Config{
		ServerConfig:  cfg.Server,
		HealthHandler: healthHandler,
		Logger:        logger,
	})

	router := srv.Router()

	router.Use(middleware.RequestID)
	router.Use(middleware.Logger(logger))
	ro
```

---

## File Overview

# main.go Documentation

## Purpose and Responsibility
This Go source file serves as the entry point for the application, handling initialization, configuration loading, and starting the server. It sets up various services such as database connections, Redis clients, JWT managers, and HTTP handlers.

## Key Exports or Public Interface
- `main()`: The main function that initializes and starts the application.
- `run(configPath string) error`: A helper function to encapsulate the initialization logic.

## How it Fits in the Project
`main.go` acts as the central hub for bootstrapping the application. It leverages other internal packages like `config`, `core`, `auth`, `user`, and `server` to set up the necessary components. The file integrates these services into a cohesive HTTP server, handling routes, middleware, and shutdown logic.

## Notable Design Decisions
1. **Dependency Injection**: Services such as database, Redis, JWT manager, and handlers are created using dependencies from configuration files.
2. **Error Handling**: Errors are logged and handled gracefully, ensuring the application can recover or shut down cleanly.
3. **Shutdown Grace Period**: A shutdown context with a timeout is used to ensure all services have time to drain connections before closing.
4. **Rate Limiting and Security Headers**: Middleware for rate limiting and security headers are applied to protect against common web vulnerabilities.
5. **OpenTelemetry Integration**: Telemetry initialization and shutdown are managed, providing visibility into application performance.

This design ensures a modular, robust, and maintainable architecture, adhering to Go idioms like error handling and middleware composition.

---

*Generated by CodeWorm on 2026-02-19 17:16*
