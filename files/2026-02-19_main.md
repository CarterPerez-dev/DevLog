# main

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/cmd/api/main.go
**Language:** go
**Lines:** 1-217
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
main.go
*/

package main

import (
	"context"
	"flag"
	"log/slog"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/joho/godotenv"

	"github.com/carterperez-dev/templates/go-backend/internal/backup"
	"github.com/carterperez-dev/templates/go-backend/internal/cleanup"
	"github.com/carterperez-dev/templates/go-backend/internal/config"
	"github.com/carterperez-dev/templates/go-backend/internal/handler"
	"github.com/carterperez-dev/templates/go-backend/internal/health"
	"github.com/carterperez-dev/templates/go-backend/internal/metrics"
	"github.com/carterperez-dev/templates/go-backend/internal/middleware"
	"github.com/carterperez-dev/templates/go-backend/internal/mongodb"
	"github.com/carterperez-dev/templates/go-backend/internal/server"
	"github.com/carterperez-dev/templates/go-backend/internal/sqlite"
	"github.com/carterperez-dev/templates/go-backend/internal/websocket"
)

const (
	drainDelay = 5 * time.Second
)

func main() {
	configPath := flag.String("config", "config.yaml", "path to config file")
	flag.Parse()

	if err := run(*configPath); err != nil {
		slog.Error("application error", "error", err)
		os.Exit(1)
	}
}

func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	_ = godotenv.Load()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	mongoClient, err := mongodb.NewClient(ctx, cfg.Mongo)
	if err != nil {
		return err
	}
	logger.Info("mongodb connected",
		"database", cfg.Mongo.Database,
		"max_pool_size", cfg.Mongo.MaxPoolSize,
	)

	sqliteClient, err := sqlite.NewClient(cfg.SQLite)
	if err != nil {
		return err
	}
	logger.Info("sqlite connected",
		"path", cfg.SQLite.Path,
	)

	healthHandler := health.NewHandler(mongoClient, sqliteClient)

	metricsRepo := mongodb.NewMetricsRepository(mongoClient)
	metricsSvc := metrics.NewService(metricsRepo, cfg.Mongo.Database)
	metricsHandler := handler.NewMetricsHandler(metricsSvc)

	backupRepo := sqlite.NewBackupRepository(sqliteClient)
	backupExecutor := backup.NewExecutor(cfg.Backup, cfg.Mongo.URI)
	backupScheduler := backup.NewScheduler(logger)
	backupSvc := backup.NewService(backupExecutor, backupScheduler, backupRepo, cfg.Backup.RetentionDays, logger)
	backupsHandler := handler.NewBackupsHandler(backupSvc, cfg.Mongo.Database)

	collectionsRepo := mongodb.NewCollectionsRepository(mongoClient)
	collectionsHandler := handler.NewCollectionsHandler(collectionsRepo, cfg.Mongo.Database)

	cleanupSvc := cleanup.NewService(mongoClient.Client(), cfg.Mongo.Database, 30, logger)

	wsHub := websocket.NewHub(logger)
	go wsHub.Run(ctx)

	wsHandler := websocket.NewHandler(wsHub, logger)

	metricsGetter := func(ctx context.Context) (any, error) {
		return metricsSvc.GetDashboardMetrics(c
```

---

## File Overview

### main.go

**Purpose and Responsibility:**
This file serves as the entry point for the Go backend application, responsible for initializing various components such as configuration loading, database connections, service setup, and server startup. It ensures proper error handling and graceful shutdown.

**Key Exports or Public Interface:**
- `main`: The main function that initializes the application.
- `run`: A helper function to encapsulate the initialization logic.

**How it Fits in the Project:**
`main.go` acts as the central hub, coordinating the setup of various services and handlers. It leverages configuration files, external dependencies, and logging to ensure a robust and maintainable architecture. The file integrates multiple internal packages like `config`, `mongodb`, `sqlite`, `metrics`, `backup`, `health`, `middleware`, `server`, and `websocket` to form the core functionality of the application.

**Notable Design Decisions:**
- **Error Handling:** Errors are logged using structured logging with `slog`. The application exits on critical errors.
- **Graceful Shutdown:** A shutdown context is used to handle graceful termination, ensuring that all services have a chance to clean up properly before exiting.
- **Dependency Injection:** Services and repositories are initialized with dependencies like database clients and configuration settings, promoting loose coupling.
- **Concurrency:** Goroutines are used for background tasks such as websocket broadcasting and daily backups, ensuring non-blocking execution.
```

This documentation provides an overview of the file's role within the project, its key components, and significant design choices.

---

*Generated by CodeWorm on 2026-02-19 23:59*
