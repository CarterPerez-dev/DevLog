# main

**Type:** File Overview
**Repository:** oneIsNun_
**File:** go-backend/cmd/api/main.go
**Language:** go
**Lines:** 1-217
**Complexity:** 0.0

---

## Source Code

```go
/*
AngelaMos | 2026
main.go
*/

package main

import (
	"context"
	"flag"
	"log/slog"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/joho/godotenv"

	"github.com/carterperez-dev/templates/go-backend/internal/backup"
	"github.com/carterperez-dev/templates/go-backend/internal/cleanup"
	"github.com/carterperez-dev/templates/go-backend/internal/config"
	"github.com/carterperez-dev/templates/go-backend/internal/handler"
	"github.com/carterperez-dev/templates/go-backend/internal/health"
	"github.com/carterperez-dev/templates/go-backend/internal/metrics"
	"github.com/carterperez-dev/templates/go-backend/internal/middleware"
	"github.com/carterperez-dev/templates/go-backend/internal/mongodb"
	"github.com/carterperez-dev/templates/go-backend/internal/server"
	"github.com/carterperez-dev/templates/go-backend/internal/sqlite"
	"github.com/carterperez-dev/templates/go-backend/internal/websocket"
)

const (
	drainDelay = 5 * time.Second
)

func main() {
	configPath := flag.String("config", "config.yaml", "path to config file")
	flag.Parse()

	if err := run(*configPath); err != nil {
		slog.Error("application error", "error", err)
		os.Exit(1)
	}
}

func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	_ = godotenv.Load()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	mongoClient, err := mongodb.NewClient(ctx, cfg.Mongo)
	if err != nil {
		return err
	}
	logger.Info("mongodb connected",
		"database", cfg.Mongo.Database,
		"max_pool_size", cfg.Mongo.MaxPoolSize,
	)

	sqliteClient, err := sqlite.NewClient(cfg.SQLite)
	if err != nil {
		return err
	}
	logger.Info("sqlite connected",
		"path", cfg.SQLite.Path,
	)

	healthHandler := health.NewHandler(mongoClient, sqliteClient)

	metricsRepo := mongodb.NewMetricsRepository(mongoClient)
	metricsSvc := metrics.NewService(metricsRepo, cfg.Mongo.Database)
	metricsHandler := handler.NewMetricsHandler(metricsSvc)

	backupRepo := sqlite.NewBackupRepository(sqliteClient)
	backupExecutor := backup.NewExecutor(cfg.Backup, cfg.Mongo.URI)
	backupScheduler := backup.NewScheduler(logger)
	backupSvc := backup.NewService(backupExecutor, backupScheduler, backupRepo, cfg.Backup.RetentionDays, logger)
	backupsHandler := handler.NewBackupsHandler(backupSvc, cfg.Mongo.Database)

	collectionsRepo := mongodb.NewCollectionsRepository(mongoClient)
	collectionsHandler := handler.NewCollectionsHandler(collectionsRepo, cfg.Mongo.Database)

	cleanupSvc := cleanup.NewService(mongoClient.Client(), cfg.Mongo.Database, 30, logger)

	wsHub := websocket.NewHub(logger)
	go wsHub.Run(ctx)

	wsHandler := websocket.NewHandler(wsHub, logger)

	metricsGetter := func(ctx context.Context) (any, error) {
		return metricsSvc.GetDashboardMetrics(c
```

---

## File Overview

# main.go

## Purpose and Responsibility
This Go source file serves as the entry point for the `oneIsNun_` backend application, responsible for initializing various services and starting the server. It handles configuration loading, dependency setup, and lifecycle management of critical components like MongoDB, SQLite, health checks, metrics, backups, and websockets.

## Key Exports or Public Interface
- **run(configPath string)**: The main function that initializes the application with a given configuration path.
- **setupLogger(cfg config.Config)**: Configures the logging mechanism using the provided configuration.

## How It Fits in the Project
`main.go` acts as the central orchestrator, bringing together various internal packages to form a cohesive backend service. It sets up database connections, health checks, metrics collection, backup scheduling, and websocket handling. The application is structured around modular components, each responsible for specific functionalities like `mongodb`, `sqlite`, `health`, `metrics`, `backup`, `collections`, and `websocket`.

## Notable Design Decisions
- **Error Handling**: Errors are logged using the `slog` package to ensure critical issues are captured.
- **Context Management**: The use of context for lifecycle management, ensuring graceful shutdown and cleanup processes.
- **Dependency Injection**: Services like `MongoDB`, `SQLite`, and `Metrics` are instantiated with dependencies injected through constructors, promoting loose coupling.
- **Concurrency**: Goroutines are used to run background tasks such as backup scheduling and websocket handling, allowing the application to remain responsive.

---

*Generated by CodeWorm on 2026-02-19 23:59*
