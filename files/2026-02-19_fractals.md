# fractals

**Type:** File Overview
**Repository:** kill-pr0cess.inc
**File:** backend/src/routes/fractals.rs
**Language:** rust
**Lines:** 1-394
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * ©AngelaMos | 2025
 */

use axum::{
    extract::{Query, State},
    http::StatusCode,
    Json,
    response::Response,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tracing::{info, warn, error};
use uuid::Uuid;

use crate::{
    services::fractal_service::{FractalService, FractalRequest, FractalResponse, FractalType},
    utils::error::{AppError, Result},
    AppState,
};

#[derive(Debug, Deserialize)]
pub struct MandelbrotQuery {
    pub width: Option<u32>,
    pub height: Option<u32>,
    pub center_x: Option<f64>,
    pub center_y: Option<f64>,
    pub zoom: Option<f64>,
    pub max_iterations: Option<u32>,
}

#[derive(Debug, Deserialize)]
pub struct JuliaQuery {
    pub width: Option<u32>,
    pub height: Option<u32>,
    pub center_x: Option<f64>,
    pub center_y: Option<f64>,
    pub zoom: Option<f64>,
    pub max_iterations: Option<u32>,
    pub c_real: Option<f64>,
    pub c_imag: Option<f64>,
}

#[derive(Debug, Serialize)]
pub struct FractalApiResponse {
    pub data: Vec<u8>,
    pub width: u32,
    pub height: u32,
    pub computation_time_ms: u128,
    pub zoom_level: f64,
    pub parameters: serde_json::Value,
    pub performance_metrics: PerformanceMetrics,
}

#[derive(Debug, Serialize)]
pub struct PerformanceMetrics {
    pub pixels_per_second: f64,
    pub parallel_efficiency: f64,
    pub memory_usage_mb: f64,
    pub cpu_utilization: f64,
}

/// Generate Mandelbrot fractal with real-time performance tracking
/// I'm implementing comprehensive parameter validation and performance optimization
pub async fn generate_mandelbrot(
    State(app_state): State<AppState>,
                                 Query(params): Query<MandelbrotQuery>,
) -> Result<Json<FractalApiResponse>> {
    info!("Generating Mandelbrot fractal with params: {:?}", params);

    // I'm setting sensible defaults and validating parameters for safety
    let width = params.width.unwrap_or(800).clamp(64, 4096);
    let height = params.height.unwrap_or(600).clamp(64, 4096);
    let center_x = params.center_x.unwrap_or(-0.5).clamp(-2.0, 2.0);
    let center_y = params.center_y.unwrap_or(0.0).clamp(-2.0, 2.0);
    let zoom = params.zoom.unwrap_or(1.0).clamp(0.1, 1e15);
    let max_iterations = params.max_iterations.unwrap_or(100).clamp(50, 10000);

    let request = FractalRequest {
        width,
        height,
        center_x,
        center_y,
        zoom,
        max_iterations,
        fractal_type: FractalType::Mandelbrot,
    };

    // Record system state before computation
    let start_memory = get_memory_usage();
    let start_cpu = get_cpu_usage().await;

    // Generate the fractal using our high-performance service
    let response = app_state.fractal_service.generate_mandelbrot(request.clone());

    // Calculate performance metrics
    let end_memory = get_memory_usage();
    let end_cpu = get_cpu_usage().await;

    let pixels_per_second = (width * height) as f64 / (response.computation_time_ms as f64 / 1000.0);
```

---

## File Overview

### Purpose and Responsibility

This Rust source file, `fractals.rs`, is responsible for handling HTTP requests to generate Mandelbrot and Julia fractal images with real-time performance tracking. It integrates with a service layer (`FractalService`) to compute the fractal data and records performance metrics.

### Key Exports and Public API

- **Endpoints:**
  - `generate_mandelbrot`: Generates a Mandelbrot fractal based on query parameters.
  - `generate_julia`: Generates a Julia set fractal with customizable complex parameters.

- **Responses:**
  - Returns a `FractalApiResponse` containing the generated image data, dimensions, computation time, and performance metrics.

### How It Fits into the Project

This file is part of the backend service for the `kill-pr0cess.inc` repository. It sits between the HTTP request handling layer (using Axum) and the fractal generation logic provided by `FractalService`. The generated data and performance metrics are stored in a database for analytics, contributing to the overall system's monitoring capabilities.

### Notable Design Decisions

- **Parameter Validation:** Default values and parameter validation ensure robustness.
- **Performance Tracking:** Comprehensive tracking of memory usage, CPU utilization, and parallel efficiency is implemented using `PerformanceMetrics`.
- **Error Handling:** Utilizes Rust’s `Result` type to handle potential errors gracefully, logging warnings and errors for debugging.
- **Dependency Injection:** The `FractalService` is injected via the `AppState`, allowing for flexible service implementations.

---

*Generated by CodeWorm on 2026-02-19 21:40*
