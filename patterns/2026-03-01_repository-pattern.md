# repository_pattern

**Type:** Pattern Analysis
**Repository:** stripe-referral
**File:** src/stripe_referral/services/referral_service.py
**Language:** python
**Lines:** 1-220
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025 | CertGames.com
Referral service with business logic
"""

from datetime import UTC, datetime
from sqlalchemy.orm import Session

from ..config.enums import ReferralCodeStatus
from ..exceptions.errors import (
    CodeExpiredError,
    CodeInactiveError,
    CodeMaxUsesReachedError,
    CodeNotFoundError,
    ProgramNotFoundError,
    SelfReferralError,
)
from ..repositories.referral_repo import (
    ReferralCodeRepository,
    ReferralTrackingRepository,
)
from ..repositories.program_repo import (
    ReferralProgramRepository,
)
from ..schemas.types import (
    CodeValidation,
    CreateCodeResult,
    ReferralHistoryItem,
    TrackReferralResult,
    UserEarnings,
)
from ..utils.code_generator import generate_unique_code


class ReferralService:
    """
    Service for referral business logic
    """
    @staticmethod
    def create_code(
        db: Session,
        user_id: str,
        program_key: str
    ) -> CreateCodeResult:
        """
        Generate unique referral code for a user
        """
        program_repo = ReferralProgramRepository(db)
        code_repo = ReferralCodeRepository(db)

        program = program_repo.get_by_key(program_key)
        if not program or not program.is_active:
            raise ProgramNotFoundError(
                f"Program '{program_key}' not found or inactive",
                program_key = program_key,
            )

        def check_collision(code_string: str) -> bool:
            """
            Check if code already exists in database
            """
            existing = code_repo.get_by_code(code_string)
            return existing is not None

        unique_code = generate_unique_code(
            user_id,
            program_key,
            check_collision
        )

        code = code_repo.create(
            code = unique_code,
            user_id = user_id,
            program_id = program.id,
            status = ReferralCodeStatus.ACTIVE.value,
        )

        return CreateCodeResult(
            code = code.code,
            program_id = code.program_id,
            user_id = code.user_id,
            created_at = code.created_at.isoformat(),
        )

    @staticmethod
    def validate_code(db: Session, code: str) -> CodeValidation:
        """
        Validate if a code is active and usable
        """
        code_repo = ReferralCodeRepository(db)

        code_obj = code_repo.get_by_code(code)
        if not code_obj:
            raise CodeNotFoundError(
                f"Code '{code}' not found",
                code = code
            )

        if code_obj.status != ReferralCodeStatus.ACTIVE.value:
            raise CodeInactiveError(
                f"Code '{code}' is inactive (status: {code_obj.status})",
                code = code,
                status = code_obj.status,
            )

        if code_obj.expires_at and code_obj.expires_at < datetime.now(UTC
                                                                      ):
        
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `ReferralService` class in the provided code implements the **Repository Pattern**, which abstracts data access and manipulation logic into separate classes (repositories). This separation ensures that business logic remains decoupled from database interactions.

#### Implementation Details:
- The `ReferralCodeRepository`, `ReferralTrackingRepository`, and `ReferralProgramRepository` handle CRUD operations for referral codes, tracking, and programs respectively.
- Methods like `create_code`, `validate_code`, and `track_referral` interact with these repositories to perform their tasks.

#### Benefits:
1. **Decoupling:** The business logic is separated from the data access layer, making it easier to change how data is stored or retrieved without affecting the service's core functionality.
2. **Testability:** Repositories can be easily mocked for unit testing, improving test coverage and reducing dependencies on a database.

#### Deviations:
- While the pattern is well-implemented, there are no explicit interfaces or abstract classes defining repository methods, which could enhance flexibility in future implementations.
- The `ReferralService` class uses static methods, which might not be ideal if you need to instantiate it for dependency injection purposes.

#### Appropriate Use Cases:
This pattern is highly appropriate when dealing with complex data access logic and multiple types of entities (referral codes, tracking records, programs) that require different CRUD operations. It ensures a clean separation of concerns and makes the codebase more maintainable and testable.

---

*Generated by CodeWorm on 2026-03-01 12:25*
