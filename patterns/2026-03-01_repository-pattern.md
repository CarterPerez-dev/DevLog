# repository_pattern

**Type:** Pattern Analysis
**Repository:** stripe-referral
**File:** src/stripe_referral/repositories/referral_repo.py
**Language:** python
**Lines:** 1-128
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025 | CertGames.com
Referral code and tracking repositories
"""

from sqlalchemy import (
    case,
    func,
    select,
)
from sqlalchemy.orm import Session

from ..config.enums import ReferralTrackingStatus
from ..models.ReferralCode import ReferralCode
from ..models.ReferralTracking import ReferralTracking

from .base import BaseRepository


class ReferralCodeRepository(BaseRepository[ReferralCode]):
    """
    Repository for ReferralCode database operations
    """
    def __init__(self, db: Session) -> None:
        """
        Initialize with ReferralCode model
        """
        super().__init__(db, ReferralCode)

    def get_by_code(self, code: str) -> ReferralCode | None:
        """
        Get referral code by code string
        """
        stmt = select(ReferralCode).where(ReferralCode.code == code)
        return self.db.execute(stmt).scalar_one_or_none()

    def get_by_user(self,
                    user_id: str,
                    program_id: int | None = None) -> list[ReferralCode]:
        """
        Get all codes for a user optionally filtered by program
        """
        stmt = select(ReferralCode).where(ReferralCode.user_id == user_id)
        if program_id:
            stmt = stmt.where(ReferralCode.program_id == program_id)
        return list(self.db.execute(stmt).scalars().all())

    def increment_uses(self, code_id: int) -> bool:
        """
        Atomically increment uses count
        """
        code = self.get_by_id(code_id)
        if not code:
            return False

        code.uses_count += 1
        self.db.commit()
        return True


class ReferralTrackingRepository(BaseRepository[ReferralTracking]):
    """
    Repository for ReferralTracking database operations
    """
    def __init__(self, db: Session) -> None:
        """
        Initialize with ReferralTracking model
        """
        super().__init__(db, ReferralTracking)

    def get_by_referrer(self, user_id: str) -> list[ReferralTracking]:
        """
        Get all referral conversions for a referrer
        """
        stmt = select(ReferralTracking).where(
            ReferralTracking.referrer_user_id == user_id
        )
        return list(self.db.execute(stmt).scalars().all())

    def get_pending_payouts(self,
                            program_id: int | None = None
                            ) -> list[ReferralTracking]:
        """
        Get all tracking records with pending payouts
        """
        stmt = select(ReferralTracking).where(
            ReferralTracking.payout_status ==
            ReferralTrackingStatus.PENDING.value
        )
        if program_id:
            stmt = stmt.where(ReferralTracking.program_id == program_id)
        return list(self.db.execute(stmt).scalars().all())

    def get_user_earnings(self, user_id: str) -> dict[str, float]:
        """
        Calculate total earnings for a user
        """
        stmt = select(
            func.sum(ReferralTracking.amount_earned
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

**Implementation:**
The code implements a repository pattern, where `ReferralCodeRepository` and `ReferralTrackingRepository` classes encapsulate database operations for specific models (`ReferralCode` and `ReferralTracking`). Each repository class inherits from a base repository class, which provides common methods like `get_by_id`. Specific methods are defined to handle CRUD-like operations tailored to the model's requirements.

**Benefits:**
- **Encapsulation:** Operations related to each model are grouped together, making the codebase more organized and easier to maintain.
- **Testability:** Repository classes can be easily mocked or replaced with in-memory databases for unit testing.
- **Separation of Concerns:** Business logic is separated from data access logic.

**Deviations:**
- The base repository class `BaseRepository` does not follow the canonical pattern strictly, as it only provides a generic method without concrete implementations. This might lead to redundancy if more specific methods are needed in derived classes.
- Some methods like `increment_uses` use direct attribute manipulation (`code.uses_count += 1`) instead of database transactions, which could be improved for consistency.

**When Appropriate:**
This pattern is appropriate when you need to abstract data access operations and ensure that business logic remains separate from the persistence layer. It's particularly useful in applications with complex queries or multiple models requiring similar CRUD operations.

---

*Generated by CodeWorm on 2026-03-01 19:20*
