# repository_pattern

**Type:** Pattern Analysis
**Repository:** stripe-referral
**File:** src/stripe_referral/services/payout_service.py
**Language:** python
**Lines:** 1-308
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025 | CertGames.com
Payout service with business logic
"""

from typing import Any
from sqlalchemy.orm import Session

from ..adapters import (
    ManualBankAdapter,
    PayoutAdapter,
    StripeConnectAdapter,
    WiseAdapter,
)
from ..config.enums import (
    AdapterType,
    CurrencyCode,
    PayoutStatus,
    RewardType,
)
from ..exceptions.errors import (
    InvalidRecipientDataError,
    PayoutAlreadyExistsError,
    PayoutNotFoundError,
    TrackingNotFoundError,
)
from ..repositories.payout_repo import PayoutRepository
from ..repositories.program_repo import ReferralProgramRepository
from ..repositories.referral_repo import ReferralTrackingRepository
from ..schemas.types import (
    PayoutInfo,
    PayoutResult,
    ProgramInfo,
    RecipientValidation,
)


class PayoutService:
    """
    Service for payout business logic
    """
    @staticmethod
    def _get_adapter(
        adapter_type: str,
        adapter_config: dict[str,
                             Any] | None = None
    ) -> PayoutAdapter:
        """
        Factory method to get the appropriate payout adapter instance
        """
        config = adapter_config or {}

        if adapter_type == AdapterType.MANUAL.value:
            return ManualBankAdapter()
        if adapter_type == AdapterType.STRIPE_CONNECT.value:
            api_key = config.get("api_key", "")
            return StripeConnectAdapter(api_key = api_key)
        if adapter_type == AdapterType.WISE.value:
            api_token = config.get("api_token", "")
            sandbox = config.get("sandbox", False)
            return WiseAdapter(api_token = api_token, sandbox = sandbox)

        raise InvalidRecipientDataError(
            f"Unknown adapter type: {adapter_type}",
            adapter_type = adapter_type,
        )

    @staticmethod
    def create_program(
        db: Session,
        name: str,
        program_key: str,
        reward_amount: float,
        *,
        reward_currency: str = CurrencyCode.USD.value,
        reward_type: str = RewardType.ONE_TIME.value,
        adapter_type: str = AdapterType.MANUAL.value,
        max_rewards_per_user: int | None = None,
        conversion_window_days: int | None = None,
        adapter_config: dict[str,
                             Any] | None = None,
    ) -> ProgramInfo:
        """
        Create a new referral program
        """
        valid_adapter_types = [at.value for at in AdapterType]
        if adapter_type not in valid_adapter_types:
            raise InvalidRecipientDataError(
                f"Invalid adapter_type. Must be one of: {valid_adapter_types}",
                adapter_type = adapter_type,
            )

        program_repo = ReferralProgramRepository(db)

        program = program_repo.create(
            name = name,
            program_key = program_key,
            reward_amount = reward_amount,
            reward_currency = reward_currency,
            reward_type = reward_type,
            adapter_ty
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern  
**Implementation:**
The `PayoutService` class uses the repository pattern to abstract data access operations. Specifically, it interacts with three repositories (`ReferralTrackingRepository`, `PayoutRepository`, and `ReferralProgramRepository`) through static methods like `_get_adapter()` and service methods such as `create_program()`, `get_program_info()`, and `create_payout()`.

**Benefits:**
- **Encapsulation:** Repositories encapsulate data access logic, making the service layer agnostic to how data is stored.
- **Testability:** By abstracting database interactions into repositories, unit tests can mock these interfaces for more reliable testing.
- **Flexibility:** Changes in storage mechanisms (e.g., switching from SQL to NoSQL) do not require changes in the service layer.

**Deviations:**
- The `PayoutService` class includes a factory method `_get_adapter()` which is not directly related to repository operations. This introduces some deviation from the pure repository pattern.
- The service methods handle exceptions and return specific schemas, adding additional logic beyond typical repository responsibilities.

**Appropriateness:**
This pattern is appropriate in this context because it effectively separates concerns between business logic and data access. It ensures that the `PayoutService` remains focused on its core responsibilities while delegating data handling to specialized repositories. However, including a factory method for adapters might be better suited elsewhere if not directly related to repository operations.

---

*Generated by CodeWorm on 2026-03-01 11:26*
