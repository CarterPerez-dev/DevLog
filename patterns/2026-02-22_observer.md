# observer

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** frontend/ios-app/CertGamesApp/src/components/GlobalErrorHandler.js
**Language:** javascript
**Lines:** 1-168
**Complexity:** 0.0

---

## Source Code

```javascript
// src/components/GlobalErrorHandler.js
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Animated, Platform } from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { Ionicons } from '@expo/vector-icons';
import NetInfo from '@react-native-community/netinfo';
import { clearErrors, refreshAppData } from '../store/slices/networkSlice';
import { useTheme } from '../context/ThemeContext';

const GlobalErrorHandler = () => {
  const { isOffline, serverError, refreshing } = useSelector(state => state.network || {});
  const dispatch = useDispatch();
  const { theme } = useTheme();
  const [visible, setVisible] = useState(false);
  const [animValue] = useState(new Animated.Value(0));
  
  // Effect to handle visibility and auto-hide
  useEffect(() => {
    // Only show banner if we have an error condition
    const shouldShow = isOffline || serverError;
    
    if (shouldShow && !visible) {
      setVisible(true);
      // Animate banner in
      Animated.timing(animValue, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }).start();
    } else if (!shouldShow && visible) {
      // Animate banner out
      Animated.timing(animValue, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }).start(() => {
        setVisible(false);
      });
    }
  }, [isOffline, serverError, visible]);
  
  // Set up network change listener to automatically clear errors when connected
  useEffect(() => {
    // Function to handle network state changes
    const handleNetworkChange = (state) => {
      if (state.isConnected && state.isInternetReachable) {
        // Auto-clear errors when network is restored
        if (isOffline) {
          dispatch(clearErrors());
          // Attempt to refresh app data if we were previously offline
          dispatch(refreshAppData());
        }
      }
    };
    
    // Subscribe to network info updates
    const unsubscribe = NetInfo.addEventListener(handleNetworkChange);
    
    // Clean up subscription on unmount
    return () => unsubscribe();
  }, [dispatch, isOffline]);
  
  // If not visible, don't render anything
  if (!visible) return null;
  
  // Determine error text and icon
  const errorIcon = isOffline ? "cloud-offline" : "server-outline";
  const errorMessage = isOffline 
    ? "You're offline. Please check your internet connection." 
    : "Our servers are currently unavailable. We're working on it.";
  const errorColor = isOffline ? theme?.colors?.error : theme?.colors?.warning;
  
  // Handle retry - debounced to prevent multiple clicks
  const handleRetry = () => {
    if (refreshing) return; // Prevent multiple refresh attempts
    dispatch(clearErrors());
    dispatch(refreshAppData());
  };
  
  // Calculate status bar height for proper positioning
  const statusBarHeight = Platform.OS === 'ios' ? 44 : 0;
  
  return (
    <Animated.View 
      style={[
        style
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Observer

The `GlobalErrorHandler` component implements an observer pattern through its use of React's `useEffect` hooks to listen for changes in network state and update the UI accordingly.

- **Implementation**: The component subscribes to `NetInfo` events, which notify it when the network status changes. Based on these notifications, the component updates its internal state (`isOffline`, `serverError`) and triggers re-renders.
  
- **Benefits**:
  - **Decoupling**: The error handler is decoupled from the network state provider, making the code more modular and easier to maintain.
  - **Responsive UI**: The component automatically handles showing/hiding the error banner based on network changes, ensuring a responsive user experience.

- **Deviations**:
  - The observer pattern is typically implemented with explicit subject and observer classes. Here, `NetInfo` acts as the subject, while the component itself acts as an observer.
  - The use of React hooks (`useEffect`) simplifies state management compared to traditional observer implementations.

- **Appropriateness**: This pattern is suitable for scenarios where components need to react to external changes in real-time. It's particularly useful in applications with dynamic data sources, such as network status or user preferences.

This implementation effectively leverages the observer pattern to manage and respond to network state changes, enhancing both the functionality and maintainability of the application.

---

*Generated by CodeWorm on 2026-02-22 10:58*
