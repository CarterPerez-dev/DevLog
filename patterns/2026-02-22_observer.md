# observer

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** frontend/admin-app/src/lib/socket/socket.client.ts
**Language:** typescript
**Lines:** 1-243
**Complexity:** 0.0

---

## Source Code

```typescript
// ===========================
// Â©AngelaMos | 2025
// Socket.IO Client Singleton
// ===========================

import { io } from 'socket.io-client';
import type { Socket } from 'socket.io-client';
import type {
  SocketEventMap,
  SocketEmitEvents,
  SocketConnectionState,
} from './socket.types';

type TypedSocket = Socket<SocketEventMap, SocketEmitEvents>;

type ConnectionEventHandler = (data: unknown) => void;

class SocketClient {
  private static instance: SocketClient | null = null;
  private socket: TypedSocket | null = null;
  private connectionState: SocketConnectionState = 'disconnected';
  private reconnectAttempts = 0;
  private readonly maxReconnectAttempts: number = 5;
  private readonly reconnectDelay: number = 1000;
  private listeners = new Map<string, Set<ConnectionEventHandler>>();

  // eslint-disable-next-line @typescript-eslint/no-empty-function
  private constructor() {}

  public static getInstance(): SocketClient {
    SocketClient.instance ??= new SocketClient();
    return SocketClient.instance;
  }

  public connect(token?: string): TypedSocket {
    const socketConnected = this.socket?.connected;
    if (
      socketConnected !== null &&
      socketConnected !== undefined &&
      socketConnected &&
      this.socket !== null
    ) {
      return this.socket;
    }

    const socketOptions = {
      path: '/api/socket.io/',
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: this.reconnectDelay,
      reconnectionDelayMax: 10000,
      timeout: 20000,
      autoConnect: true,
      ...(token !== null &&
        token !== undefined && {
          auth: { token },
        }),
    };

    this.socket = io('/', socketOptions) as TypedSocket;
    this.setupEventHandlers();

    return this.socket;
  }

  private setupEventHandlers(): void {
    if (this.socket === null) return;

    this.socket.on('connect', (): void => {
      this.connectionState = 'connected';
      this.reconnectAttempts = 0;
      console.warn('[Socket.IO] Connected to server');
      this.notifyListeners('connection_changed', this.connectionState);
    });

    this.socket.on('disconnect', (): void => {
      this.connectionState = 'disconnected';
      console.warn('[Socket.IO] Disconnected from server');
      this.notifyListeners('connection_changed', this.connectionState);
    });

    this.socket.on('connect_error', (error: Error): void => {
      this.connectionState = 'error';
      this.reconnectAttempts += 1;
      console.error('[Socket.IO] Connection error:', error.message);
      this.notifyListeners('connection_error', error);

      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        console.error('[Socket.IO] Max reconnection attempts reached');
        this.disconnect();
      }
    });
  }

  public disconnect(): void {
    if (this.socket !== null) {
      this.socket.disconnect();
      this.socket = null;
      th
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Observer

The `SocketClient` class implements an observer pattern by managing a map of event listeners (`listeners`) that are notified when socket events occur, such as 'connect', 'disconnect', and 'connect_error'. This is evident from the `notifyListeners` method which calls handlers based on specific events.

**Benefits:**
- **Decoupling:** The `SocketClient` class does not need to know who or how many listeners are registered for each event. Listeners can be added, removed, or updated independently of the socket connection logic.
- **Reusability:** This pattern allows multiple components to register and unregister listeners without modifying the core socket handling code.

**Deviations:**
- The `notifyListeners` method is not explicitly defined in the class, but it's implied by the usage within event handlers. It would be clearer if this method were implemented.
- The use of TypeScript generics (`K extends keyof SocketEventMap`) ensures type safety for event names and handler functions.

**Appropriateness:**
This pattern is highly appropriate when dealing with real-time communication where multiple components need to react to socket events independently. It provides a clean separation between the event source (socket) and the observers (listeners), making the code more modular and maintainable. However, it might be overkill for simple applications or scenarios where direct event handling without an intermediate layer is sufficient.

---

*Generated by CodeWorm on 2026-02-22 08:24*
