# observer

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** frontend/user-app/src/core/lib/socket/socket.client.ts
**Language:** typescript
**Lines:** 1-259
**Complexity:** 0.0

---

## Source Code

```typescript
// ===========================
// Socket.IO Client Singleton
// Â©AngelaMos | 2025
// ===========================

import { io } from 'socket.io-client';
import type { Socket } from 'socket.io-client';
import { TokenStorage } from '@/core/lib/storage/secure';
import type {
  SocketEventMap,
  SocketEmitEvents,
  SocketConnectionState,
} from './socket.types';

type TypedSocket = Socket<SocketEventMap, SocketEmitEvents>;

type ConnectionEventHandler = (data: unknown) => void;

class SocketClient {
  private static instance: SocketClient | null = null;
  private socket: TypedSocket | null = null;
  private connectionState: SocketConnectionState = 'disconnected';
  private reconnectAttempts = 0;
  private readonly maxReconnectAttempts: number = 5;
  private readonly reconnectDelay: number = 1000;
  private listeners = new Map<string, Set<ConnectionEventHandler>>();

  // eslint-disable-next-line @typescript-eslint/no-empty-function
  private constructor() {}

  public static getInstance(): SocketClient {
    SocketClient.instance ??= new SocketClient();
    return SocketClient.instance;
  }

  public connect(): TypedSocket {
    const socketConnected = this.socket?.connected;
    if (
      socketConnected !== null &&
      socketConnected !== undefined &&
      socketConnected &&
      this.socket !== null
    ) {
      return this.socket;
    }

    const token = TokenStorage.getAccessToken();
    const userId = TokenStorage.getUserId();

    const socketOptions = {
      path: '/api/socket.io/',
      transports: ['websocket', 'polling'] as ('websocket' | 'polling')[],
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: this.reconnectDelay,
      reconnectionDelayMax: 10000,
      timeout: 20000,
      autoConnect: true,
      ...(token !== null &&
        token !== undefined && {
          auth: { token },
          ...(userId !== null &&
            userId !== undefined && {
              extraHeaders: {
                'X-User-Id': userId,
              },
            }),
        }),
    };

    this.socket = io('/', socketOptions) as TypedSocket;
    this.setupEventHandlers();

    return this.socket;
  }

  private setupEventHandlers(): void {
    if (this.socket === null) return;

    this.socket.on('connect', (): void => {
      this.connectionState = 'connected';
      this.reconnectAttempts = 0;
      console.warn('[Socket.IO] Connected to server');
      this.notifyListeners('connection_changed', this.connectionState);
    });

    this.socket.on('disconnect', (): void => {
      this.connectionState = 'disconnected';
      console.warn('[Socket.IO] Disconnected from server');
      this.notifyListeners('connection_changed', this.connectionState);
    });

    this.socket.on('connect_error', (error: Error): void => {
      this.connectionState = 'error';
      this.reconnectAttempts += 1;
      console.error('[Socket.IO] Connection error:', error.message);
      this.notifyListeners('
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** **Observer**

The `SocketClient` class implements the Observer design pattern by maintaining a map of event listeners (`listeners`) that get notified when socket events occur (e.g., connection, disconnect, error). The `setupEventHandlers` method sets up these handlers to update the state and notify listeners.

**Benefits:**
- **Decoupling:** Listeners are decoupled from the socket implementation, making it easier to manage event handling.
- **Flexibility:** Allows for easy addition or removal of event listeners without modifying the core logic.

**Deviations:**
- The `SocketClient` uses a singleton pattern (`getInstance`) to ensure only one instance exists. This is not strictly part of the Observer pattern but helps in managing shared state and resources.
- The implementation uses TypeScript types extensively, ensuring type safety for events and handlers.

**Appropriateness:**
This pattern is appropriate when dealing with event-driven systems like web sockets, where multiple components need to react to changes in the system's state. It ensures that all interested parties are notified of significant events without tightly coupling them, making the code more modular and maintainable.

---

*Generated by CodeWorm on 2026-02-22 10:56*
