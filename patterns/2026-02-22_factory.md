# factory

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/progression/qa/conftest.py
**Language:** python
**Lines:** 1-126
**Complexity:** 0.0

---

## Source Code

```python
"""
Progression Domain Test Configuration
/api/domains/progression/qa/conftest.py
"""

import pytest
from qa.conftest import (
    app,
    client,
    db,
    redis_client,
    audit_capture,
    api_client,
    valid_object_id,
    flask_g,
)
from qa.super_global.fixtures.database import (
    db_state_manager,
    isolated_db_test,
    seeded_db_test,
    db_transaction_test,
    db_performance_monitor,
)

from qa.super_global.fixtures.factories import (
    user_factory,
    achievement_factory,
    shop_item_factory,
)

from qa.super_global.fixtures.test_data import (
    test_emails,
    test_passwords,
    test_usernames,
    test_achievements,
    test_shop_items,
    test_dates,
)
from qa.account_qa.fixtures.factories import (
    comprehensive_user_factory,
    user_relationship_factory,
)

from qa.account_qa.fixtures.auth import (
    enhanced_auth_headers,
    auth_context,
    auth_scenario_factory,
)

from qa.account_qa.fixtures.test_data import (
    account_registration_data,
    account_login_data,
)


@pytest.fixture
def progression_test_setup(db_state_manager, comprehensive_user_factory):
    """
    Progression Test Setup Helper
    """
    class ProgressionTestSetup:
        def __init__(self, db_manager, user_factory):
            self.db_manager = db_manager
            self.user_factory = user_factory

        def ensure_clean_db(self) -> bool:
            """
            Ensure database is clean for testing
            """
            return self.db_manager.ensure_clean()

        def create_test_user_with_progression(self, **kwargs):
            """
            Create a test user with progression data
            """
            user = self.user_factory(**kwargs)
            self.verify_user_persisted(user)
            return user

        def verify_user_persisted(self, user):
            """
            Verify user was properly persisted with progression fields
            """
            self.db_manager.verify_persistence(
                user,
                [
                    'username',
                    'email',
                    'level',
                    'xp',
                    'coins',
                    'achievements'
                ]
            )

        def get_collection_stats(self):
            """
            Get current database collection statistics
            """
            return self.db_manager.get_collection_stats()

    return ProgressionTestSetup(
        db_state_manager,
        comprehensive_user_factory
    )


__all__ = [
    # Root fixtures
    'app', 'client', 'db', 'redis_client', 'audit_capture', 'api_client',
    'valid_object_id', 'flask_g',
    # Database fixtures
    'db_state_manager', 'isolated_db_test', 'seeded_db_test',
    'db_transaction_test', 'db_performance_monitor',
    # Super global factories and data
    'user_factory', 'achievement_factory', 'shop_item_factory',
    'test_emails', 'test_passwords', 'test_usernames', 'test_achievements',
    'test_shop_i
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory

The `progression_test_setup` fixture in the provided code implements a factory design pattern. It encapsulates the creation logic for test setups, ensuring that specific conditions are met before tests run.

#### Implementation:
- **Class Definition**: The `ProgressionTestSetup` class is defined within the fixture.
- **Initialization**: The class takes `db_state_manager` and `comprehensive_user_factory` as parameters in its constructor.
- **Methods**:
  - `ensure_clean_db`: Ensures the database is clean for testing.
  - `create_test_user_with_progression`: Creates a test user with progression data.
  - `verify_user_persisted`: Verifies that the created user has persisted with expected fields.

#### Benefits:
1. **Encapsulation**: The factory encapsulates complex setup logic, making it easier to manage and extend.
2. **Reusability**: The same setup can be reused across multiple tests without duplicating code.
3. **Test Isolation**: Ensures that each test starts in a clean state by ensuring the database is cleaned before running.

#### Deviations:
- The factory is implemented as a class rather than a simple function, which adds some complexity but also provides more flexibility for managing state and behavior.
- The `__all__` list includes this fixture, making it easily accessible to other test modules.

#### Appropriateness:
This pattern is highly appropriate in scenarios where complex setup logic needs to be encapsulated. It ensures that tests are isolated and can be run independently without affecting each other's state. However, for simpler setups, a function-based factory might suffice.

---

*Generated by CodeWorm on 2026-02-22 22:50*
