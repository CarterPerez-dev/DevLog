# repository_pattern

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/auth/services/user.py
**Language:** python
**Lines:** 1-220
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
user.py
"""

from uuid import UUID
from sqlalchemy.ext.asyncio import (
    AsyncSession,
)

from core.exceptions import (
    EmailAlreadyExists,
    InvalidCredentials,
    UserNotFound,
)
from core.security.auth.jwt import (
    hash_password,
    verify_password,
)
from aspects.auth.schemas.user import (
    AdminUserCreate,
    UserCreate,
    UserListResponse,
    UserResponse,
    UserUpdate,
    UserUpdateAdmin,
)
from aspects.auth.models.User import User
from aspects.auth.repositories.user import UserRepository


class UserService:
    """
    Business logic for user operations
    """
    @staticmethod
    async def create_user(
        session: AsyncSession,
        user_data: UserCreate,
    ) -> UserResponse:
        """
        Register a new user
        """
        if await UserRepository.email_exists(session, user_data.email):
            raise EmailAlreadyExists(user_data.email)

        hashed = await hash_password(user_data.password)
        user = await UserRepository.create_user(
            session,
            email = user_data.email,
            hashed_password = hashed,
            full_name = user_data.full_name,
        )
        return UserResponse.model_validate(user)

    @staticmethod
    async def get_user_by_id(
        session: AsyncSession,
        user_id: UUID,
    ) -> UserResponse:
        """
        Get user by ID
        """
        user = await UserRepository.get_by_id(session, user_id)
        if not user:
            raise UserNotFound(str(user_id))
        return UserResponse.model_validate(user)

    @staticmethod
    async def get_user_model_by_id(
        session: AsyncSession,
        user_id: UUID,
    ) -> User:
        """
        Get user model by ID (for internal use)
        """
        user = await UserRepository.get_by_id(session, user_id)
        if not user:
            raise UserNotFound(str(user_id))
        return user

    @staticmethod
    async def update_user(
        session: AsyncSession,
        user: User,
        user_data: UserUpdate,
    ) -> UserResponse:
        """
        Update user profile
        """
        update_dict = user_data.model_dump(exclude_unset = True)
        updated_user = await UserRepository.update(
            session,
            user,
            **update_dict
        )
        return UserResponse.model_validate(updated_user)

    @staticmethod
    async def change_password(
        session: AsyncSession,
        user: User,
        current_password: str,
        new_password: str,
    ) -> None:
        """
        Change user password
        """
        is_valid, _ = await verify_password(current_password, user.hashed_password)
        if not is_valid:
            raise InvalidCredentials()

        hashed = await hash_password(new_password)
        await UserRepository.update_password(session, user, hashed)

    @staticmethod
    async def deactivate_user(
        session: AsyncSession,
        user: User,
    ) -> UserRe
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

#### Implementation
The `UserService` class in the provided code implements the **Repository Pattern** by encapsulating data access logic within the `UserRepository`. The methods like `create_user`, `get_user_by_id`, and others delegate to `UserRepository` for database operations. For example, the `create_user` method checks if an email already exists using `await UserRepository.email_exists(session, user_data.email)`.

#### Benefits
- **Decoupling:** The service layer is decoupled from the data access logic, making it easier to change or replace the underlying storage mechanism.
- **Testability:** Repository methods can be easily mocked for unit testing, isolating business logic from database interactions.
- **Consistency:** Ensures that all data access operations follow a consistent pattern and interface.

#### Deviations
- The `UserService` class is static, which might not align with the typical implementation of the repository pattern where services are usually instantiated objects. However, this could be due to specific design choices or constraints in the application.
- The methods like `get_user_model_by_id` return a raw `User` model instead of a `UserResponse`, which might require additional handling.

#### Appropriate Use Cases
This pattern is appropriate when:
- You need to abstract data access logic from business logic.
- Your application requires multiple data sources or storage mechanisms, and you want to maintain consistency in how these are accessed.
- Testing needs to be isolated from database interactions.

---

*Generated by CodeWorm on 2026-02-24 08:43*
