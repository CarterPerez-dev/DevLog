# repository_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/account/services/auth.py
**Language:** python
**Lines:** 1-336
**Complexity:** 0.0

---

## Source Code

```python
"""
Auth Service - Auth, password reset, and temp registration operations
/api/domains/account/services/auth.py
"""

import bcrypt
import mongoengine
from flask import current_app
from datetime import (
    UTC,
    datetime,
    timedelta,
)

from settings import Security
from api.core.services.logging import AuditLogger
from api.domains.shop.services.catalog_ops import CatalogService

from ..models.User import User
from ..models.PasswordReset import PasswordReset
from ..models.TempRegistration import TempRegistration

from ..middleware.schemas import username_validator


class AuthService:
    """
    Service class for authentication operations
    """
    @staticmethod
    def find_user_by_id(user_id: str) -> User | None:
        """
        Find user by ID
        """
        return User.objects(id = user_id).first()

    @staticmethod
    def find_user_by_email(email: str) -> User | None:
        """
        Find user by email (case-insensitive)
        """
        if not email:
            return None
        return User.objects(email = email.lower()).first()

    @staticmethod
    def find_user_by_username(username: str) -> User | None:
        """
        Find user by username (case-sensitive)
        """
        if not username:
            return None
        return User.objects(username = username).first()

    @staticmethod
    def find_user_by_identifier(identifier: str) -> User | None:
        """
        Find user by email or username for login
        """
        if not identifier:
            return None
        user: User | None = User.objects(username = identifier).first()
        if not user:
            user = User.objects(email = identifier.lower()).first()
        return user

    @staticmethod
    def hash_password(password: str) -> str:
        """
        Hash a password using bcrypt
        """
        password_bytes: bytes = password.encode("utf-8")
        salt: bytes = bcrypt.gensalt()
        hashed_bytes: bytes = bcrypt.hashpw(password_bytes, salt)
        return hashed_bytes.decode("utf-8")

    @staticmethod
    def create_user(
        username: str,
        email: str,
        password: str,
        **extra_fields
    ) -> User | None:
        """
        Create a new user with validation
        """
        try:
            if not username or not email or not password:
                return None

            validated_username = username_validator(username)
            hashed_password: str = AuthService.hash_password(password)
            normalized_email: str = email.lower()

            new_user: User = User(
                username = validated_username,
                email = normalized_email,
                password = hashed_password,
                **extra_fields
            )
            new_user.save()

            AuditLogger.log_action(
                "user_created",
                user_id = str(new_user.id),
                data = {
                    "username": username,
                   
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used: Repository Pattern**

The `AuthService` class in the provided code implements a form of the **Repository Pattern**, which encapsulates data access logic and abstracts it away from the business logic. This is evident through methods like `find_user_by_id`, `find_user_by_email`, and `create_user`.

- **Implementation**: The `AuthService` contains static methods for interacting with the database, such as finding users by ID or email, hashing passwords, and creating new users.
- **Benefits**:
  - **Decoupling**: It decouples business logic from data access, making it easier to switch between different storage mechanisms (e.g., MongoDB).
  - **Testability**: By abstracting the database interaction, unit tests can focus on business logic rather than database operations.
  - **Consistency**: Ensures consistent handling of user data across various methods.

**Deviations from Standard Pattern**:
- The pattern is not strictly followed in a separate repository class. Instead, it's embedded within `AuthService`. This could make the service harder to test and maintain if it grows larger.
- Some methods like `hash_password` and `check_username_exists` are utility functions rather than data access operations.

**Appropriateness**:
This pattern is appropriate for this context because it encapsulates database interactions, making the code more modular and easier to manage. However, for a more complex application, it might be beneficial to separate these concerns into dedicated repository classes or services.

---

*Generated by CodeWorm on 2026-02-22 23:55*
