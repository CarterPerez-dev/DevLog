# decorator_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/core/decorators/cache.py
**Language:** python
**Lines:** 1-194
**Complexity:** 0.0

---

## Source Code

```python
"""
Caching decorators for route optimization
/api/core/lib/cache.py
"""

import os
import time
import redis
import json
import logging
from settings import Cache, Redis
from functools import wraps
from flask import current_app
from collections.abc import Callable
from typing import Any, TypeVar, cast


logger = logging.getLogger(__name__)

cache_storage: dict[str, Any] = {}
cache_timestamps: dict[str, float] = {}

_redis_conn: redis.StrictRedis | None = None

T = TypeVar("T")


def get_redis_connection() -> redis.StrictRedis | None:
    """
    Get Redis connection using Flask app's shared Redis client
    """
    try:
        return current_app.extensions.get("redis_client")
    except Exception:
        global _redis_conn
        if _redis_conn is None and redis:
            try:
                REDIS_PASSWORD: str | None = os.getenv("REDIS_PASSWORD")
                _redis_conn = redis.StrictRedis(
                    host = Redis.DEFAULT_HOST,
                    port = Redis.DEFAULT_PORT,
                    db = Redis.DEFAULT_DB,
                    password = REDIS_PASSWORD,
                    decode_responses = True,
                    socket_connect_timeout = Redis.SOCKET_CONNECT_TIMEOUT,
                    socket_timeout = Redis.SOCKET_TIMEOUT
                )
                _redis_conn.ping()
            except Exception:
                _redis_conn = None
        return _redis_conn


def redis_cache_set(
    key: str,
    value: Any,
    ttl: int = Redis.DEFAULT_CACHE_TTL_SECONDS
) -> None:
    """
    Set value in Redis cache with TTL
    """
    conn: redis.StrictRedis | None = get_redis_connection()
    if conn:
        try:
            serialized: str = json.dumps(value, default = str)
            conn.setex(key, ttl, serialized)
        except Exception as e:
            logger.warning("Failed to set cache for key %s: %s", key, e)


def redis_cache_get(key: str) -> Any:
    """
    Get value from Redis cache
    """
    conn: redis.StrictRedis | None = get_redis_connection()
    if conn:
        try:
            data: bytes | None = conn.get(key)
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            logger.warning("Failed to get cache for key %s: %s", key, e)
            return None
    return None


def cached_route(
    cache_duration_seconds: int = Cache.
    DEFAULT_ROUTE_CACHE_DURATION_SECONDS,
) -> Callable[[Callable[...,
                        T]],
              Callable[...,
                       T]]:
    """
    Decorator to cache route responses
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> T:
            cache_key: str = f"{func.__name__}_{str(args)}_{str(sorted(kwargs.items()))}"

            now: float = time.time()

            if (cache_key in cache_storage
                    and cache_key in cache_timestamps and now -
                    
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

**Implementation:**
The decorator pattern is implemented through the `cached_route` function, which wraps a route handler with caching logic. This function returns another decorator that caches the result of the decorated function based on a unique cache key derived from the function's arguments and name.

```python
def cached_route(
    cache_duration_seconds: int = Cache.DEFAULT_ROUTE_CACHE_DURATION_SECONDS,
) -> Callable[[Callable[..., T]], Callable[..., T]]:
    ...
```

**Benefits:**
- **Decoupling:** The caching logic is decoupled from the route handler, making it easier to manage and modify.
- **Performance Optimization:** Caching reduces the number of database queries or API calls by storing results in memory or Redis.

**Deviations:**
- The `cached_route` decorator uses a dictionary (`cache_storage`) for local caching, whereas typical implementations might use a more robust cache system like Redis directly.
- There is no explicit expiration handling within the local cache; it relies on Redis TTL.

**Appropriateness:**
This pattern is appropriate when you need to cache route responses to improve performance and reduce database load. It's especially useful in web applications where certain routes are frequently accessed with similar parameters. However, for more complex caching scenarios requiring distributed caching or fine-grained control, a dedicated caching library like Redis might be more suitable.

---

*Generated by CodeWorm on 2026-02-21 20:43*
