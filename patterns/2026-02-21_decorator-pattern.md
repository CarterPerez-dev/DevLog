# decorator_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/core/auth/auth_optional.py
**Language:** python
**Lines:** 1-56
**Complexity:** 0.0

---

## Source Code

```python
"""
Optional authentication decorator: FUTURE USE
/api/core/auth/auth_optional.py
"""

from typing import Any
from functools import wraps
from collections.abc import Callable
from flask import g, request, session
from flask_jwt_extended import (
    get_jwt_identity,
    verify_jwt_in_request,
)
from api.domains.account.models.User import User


def auth_optional(fn: Callable[..., Any]) -> Callable[..., Any]:
    """
    Decorator that allows optional authentication.
    """
    @wraps(fn)
    def wrapper(*args: Any, **kwargs: Any) -> Any:

        user_id: str | None = None
        try:
            verify_jwt_in_request(optional = True)
            user_id = get_jwt_identity()
            if user_id:
                pass
            else:
                user_id = None
        except Exception:
            user_id = None

        if not user_id:
            user_id = session.get("userId")

        if not user_id:
            user_id = request.headers.get("X-User-Id")

        g.user_id = None
        g.user = None

        if user_id:
            try:
                user: User | None = User.objects(id = user_id).first()
                if user:
                    g.user_id = user_id
                    g.user = user
            except Exception:
                pass  # nosec B110

        return fn(*args, **kwargs)

    return wrapper

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

The `auth_optional` decorator is implemented to optionally authenticate users based on JWT or session headers. Here’s a breakdown:

1. **Implementation:**
   - The function `auth_optional` takes a callable `fn` and returns another callable.
   - It uses the `verify_jwt_in_request` method from Flask-JWT-Extended with the `optional=True` parameter to allow for optional authentication.
   - If no JWT is present, it checks session data or headers for a user ID.

2. **Benefits:**
   - Flexibility in handling authenticated and unauthenticated requests.
   - Centralized authentication logic that can be easily applied to any function requiring optional authentication.
   - Improved code readability by abstracting the authentication process.

3. **Deviations from Standard Pattern:**
   - The decorator does not modify or wrap the original function's behavior directly but rather sets up global context (`g.user_id` and `g.user`) which can be used within the decorated function.
   - It handles exceptions by setting `user_id` to `None`, which is a deviation from typical pattern where such errors might raise an exception.

4. **Appropriateness:**
   - This pattern is appropriate when you need to handle both authenticated and unauthenticated requests in a consistent manner, especially in APIs that support JWT tokens but also allow for other authentication methods.
   - It’s useful in scenarios where the presence of a user ID is not mandatory for all operations.

This decorator ensures that the code remains clean and focused on its primary logic while abstracting away the complexities of handling different authentication mechanisms.

---

*Generated by CodeWorm on 2026-02-21 14:25*
