# decorator_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/core/decorators/schema.py
**Language:** python
**Lines:** 1-98
**Complexity:** 0.0

---

## Source Code

```python
"""
Schema Validation Decorator
/api/middleware/decorators/schema.py
"""

import json
import logging
import contextlib
from typing import Any
from functools import wraps
from flask import request, g
from collections.abc import Callable
from pydantic import BaseModel, ValidationError
from werkzeug.exceptions import (
    UnsupportedMediaType,
    BadRequest,
)


logger = logging.getLogger(__name__)


def schema(
    model: type[BaseModel]
) -> Callable[[Callable[...,
                        Any]],
              Callable[...,
                       Any]]:
    """
    Pydantic schema validation decorator.
    """
    def decorator(f: Callable[..., Any]) -> Callable[..., Any]:
        @wraps(f)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            try:
                data = None
                content_type = request.content_type or ""

                if content_type.startswith('application/json'):
                    data = request.get_json()
                elif content_type.startswith(
                    ('application/x-www-form-urlencoded',
                     'multipart/form-data')):
                    data = {}
                    for key, value in request.form.items():
                        try:
                            data[key] = json.loads(value
                                                   ) if value.startswith(
                                                       ('{',
                                                        '[')
                                                   ) else value
                        except (json.JSONDecodeError, ValueError):
                            data[key] = value
                else:
                    with contextlib.suppress(UnsupportedMediaType):
                        data = request.get_json(silent = True)

                    if not data and request.form:
                        data = dict(request.form)
                    elif not data:
                        data = dict(request.args)

                if data is None:
                    data = {}

                validated_data: BaseModel = model(**data)

                g.validated = validated_data.model_dump()
                g.validated_model = validated_data

            except ValidationError as e:
                errors: dict[str, str] = {}
                for error in e.errors():
                    field: str = ".".join(str(x) for x in error["loc"])
                    errors[field] = error["msg"]

                return {"error": "Validation failed", "errors": errors}, 400
            except Exception as e:
                if isinstance(e, UnsupportedMediaType):
                    return {
                        "error": "Invalid content type",
                        "message": "Content-Type must be application/json"
                    }, 400
                if isinstance(e, BadRequest):
                    return {"error": "Invalid JSON", "message": "Request body must be valid JSON"}, 400

    
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

The `schema` decorator function in the provided code implements the **Decorator Pattern** to validate incoming request data using Pydantic models. The core implementation involves a higher-order function that takes a model class as an argument and returns another function (decorator) which wraps the original function (`f`). This wrapper function handles JSON parsing, form data processing, and validation against the provided Pydantic model.

**Benefits:**
- **Modularity:** Decorators allow for clean separation of concerns by encapsulating cross-cutting concerns like validation.
- **Reusability:** The `schema` decorator can be applied to multiple functions without duplicating code.
- **Flexibility:** Easily switch or extend the validation logic by modifying the decorator.

**Deviations:**
- The implementation includes custom error handling for specific HTTP errors (`UnsupportedMediaType`, `BadRequest`), which is not a strict deviation but adds context-specific behavior.
- The use of `contextlib.suppress` to handle `UnsupportedMediaType` exceptions without raising them immediately, allowing the validation process to continue.

**Appropriateness:**
This pattern is highly appropriate for web APIs where request data needs to be validated before processing. It ensures that all endpoints adhere to a consistent validation mechanism, improving code maintainability and reducing boilerplate code. However, it might not be suitable for scenarios requiring complex or dynamic validation logic that cannot be encapsulated in a simple decorator.

---

*Generated by CodeWorm on 2026-02-21 16:18*
