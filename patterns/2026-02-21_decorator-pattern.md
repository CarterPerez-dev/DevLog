# decorator_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/core/auth/subscription_required.py
**Language:** python
**Lines:** 1-103
**Complexity:** 0.0

---

## Source Code

```python
"""
Requires both auth & active subscription
/api/core/auth/subscription_required.py
"""

from typing import Any
from functools import wraps
from collections.abc import Callable
from flask import g, request, session
from flask_jwt_extended import (
    get_jwt,
    get_jwt_identity,
    verify_jwt_in_request,
)
from api.domains.account.models.User import User
from .user_cache import get_cached_user, cache_user


def subscription_required(fn: Callable[..., Any]) -> Callable[..., Any]:
    """
    Decorator that requires valid authentication AND active subscription.
    """
    @wraps(fn)
    def wrapper(*args: Any, **kwargs: Any) -> Any | tuple[dict, int]:

        user_id: str | None = None
        try:
            verify_jwt_in_request(optional = True)
            user_id = get_jwt_identity()
            if user_id:
                pass
            else:
                user_id = None
        except Exception:
            user_id = None

        if not user_id:
            user_id = session.get("userId")

        if not user_id:
            user_id = request.headers.get("X-User-Id")

        if not user_id:
            return {
                "error": "Authentication required",
                "status": "unauthenticated",
                "message": "Please log in to access premium features",
            }, 401

        try:
            user: User | None = get_cached_user(user_id)

            if not user:
                user = User.objects(id = user_id).first()
                if user:
                    cache_user(user)
                else:
                    return {
                        "error": "Invalid user",
                        "status": "unauthenticated",
                        "message": "User account not found",
                    }, 401
        except Exception:
            return {
                "error": "Authentication error",
                "status": "unauthenticated",
                "message": "Failed to verify user account",
            }, 401

        subscription_active: bool = False

        try:
            jwt_data: dict[str, Any] = get_jwt()
            if jwt_data:
                subscription_active = jwt_data.get(
                    "subscriptionActive",
                    False
                )
                if subscription_active:
                    g.user_id = user_id
                    g.user = user
                    return fn(*args, **kwargs)
        except Exception:  # nosec B110
            pass

        subscription_active = getattr(user, "subscriptionActive", False)
        subscription_type: str = getattr(user, "subscriptionType", "free")

        if not subscription_active or subscription_type == "free":
            return {
                "error": "Premium subscription required",
                "status": "subscription_required",
                "message": "This feature requires an active premium subscription",
                "upgrade_url": "/subscription",
            }, 403

   
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

The `subscription_required` decorator ensures that a user must be authenticated and have an active subscription to access certain API endpoints. It is implemented using Python's `functools.wraps` to preserve the function metadata of the decorated functions.

**Benefits:**
- **Modularity**: The decorator encapsulates the logic for authentication and subscription validation, making it reusable across multiple endpoints.
- **Maintainability**: Centralizing the authentication and authorization checks makes it easier to update or modify these rules without changing each endpoint's implementation.
- **Readability**: By using a decorator, the main function bodies remain clean and focused on their core responsibilities.

**Deviations:**
- The `verify_jwt_in_request` call is made with `optional=True`, which is not typical for this pattern. Usually, it would be used to ensure that a valid JWT is present.
- The use of `try-except` blocks around critical operations like fetching the user and checking subscription status can lead to potential issues if exceptions are not handled properly.

**Appropriateness:**
This pattern is highly appropriate in scenarios where you need to enforce complex access control rules across multiple functions or endpoints. It ensures that the core functionality of each endpoint remains clean while maintaining robust security checks. However, it might be overkill for simpler use cases and could benefit from more precise exception handling.

---

*Generated by CodeWorm on 2026-02-21 13:25*
