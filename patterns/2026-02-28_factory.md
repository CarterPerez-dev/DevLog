# factory

**Type:** Pattern Analysis
**Repository:** my-portfolio
**File:** v1/backend/app/core/database.py
**Language:** python
**Lines:** 1-160
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
database.py
"""

import contextlib
from collections.abc import (
    AsyncIterator,
    Iterator,
)

from sqlalchemy import create_engine
from sqlalchemy.engine import Engine
from sqlalchemy.engine.url import make_url
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    AsyncConnection,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import Session, sessionmaker

from config import settings


class DatabaseSessionManager:
    """
    Manages database connections and sessions for both sync and async contexts
    """
    def __init__(self) -> None:
        self._async_engine: AsyncEngine | None = None
        self._sync_engine: Engine | None = None
        self._async_sessionmaker: async_sessionmaker[AsyncSession] | None = None
        self._sync_sessionmaker: sessionmaker[Session] | None = None

    def init(self, database_url: str) -> None:
        """
        Initialize database engines and session factories
        """
        base_url = make_url(database_url)

        async_url = base_url.set(drivername = "postgresql+asyncpg")
        self._async_engine = create_async_engine(
            async_url,
            pool_size = settings.DB_POOL_SIZE,
            max_overflow = settings.DB_MAX_OVERFLOW,
            pool_timeout = settings.DB_POOL_TIMEOUT,
            pool_recycle = settings.DB_POOL_RECYCLE,
            pool_pre_ping = True,
            echo = settings.DEBUG,
        )
        self._async_sessionmaker = async_sessionmaker(
            bind = self._async_engine,
            class_ = AsyncSession,
            autocommit = False,
            autoflush = False,
            expire_on_commit = False,
        )

        sync_url = base_url.set(drivername = "postgresql+psycopg2")
        self._sync_engine = create_engine(
            sync_url,
            pool_size = settings.DB_POOL_SIZE,
            max_overflow = settings.DB_MAX_OVERFLOW,
            pool_timeout = settings.DB_POOL_TIMEOUT,
            pool_recycle = settings.DB_POOL_RECYCLE,
            pool_pre_ping = True,
            echo = settings.DEBUG,
        )
        self._sync_sessionmaker = sessionmaker(
            bind = self._sync_engine,
            autocommit = False,
            autoflush = False,
            expire_on_commit = False,
        )

    async def close(self) -> None:
        """
        Dispose of all database connections
        """
        if self._async_engine:
            await self._async_engine.dispose()
            self._async_engine = None
            self._async_sessionmaker = None

        if self._sync_engine:
            self._sync_engine.dispose()
            self._sync_engine = None
            self._sync_sessionmaker = None

    @contextlib.asynccontextmanager
    async def session(self) -> AsyncIterator[AsyncSession]:
        """
        Async context manager for database sessions

        Handles commit on success, rollback on exception
        """
        if self._async_ses
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `DatabaseSessionManager` class implements a **Factory Method** pattern, where it provides methods to initialize database engines and session factories for both synchronous and asynchronous contexts.

- **Implementation**: The `init` method initializes the database engines (`_async_engine`, `_sync_engine`) and their corresponding session makers (`_async_sessionmaker`, `_sync_sessionmaker`). These are created using `create_async_engine` and `sessionmaker` from SQLAlchemy.
  
- **Benefits**:
  - **Flexibility**: Allows for easy configuration of different database drivers (e.g., `postgresql+asyncpg` vs. `postgresql+psycopg2`).
  - **Reusability**: The same factory methods can be used to create multiple sessions or connections, promoting code reuse.
  
- **Deviations**:
  - The pattern is extended with context managers (`session`, `connect`) that handle session and connection lifecycle management, which deviates slightly from the canonical Factory Method implementation.
  - The `sync_engine` property directly returns an engine instance without using a factory method.

- **Appropriateness**:
  - This pattern is appropriate in scenarios where multiple database configurations or contexts (e.g., async vs. sync) are needed and require flexible initialization and management of sessions/connections.

This implementation effectively manages the complexity of initializing and disposing of database connections, making it easier to maintain and scale the application.

---

*Generated by CodeWorm on 2026-02-28 01:54*
