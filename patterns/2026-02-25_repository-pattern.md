# repository_pattern

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/planner/service.py
**Language:** python
**Lines:** 1-103
**Complexity:** 0.0

---

## Source Code

```python
"""
ⒸAngelaMos | 2026
service.py
"""

from datetime import date
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from core.exceptions import ResourceNotFound
from aspects.life_manager.facets.planner.repository import TimeBlockRepository
from aspects.life_manager.facets.planner.schemas import (
    TimeBlockCreate,
    TimeBlockUpdate,
    TimeBlockResponse,
    TimeBlockListResponse,
)


class TimeBlockNotFound(ResourceNotFound):
    """
    Raised when time block not found
    """
    def __init__(self, block_id: UUID) -> None:
        super().__init__(
            resource = "TimeBlock",
            identifier = str(block_id)
        )


class PlannerService:
    """
    Service for planner operations
    """
    @staticmethod
    async def get_blocks_by_date(
        session: AsyncSession,
        block_date: date,
    ) -> TimeBlockListResponse:
        """
        Get all time blocks for a date
        """
        blocks = await TimeBlockRepository.get_by_date(session, block_date)
        return TimeBlockListResponse(
            items = [TimeBlockResponse.model_validate(b) for b in blocks],
            date = block_date,
        )

    @staticmethod
    async def create_block(
        session: AsyncSession,
        data: TimeBlockCreate,
    ) -> TimeBlockResponse:
        """
        Create a time block
        """
        block = await TimeBlockRepository.create(
            session,
            block_date = data.block_date,
            start_time = data.start_time,
            end_time = data.end_time,
            title = data.title,
            description = data.description,
            color = data.color,
            sort_order = data.sort_order,
        )
        return TimeBlockResponse.model_validate(block)

    @staticmethod
    async def update_block(
        session: AsyncSession,
        block_id: UUID,
        data: TimeBlockUpdate,
    ) -> TimeBlockResponse:
        """
        Update a time block
        """
        block = await TimeBlockRepository.get_by_id(session, block_id)
        if not block:
            raise TimeBlockNotFound(block_id)

        update_dict = data.model_dump(exclude_unset = True)
        block = await TimeBlockRepository.update(
            session,
            block,
            **update_dict
        )
        return TimeBlockResponse.model_validate(block)

    @staticmethod
    async def delete_block(
        session: AsyncSession,
        block_id: UUID,
    ) -> None:
        """
        Delete a time block
        """
        block = await TimeBlockRepository.get_by_id(session, block_id)
        if not block:
            raise TimeBlockNotFound(block_id)
        await TimeBlockRepository.delete(session, block)

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `PlannerService` class interacts with a `TimeBlockRepository` to perform CRUD operations on time blocks. The repository handles database interactions, ensuring that service logic remains clean and focused.

- **Implementation**: 
  - `get_blocks_by_date`, `create_block`, `update_block`, and `delete_block` methods in `PlannerService` delegate the actual database operations to `TimeBlockRepository`.
  - `TimeBlockRepository` contains methods like `get_by_date`, `create`, `get_by_id`, `update`, and `delete`.

- **Benefits**:
  - **Separation of Concerns**: The repository handles all data-related logic, making the service layer simpler and more focused on business logic.
  - **Testability**: Repository methods can be easily mocked or replaced for unit testing.

- **Deviations**:
  - The `PlannerService` class is stateless (all methods are static), which might not align with the typical repository pattern where services often manage application state. However, this deviation simplifies the service layer.
  - No explicit error handling in the repository; exceptions like `ResourceNotFound` are raised directly.

- **Appropriateness**:
  - This pattern is appropriate for managing data operations and ensuring that business logic remains clean and testable.
  - It’s particularly useful when dealing with complex database interactions or when you need to switch between different storage mechanisms without changing the service layer.

---

*Generated by CodeWorm on 2026-02-25 20:12*
