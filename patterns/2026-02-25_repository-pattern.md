# repository_pattern

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/core/foundation/repositories/base.py
**Language:** python
**Lines:** 1-107
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
base.py
"""

from collections.abc import Sequence
from typing import (
    Any,
    Generic,
    TypeVar,
)
from uuid import UUID

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from core.infrastructure.database.Base import Base


ModelT = TypeVar("ModelT", bound = Base)


class BaseRepository(Generic[ModelT]):
    """
    Generic repository with common CRUD operations
    """
    model: type[ModelT]

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> ModelT | None:
        """
        Get a single record by ID
        """
        return await session.get(cls.model, id)

    @classmethod
    async def get_multi(
        cls,
        session: AsyncSession,
        skip: int = 0,
        limit: int = 100,
    ) -> Sequence[ModelT]:
        """
        Get multiple records with pagination
        """
        result = await session.execute(
            select(cls.model).offset(skip).limit(limit)
        )
        return result.scalars().all()

    @classmethod
    async def count(cls, session: AsyncSession) -> int:
        """
        Count total records
        """
        result = await session.execute(
            select(func.count()).select_from(cls.model)
        )
        return result.scalar_one()

    @classmethod
    async def create(
        cls,
        session: AsyncSession,
        **kwargs: Any,
    ) -> ModelT:
        """
        Create a new record
        """
        instance = cls.model(**kwargs)
        session.add(instance)
        await session.flush()
        await session.refresh(instance)
        return instance

    @classmethod
    async def update(
        cls,
        session: AsyncSession,
        instance: ModelT,
        **kwargs: Any,
    ) -> ModelT:
        """
        Update an existing record
        """
        for key, value in kwargs.items():
            setattr(instance, key, value)
        await session.flush()
        await session.refresh(instance)
        return instance

    @classmethod
    async def delete(
        cls,
        session: AsyncSession,
        instance: ModelT,
    ) -> None:
        """
        Delete a record
        """
        await session.delete(instance)
        await session.flush()

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `BaseRepository` class implements a generic repository pattern, providing common CRUD operations for database entities. Each method (`get_by_id`, `get_multi`, `count`, `create`, `update`, and `delete`) operates on a specific model type, ensuring that the business logic is decoupled from the data access layer.

**Benefits:**
- **Decoupling:** The repository abstracts the interaction with the database, making it easier to switch between different storage mechanisms.
- **Reusability:** Generic methods can be reused across multiple models by simply specifying the model type.
- **Testability:** Repository methods are isolated and can be easily tested in isolation from the database.

**Deviations:**
- The implementation uses class methods instead of instance methods, which is a common deviation but still adheres to the repository pattern's intent.
- The use of `TypeVar` for generic type hints enhances code readability and maintainability.

**Appropriateness:**
This pattern is highly appropriate in this context because it provides a structured way to manage database operations. It ensures that business logic remains separate from data access, making the application more modular and easier to maintain. However, it might be overkill for very simple applications or when working with small datasets where direct ORM usage could suffice.

---

*Generated by CodeWorm on 2026-02-25 20:25*
