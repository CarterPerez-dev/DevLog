# repository_pattern

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/auth/repositories/user.py
**Language:** python
**Lines:** 1-109
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
user.py
"""
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from aspects.auth.models.User import User
from core.foundation.repositories.base import BaseRepository


class UserRepository(BaseRepository[User]):
    """
    Repository for User model database operations
    """
    model = User

    @classmethod
    async def get_by_email(
        cls,
        session: AsyncSession,
        email: str,
    ) -> User | None:
        """
        Get user by email address
        """
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalars().first()

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> User | None:
        """
        Get user by ID
        """
        return await session.get(User, id)

    @classmethod
    async def email_exists(
        cls,
        session: AsyncSession,
        email: str,
    ) -> bool:
        """
        Check if email is already registered
        """
        result = await session.execute(
            select(User.id).where(User.email == email)
        )
        return result.scalars().first() is not None

    @classmethod
    async def create_user(
        cls,
        session: AsyncSession,
        email: str,
        hashed_password: str,
        full_name: str | None = None,
    ) -> User:
        """
        Create a new user
        """
        user = User(
            email = email,
            hashed_password = hashed_password,
            full_name = full_name,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def update_password(
        cls,
        session: AsyncSession,
        user: User,
        hashed_password: str,
    ) -> User:
        """
        Update user password and increment token version
        """
        user.hashed_password = hashed_password
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def increment_token_version(
        cls,
        session: AsyncSession,
        user: User,
    ) -> User:
        """
        Invalidate all user tokens
        """
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

**Implementation:**
The `UserRepository` class in the provided code implements the repository pattern by encapsulating database operations for the `User` model. It provides methods like `get_by_email`, `get_by_id`, `email_exists`, `create_user`, and `update_password`. These methods abstract away the details of interacting with the SQLAlchemy session, providing a clean interface for performing CRUD operations.

**Benefits:**
- **Encapsulation:** The repository pattern encapsulates database interactions within a single class, making it easier to switch between different data access technologies.
- **Decoupling:** It decouples business logic from data access logic, allowing changes in the database schema or storage mechanism without affecting other parts of the application.

**Deviations:**
- While most methods follow the pattern, some methods like `increment_token_version` and `update_password` modify the user object directly. This is a deviation because typically, repository methods should not alter objects but rather return them after operations.
- The use of class methods (`@classmethod`) implies that instances are not needed to call these methods, which is standard for repositories.

**Appropriateness:**
This pattern is appropriate in this context as it provides a clear separation between business logic and data access. However, the direct modification of objects within certain methods might be better handled through instance methods or by returning modified objects instead.

---

*Generated by CodeWorm on 2026-02-25 21:06*
