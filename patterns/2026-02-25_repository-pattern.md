# repository_pattern

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/auth/services/auth.py
**Language:** python
**Lines:** 1-213
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
auth.py
"""

import uuid6
from sqlalchemy.ext.asyncio import (
    AsyncSession,
)

from core.exceptions import (
    InvalidCredentials,
    TokenError,
    TokenRevokedError,
)
from core.security.auth.jwt import (
    hash_token,
    create_access_token,
    create_refresh_token,
    verify_password_with_timing_safety,
)
from aspects.auth.models.User import User
from aspects.auth.repositories.user import UserRepository
from aspects.auth.repositories.refresh_token import RefreshTokenRepository
from aspects.auth.schemas.auth import (
    TokenResponse,
    TokenWithUserResponse,
)
from aspects.auth.schemas.user import UserResponse


class AuthService:
    """
    Business logic for authentication operations
    """
    @staticmethod
    async def authenticate(
        session: AsyncSession,
        email: str,
        password: str,
        device_id: str | None = None,
        device_name: str | None = None,
        ip_address: str | None = None,
    ) -> tuple[str,
               str,
               User]:
        """
        Authenticate user and create tokens
        """
        user = await UserRepository.get_by_email(session, email)
        hashed_password = user.hashed_password if user else None

        is_valid, new_hash = await verify_password_with_timing_safety(
            password, hashed_password
        )

        if not is_valid or user is None:
            raise InvalidCredentials()

        if not user.is_active:
            raise InvalidCredentials()

        if new_hash:
            await UserRepository.update_password(session, user, new_hash)

        access_token = create_access_token(user.id, user.token_version)

        family_id = uuid6.uuid7()
        raw_refresh, token_hash, expires_at = create_refresh_token(user.id, family_id)

        await RefreshTokenRepository.create_token(
            session,
            user_id = user.id,
            token_hash = token_hash,
            family_id = family_id,
            expires_at = expires_at,
            device_id = device_id,
            device_name = device_name,
            ip_address = ip_address,
        )

        return access_token, raw_refresh, user

    @staticmethod
    async def login(
        session: AsyncSession,
        email: str,
        password: str,
        device_id: str | None = None,
        device_name: str | None = None,
        ip_address: str | None = None,
    ) -> tuple[TokenWithUserResponse,
               str]:
        """
        Login and return tokens with user data
        """
        access_token, refresh_token, user = await AuthService.authenticate(
            session,
            email,
            password,
            device_id,
            device_name,
            ip_address,
        )

        response = TokenWithUserResponse(
            access_token = access_token,
            user = UserResponse.model_validate(user),
        )
        return response, refresh_token

    @staticmethod
    async def refresh_to
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

**Implementation:**
The `AuthService` class interacts with repositories (`UserRepository`, `RefreshTokenRepository`) to perform operations like getting, updating, and creating user and token data. The methods `authenticate`, `login`, `refresh_tokens`, and `logout` delegate the responsibility of database interactions to these repositories.

**Benefits:**
1. **Decoupling:** By separating business logic from data access, the code is more modular and easier to test.
2. **Consistency:** Ensures that all data access follows a consistent pattern, making it easier to maintain and scale.
3. **Testability:** Repositories can be easily mocked or replaced with in-memory databases for unit testing.

**Deviations:**
- The `AuthService` class is not strictly following the repository pattern as defined by Martin Fowler, where repositories should encapsulate all data access logic. Here, the service layer still contains some business logic.
- Some methods like `logout` are incomplete and might require additional parameters or error handling.

**Appropriateness:**
This pattern is appropriate in this context because it clearly separates concerns between business logic and data access, making the codebase more maintainable and testable. It is particularly beneficial in a microservices architecture where different services may need to interact with the same database models. However, for simpler applications or scenarios where the service layer is minimal, this level of separation might be overkill.

---

*Generated by CodeWorm on 2026-02-25 20:54*
