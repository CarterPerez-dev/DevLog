# repository_pattern

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/auth/repositories/refresh_token.py
**Language:** python
**Lines:** 1-179
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
refresh_token.py
"""

from uuid import UUID
from datetime import UTC, datetime

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from aspects.auth.models.RefreshToken import RefreshToken
from core.foundation.repositories.base import BaseRepository


class RefreshTokenRepository(BaseRepository[RefreshToken]):
    """
    Repository for RefreshToken model database operations
    """
    model = RefreshToken

    @classmethod
    async def get_by_hash(
        cls,
        session: AsyncSession,
        token_hash: str,
    ) -> RefreshToken | None:
        """
        Get refresh token by its hash
        """
        result = await session.execute(
            select(RefreshToken).where(
                RefreshToken.token_hash == token_hash
            )
        )
        return result.scalars().first()

    @classmethod
    async def get_valid_by_hash(
        cls,
        session: AsyncSession,
        token_hash: str,
    ) -> RefreshToken | None:
        """
        Get valid (not revoked, not expired) refresh token by hash
        """
        result = await session.execute(
            select(RefreshToken).where(
                RefreshToken.token_hash == token_hash,
                RefreshToken.is_revoked == False,
                RefreshToken.expires_at > datetime.now(UTC),
            )
        )
        return result.scalars().first()

    @classmethod
    async def create_token(
        cls,
        session: AsyncSession,
        user_id: UUID,
        token_hash: str,
        family_id: UUID,
        expires_at: datetime,
        device_id: str | None = None,
        device_name: str | None = None,
        ip_address: str | None = None,
    ) -> RefreshToken:
        """
        Create a new refresh token
        """
        token = RefreshToken(
            user_id = user_id,
            token_hash = token_hash,
            family_id = family_id,
            expires_at = expires_at,
            device_id = device_id,
            device_name = device_name,
            ip_address = ip_address,
        )
        session.add(token)
        await session.flush()
        await session.refresh(token)
        return token

    @classmethod
    async def revoke_token(
        cls,
        session: AsyncSession,
        token: RefreshToken,
    ) -> RefreshToken:
        """
        Revoke a single token
        """
        token.revoke()
        await session.flush()
        await session.refresh(token)
        return token

    @classmethod
    async def revoke_family(
        cls,
        session: AsyncSession,
        family_id: UUID,
    ) -> int:
        """
        Revoke all tokens in a family (for replay attack response)

        Returns count of revoked tokens
        """
        result = await session.execute(
            update(RefreshToken).where(
                RefreshToken.family_id == family_id,
                RefreshToken.is_revoked == False,
            ).values(is_re
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `RefreshTokenRepository` class implements the **Repository Pattern**, which encapsulates database access logic within a dedicated class. This implementation provides methods for common CRUD operations and specific business logic related to refresh tokens.

#### How Implemented:
- The class inherits from `BaseRepository`, indicating it is part of a larger repository framework.
- Methods like `get_by_hash`, `create_token`, `revoke_token`, etc., handle database interactions such as querying, creating, updating, and deleting entities (`RefreshToken`).

#### Benefits:
1. **Encapsulation**: Separates data access logic from business logic, making the code more maintainable.
2. **Testability**: Easier to mock or stub database operations for unit testing.
3. **Consistency**: Ensures a consistent approach to handling database interactions across the application.

#### Deviations:
- The `BaseRepository` is not explicitly shown in this snippet but is assumed to provide common methods and properties like `model`.
- Methods use class-level definitions, which is typical of repository patterns in Python.
- Some methods (like `cleanup_expired`) perform additional cleanup tasks beyond CRUD operations, indicating a mix of business logic.

#### Appropriateness:
This pattern is highly appropriate for this scenario as it effectively encapsulates database interactions and provides a clear separation between data access and application logic. It ensures that the code remains clean and maintainable, especially in larger applications where multiple repositories might be used.

---

*Generated by CodeWorm on 2026-02-25 21:08*
