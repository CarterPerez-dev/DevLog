# decorator_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/admin/utils/decorators/response.py
**Language:** python
**Lines:** 1-41
**Complexity:** 0.0

---

## Source Code

```python
"""
Pydantic Response Decorator
/api/admin/utils/response.py
"""

from functools import wraps
from pydantic import BaseModel


def R(schema_class: type[BaseModel]):
    """
    Response schema decorator for Pydantic models
    """
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            result = f(*args, **kwargs)

            if isinstance(result, tuple):
                data, status_code = result
                if isinstance(data, dict):
                    validated = schema_class(**data)
                    return validated.model_dump(mode = 'json'), status_code
                return result

            if isinstance(result, dict):
                validated = schema_class(**result)
                return validated.model_dump(mode = 'json')

            if isinstance(result, BaseModel):
                if isinstance(result, schema_class):
                    return result.model_dump(mode = 'json')
                validated = schema_class(**result.model_dump())
                return validated.model_dump(mode = 'json')

            return result

        return wrapper

    return decorator

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

The `R` decorator in the provided code wraps a function to ensure that its return value, if it's a dictionary or an instance of a Pydantic model, gets validated and returned as JSON. This implementation follows the Decorator pattern by enhancing the functionality of the decorated function without modifying its structure.

**Benefits:**
- **Encapsulation:** The decorator encapsulates validation logic, making it reusable across multiple functions.
- **Flexibility:** It can handle different types of return values (tuple, dict, or Pydantic model) and validate them accordingly.
- **Consistency:** Ensures that all responses adhere to the specified schema, promoting consistency in API outputs.

**Deviations:**
- The decorator checks for multiple conditions (`tuple`, `dict`, `BaseModel`) and handles each case differently. This is a deviation from the standard single responsibility principle of decorators, which typically wrap a function with minimal changes.
- The use of `@wraps(f)` ensures that the metadata (name, docstring) of the original function is preserved.

**Appropriateness:**
This pattern is appropriate when you need to add cross-cutting concerns like validation or formatting to multiple functions without modifying their core logic. It's particularly useful in APIs where consistent response formats are essential. However, it might be overkill for simple functions with straightforward return types.

---

*Generated by CodeWorm on 2026-02-22 07:01*
