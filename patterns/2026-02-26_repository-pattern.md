# repository_pattern

**Type:** Pattern Analysis
**Repository:** my-portfolio
**File:** v1/backend/app/user/repository.py
**Language:** python
**Lines:** 1-110
**Complexity:** 0.0

---

## Source Code

```python
"""
ⒸAngelaMos | 2025
repository.py
"""
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from config import UserRole
from .User import User
from core.base_repository import BaseRepository


class UserRepository(BaseRepository[User]):
    """
    Repository for User model database operations
    """
    model = User

    @classmethod
    async def get_by_email(
        cls,
        session: AsyncSession,
        email: str,
    ) -> User | None:
        """
        Get user by email address
        """
        result = await session.execute(select(User).where(User.email == email))
        return result.scalars().first()

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> User | None:
        """
        Get user by ID
        """
        return await session.get(User, id)

    @classmethod
    async def email_exists(
        cls,
        session: AsyncSession,
        email: str,
    ) -> bool:
        """
        Check if email is already registered
        """
        result = await session.execute(
            select(User.id).where(User.email == email)
        )
        return result.scalars().first() is not None

    @classmethod
    async def create_user(
        cls,
        session: AsyncSession,
        email: str,
        hashed_password: str,
        full_name: str | None = None,
        role: UserRole = UserRole.USER,
    ) -> User:
        """
        Create a new user
        """
        user = User(
            email = email,
            hashed_password = hashed_password,
            full_name = full_name,
            role = role,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def update_password(
        cls,
        session: AsyncSession,
        user: User,
        hashed_password: str,
    ) -> User:
        """
        Update user password and increment token version
        """
        user.hashed_password = hashed_password
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def increment_token_version(
        cls,
        session: AsyncSession,
        user: User,
    ) -> User:
        """
        Invalidate all user tokens
        """
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `UserRepository` class implements the **Repository Pattern**, which abstracts data access operations, providing a clean interface for interacting with the database.

#### Implementation Details:
- The `UserRepository` class inherits from `BaseRepository[User]`, ensuring type safety and reusability.
- Methods like `get_by_email`, `get_by_id`, `email_exists`, `create_user`, `update_password`, and `increment_token_version` encapsulate specific database operations, making the code more modular and testable.

#### Benefits:
1. **Encapsulation:** Abstracts database interactions, reducing coupling between business logic and data access.
2. **Testability:** Facilitates unit testing by isolating data access from application logic.
3. **Maintainability:** Easier to modify or replace the underlying data storage mechanism without affecting the rest of the application.

#### Deviations:
- The methods are class methods (`@classmethod`), which is a deviation from the typical instance method usage in the Repository Pattern. This might be due to the static nature of some operations or for simplicity.
- No explicit transaction handling, though this can be added using context managers or transactions provided by SQLAlchemy.

#### Appropriate Use Cases:
This pattern is appropriate when you need to abstract database access and ensure that your application's business logic remains decoupled from its data storage. It’s particularly useful in applications with complex data models or multiple data sources.

---

*Generated by CodeWorm on 2026-02-26 11:13*
