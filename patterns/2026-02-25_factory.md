# factory

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/checklist/routes.py
**Language:** python
**Lines:** 1-125
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
routes.py
"""

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Query, status

from core.security.auth.dependencies import DBSession
from core.foundation.responses import NOT_FOUND_404
from aspects.life_manager.facets.checklist.schemas import (
    ChecklistItemCreate,
    ChecklistItemUpdate,
    ChecklistItemResponse,
    ChecklistItemListResponse,
    ChecklistDayResponse,
    ChecklistLogResponse,
    ChecklistLogUpdate,
    ChecklistStatsResponse,
)
from aspects.life_manager.facets.checklist.service import ChecklistService


router = APIRouter(prefix = "/checklist", tags = ["Life Checklist"])


@router.get(
    "/items",
    response_model = ChecklistItemListResponse,
)
async def get_items(db: DBSession) -> ChecklistItemListResponse:
    """
    Get all active checklist items
    """
    return await ChecklistService.get_items(db)


@router.post(
    "/items",
    response_model = ChecklistItemResponse,
    status_code = status.HTTP_201_CREATED,
)
async def create_item(
    db: DBSession,
    data: ChecklistItemCreate,
) -> ChecklistItemResponse:
    """
    Create a checklist item
    """
    return await ChecklistService.create_item(db, data)


@router.put(
    "/items/{item_id}",
    response_model = ChecklistItemResponse,
    responses = {**NOT_FOUND_404},
)
async def update_item(
    db: DBSession,
    item_id: UUID,
    data: ChecklistItemUpdate,
) -> ChecklistItemResponse:
    """
    Update a checklist item
    """
    return await ChecklistService.update_item(db, item_id, data)


@router.delete(
    "/items/{item_id}",
    status_code = status.HTTP_204_NO_CONTENT,
    responses = {**NOT_FOUND_404},
)
async def delete_item(
    db: DBSession,
    item_id: UUID,
) -> None:
    """
    Soft-delete a checklist item
    """
    await ChecklistService.delete_item(db, item_id)


@router.get(
    "/log",
    response_model = ChecklistDayResponse,
)
async def get_day(
    db: DBSession,
    log_date: date = Query(default_factory = date.today),
) -> ChecklistDayResponse:
    """
    Get checklist for a day (auto-inits if first visit)
    """
    return await ChecklistService.get_day(db, log_date)


@router.patch(
    "/log/{log_id}",
    response_model = ChecklistLogResponse,
    responses = {**NOT_FOUND_404},
)
async def update_log(
    db: DBSession,
    log_id: UUID,
    data: ChecklistLogUpdate,
) -> ChecklistLogResponse:
    """
    Toggle completion and set note on a log entry
    """
    return await ChecklistService.update_log(db, log_id, data)


@router.get(
    "/stats",
    response_model = ChecklistStatsResponse,
)
async def get_stats(db: DBSession) -> ChecklistStatsResponse:
    """
    Get streak, per-item completion rates, and year heatmap
    """
    return await ChecklistService.get_stats(db)

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided code, the `ChecklistService` acts as a factory method for creating, updating, deleting, and retrieving checklist items and logs. Each route in the `routes.py` file calls methods on `ChecklistService`, such as `get_items`, `create_item`, `update_item`, etc., which encapsulate the business logic.

**Benefits:**
- **Encapsulation:** The service layer handles all operations related to checklist items and logs, making it easier to manage and update business rules.
- **Decoupling:** Routes are decoupled from the specific implementation details of the service methods, allowing for easier maintenance and testing.

**Deviations:**
- While `ChecklistService` follows a factory method pattern by providing various operations, there is no explicit creation of objects through a factory class or method. Instead, it uses direct method calls.
- The `routes.py` file does not show any instantiation of the service layer; it assumes that the service methods are already available.

**Appropriateness:**
This pattern is appropriate for this context because:
- It centralizes business logic in one place (`ChecklistService`), making the code more modular and testable.
- The separation between the API endpoints (routes) and the business logic allows for easier maintenance and scalability.

---

*Generated by CodeWorm on 2026-02-25 21:43*
