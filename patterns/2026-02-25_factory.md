# factory

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/conftest.py
**Language:** python
**Lines:** 1-285
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2025
conftest.py

Test configuration, fixtures, and factories
"""

import hashlib
import secrets
from datetime import (
    UTC,
    datetime,
    timedelta,
)
from uuid import uuid4
from collections.abc import AsyncIterator

import pytest
from httpx import (
    AsyncClient,
    ASGITransport,
)
import pytest_asyncio
from sqlalchemy.ext.asyncio import (
    AsyncSession,
    create_async_engine,
)
from sqlalchemy.pool import StaticPool

from core.security.auth.jwt import (
    hash_password,
    create_access_token,
)
from config import UserRole
from core.infrastructure.database.session import get_db_session

from core.infrastructure.database.Base import Base
from aspects.auth.models.User import User
from aspects.auth.models.RefreshToken import RefreshToken


@pytest_asyncio.fixture(scope = "session", loop_scope = "session")
async def test_engine():
    """
    Session scoped async engine with in memory SQLite
    StaticPool keeps single connection so DB persists
    """
    engine = create_async_engine(
        "sqlite+aiosqlite:///:memory:",
        poolclass = StaticPool,
        connect_args = {"check_same_thread": False},
        echo = False,
    )
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield engine
    await engine.dispose()


@pytest.fixture
async def db_session(test_engine) -> AsyncIterator[AsyncSession]:
    """
    Per test session with transaction rollback for isolation
    App commits become savepoints that rollback with test
    """
    async with test_engine.connect() as conn:
        await conn.begin()

        session = AsyncSession(
            bind = conn,
            expire_on_commit = False,
            join_transaction_mode = "create_savepoint",
        )

        yield session

        await session.close()
        await conn.rollback()


@pytest.fixture
async def client(db_session: AsyncSession) -> AsyncIterator[AsyncClient]:
    """
    Async HTTP client with DB session override
    """
    from src.__main__ import app

    async def override_get_db():
        yield db_session

    app.dependency_overrides[get_db_session] = override_get_db

    async with AsyncClient(
            transport = ASGITransport(app = app),
            base_url = "http://test",
    ) as ac:
        yield ac

    app.dependency_overrides.clear()


@pytest.fixture
def auth_headers(access_token: str) -> dict[str, str]:
    """
    Authorization headers for authenticated requests
    """
    return {"Authorization": f"Bearer {access_token}"}


@pytest.fixture
def admin_auth_headers(admin_access_token: str) -> dict[str, str]:
    """
    Authorization headers for admin requests
    """
    return {"Authorization": f"Bearer {admin_access_token}"}


class UserFactory:
    """
    Factory for creating test users
    """
    _counter = 0

    @classmethod
    async def create(
        cls,
        session: AsyncSession,
        *,
        email: str | None = None,
        passwor
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `UserFactory` and `RefreshTokenFactory` classes in the provided code implement the Factory Method design pattern. These factories are responsible for creating instances of `User` and `RefreshToken` objects, respectively.

- **Implementation**: The factory methods (`create` in both classes) accept a session object and various parameters to construct test users and tokens. They handle the creation process by adding entities to the database session, flushing changes, and refreshing the objects before returning them.
  
- **Benefits**:
  - **Encapsulation**: The factories encapsulate the complex logic required to create and persist these objects in the database.
  - **Test Isolation**: By using these factories, tests can easily generate consistent test data without directly interacting with the database.

- **Deviations**:
  - The `UserFactory` and `RefreshTokenFactory` classes use class-level attributes (`_counter`) to manage state across multiple factory instances. This is a deviation from the pure Factory Method pattern.
  - The factories also handle the creation of related entities (e.g., adding tokens to users), which introduces some complexity.

- **Appropriateness**:
  - This pattern is appropriate in this context because it simplifies test setup and ensures consistent, isolated test data. It abstracts away the details of database interaction, making tests more maintainable and easier to write.
  - However, for larger applications or when dealing with complex object hierarchies, a more generalized factory might be preferred.

This pattern effectively manages the creation of test entities in a structured and reusable manner, enhancing the overall quality and reliability of the testing process.

---

*Generated by CodeWorm on 2026-02-25 20:27*
