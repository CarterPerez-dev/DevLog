# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/api-security-scanner/backend/repositories/scan_repository.py
**Language:** python
**Lines:** 1-160
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
Handles all Scan model database queries
"""

from __future__ import annotations

from datetime import UTC, datetime
from sqlalchemy.orm import (
    Session,
    joinedload,
)

from config import settings
from models.Scan import Scan


class ScanRepository:
    """
    Repository for Scan database operations
    """
    @staticmethod
    def create_scan(
        db: Session,
        user_id: int,
        target_url: str,
        commit: bool = True
    ) -> Scan:
        """
        Create a new scan

        Args:
            db: Database session
            user_id: User ID who initiated the scan
            target_url: Target URL to scan
            commit: Whether to commit the transaction

        Returns:
            Scan: Created scan instance
        """
        scan = Scan(
            user_id = user_id,
            target_url = target_url,
            scan_date = datetime.now(UTC),
        )
        db.add(scan)
        if commit:
            db.commit()
            db.refresh(scan)
        return scan

    @staticmethod
    def get_by_id(db: Session, scan_id: int) -> Scan | None:
        """
        Get scan by ID with test results loaded

        Args:
            db: Database session
            scan_id: Scan ID

        Returns:
            Scan | None: Scan instance or None if not found
        """
        return (
            db.query(Scan).options(
                joinedload(Scan.test_results)
            ).filter(Scan.id == scan_id).first()
        )

    @staticmethod
    def get_by_user(
        db: Session,
        user_id: int,
        skip: int = 0,
        limit: int | None = None
    ) -> list[Scan]:
        """
        Get all scans for a user with pagination.

        Args:
            db: Database session
            user_id: User ID
            skip: Number of records to skip
            limit: Maximum number of records to return (DEFAULT_PAGINATION_LIMIT)

        Returns:
            list[Scan]: List of scans with test results
        """
        if limit is None:
            limit = settings.DEFAULT_PAGINATION_LIMIT

        return (
            db.query(Scan).options(
                joinedload(Scan.test_results)
            ).filter(Scan.user_id == user_id).order_by(
                Scan.scan_date.desc()
            ).offset(skip).limit(limit).all()
        )

    @staticmethod
    def get_recent(db: Session,
                   limit: int | None = None) -> list[Scan]:
        """
        Get most recent scans across all users.

        Args:
            db: Database session
            limit: Maximum number of scans to return (DEFAULT_PAGINATION_LIMIT)

        Returns:
            list[Scan]: List of recent scans
        """
        if limit is None:
            limit = settings.DEFAULT_PAGINATION_LIMIT

        return (
            db.query(Scan).options(
                joinedload(Scan.test_results)
            ).order_by(Scan.scan_date.desc()).limit(limit).all()
        )

    @staticmet
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern  
**Implementation:**

The `ScanRepository` class encapsulates all database operations related to the `Scan` model, providing static methods for creating, retrieving, updating, and deleting scans. Each method handles a specific operation, such as `create_scan`, `get_by_id`, `get_by_user`, `delete`, and `count_by_user`. These methods use SQLAlchemy sessions (`Session`) to interact with the database.

**Benefits:**

1. **Separation of Concerns:** The repository pattern separates business logic from data access, making the code more modular and easier to maintain.
2. **Testability:** By encapsulating database interactions within a single class, it becomes easier to mock or replace the data source during testing.
3. **Consistency:** Ensures that all database operations follow a consistent interface.

**Deviations:**

- The `ScanRepository` uses static methods instead of instance methods, which is common in Python for utility classes but may not be ideal if you need to maintain state between method calls.
- The use of type hints and the `Session` parameter ensures strong typing and clear method signatures.

**Appropriateness:**

This pattern is highly appropriate when working with SQLAlchemy ORM operations. It provides a clean, organized way to manage database interactions, making the codebase more manageable and easier to test. However, if you need to maintain state between method calls or have complex business logic that requires instance methods, you might consider using an instance-based repository pattern instead.

---

*Generated by CodeWorm on 2026-02-18 17:50*
