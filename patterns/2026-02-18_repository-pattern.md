# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/api-security-scanner/backend/services/scan_service.py
**Language:** python
**Lines:** 1-181
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2025
Coordinates scanners and saves results
"""

from __future__ import annotations

from sqlalchemy.orm import Session
from fastapi import HTTPException, status

from core.enums import TestType
from repositories.scan_repository import ScanRepository
from repositories.test_result_repository import TestResultRepository

from scanners.base_scanner import BaseScanner
from scanners.auth_scanner import AuthScanner
from scanners.idor_scanner import IDORScanner
from scanners.sqli_scanner import SQLiScanner
from scanners.rate_limit_scanner import RateLimitScanner
from schemas.test_result_schemas import TestResultCreate
from schemas.scan_schemas import ScanRequest, ScanResponse


class ScanService:
    """
    Orchestrates security scanning workflow
    """

    @staticmethod
    def run_scan(db: Session, user_id: int, scan_request: ScanRequest) -> ScanResponse:
        """
        Execute security scan with selected tests

        Args:
            db: Database session
            user_id: User ID initiating the scan
            scan_request: Scan configuration and tests to run

        Returns:
            ScanResponse: Scan results with all test outcomes
        """
        scan = ScanRepository.create_scan(
            db=db,
            user_id=user_id,
            target_url=str(scan_request.target_url),
        )

        scanner_mapping: dict[TestType, type[BaseScanner]] = {
            TestType.RATE_LIMIT: RateLimitScanner,
            TestType.AUTH: AuthScanner,
            TestType.SQLI: SQLiScanner,
            TestType.IDOR: IDORScanner,
        }

        results: list[TestResultCreate] = []

        for test_type in scan_request.tests_to_run:
            scanner_class: type[BaseScanner] | None = scanner_mapping.get(test_type)

            if not scanner_class:
                continue

            try:
                scanner = scanner_class(
                    target_url=str(scan_request.target_url),
                    auth_token=scan_request.auth_token,
                    max_requests=scan_request.max_requests,
                )

                result = scanner.scan()
                results.append(result)

            except Exception as e:
                results.append(
                    TestResultCreate(
                        test_name=test_type,
                        status="error",
                        severity="info",
                        details=f"Scanner error: {str(e)}",
                        evidence_json={"error": str(e)},
                        recommendations_json=[
                            "Check target URL is accessible",
                            "Verify authentication token if provided",
                        ],
                    )
                )

        for result in results:
            TestResultRepository.create_test_result(
                db=db,
                scan_id=scan.id,
                test_name=result.test_name,
                status=result.status,
        
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `ScanService` class orchestrates security scanning workflows by interacting with repositories to create, retrieve, update, and delete scans and test results. This implementation follows the **Repository Pattern**, where specific methods handle database operations through repository classes.

- **Implementation**: The `ScanService` uses static methods to interact with `ScanRepository` and `TestResultRepository`. For example, `run_scan` creates a scan record using `ScanRepository.create_scan`, while `get_user_scans` retrieves scans for a user via `ScanRepository.get_by_user`.

- **Benefits**:
  - **Decoupling**: The service layer is decoupled from the database implementation details. This makes it easier to switch databases or modify storage logic without changing the service code.
  - **Consistency**: Ensures consistent data handling and validation across different operations.

- **Deviations**:
  - The pattern is slightly modified by including business logic in some methods, such as error handling during scanning (`run_scan`).
  - The `ScanService` also handles HTTP exceptions, which might be more appropriate for a higher-level API layer rather than the service layer.

- **Appropriateness**:
  - This pattern is highly suitable here because it effectively separates concerns and provides a clean interface between business logic and data access. It's particularly useful in larger applications where multiple services need to interact with the same database entities.

---

*Generated by CodeWorm on 2026-02-18 13:49*
