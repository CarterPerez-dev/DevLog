# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/examples/minimal-production/backend/app/core/dependencies.py
**Language:** python
**Lines:** 1-77
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
dependencies.py
"""

from __future__ import annotations

from typing import Annotated
from uuid import UUID

import jwt
from fastapi import Depends
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession

from config import (
    API_PREFIX,
    TokenType,
)
from .database import get_db_session
from .exceptions import (
    InactiveUser,
    TokenError,
    UserNotFound,
)
from user.User import User
from .security import decode_access_token
from user.repository import UserRepository


oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl = f"{API_PREFIX}/auth/login",
    auto_error = True,
)

DBSession = Annotated[AsyncSession, Depends(get_db_session)]


async def get_current_user(
    token: Annotated[str,
                     Depends(oauth2_scheme)],
    db: DBSession,
) -> User:
    """
    Validate access token and return current user
    """
    try:
        payload = decode_access_token(token)
    except jwt.InvalidTokenError as e:
        raise TokenError(message = str(e)) from e

    if payload.get("type") != TokenType.ACCESS.value:
        raise TokenError(message = "Invalid token type")

    user_id = UUID(payload["sub"])
    user = await UserRepository.get_by_id(db, user_id)

    if user is None:
        raise UserNotFound(identifier = str(user_id))

    return user


async def get_current_active_user(
    user: Annotated[User,
                    Depends(get_current_user)],
) -> User:
    """
    Ensure user is active
    """
    if not user.is_active:
        raise InactiveUser()
    return user


CurrentUser = Annotated["User", Depends(get_current_active_user)]

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used**: Repository Pattern

The `dependencies.py` file implements the **Repository Pattern**, which abstracts data access operations behind a well-defined interface, making it easier to manage and test data-related logic.

#### Implementation Details:
- The `UserRepository.get_by_id()` method is used to fetch user data from the database.
- Dependency injection via `Depends` ensures that the repository methods are properly instantiated and utilized within the context of each function.

#### Benefits:
1. **Separation of Concerns**: Data access logic is encapsulated in the `UserRepository`, making it easier to switch or mock the underlying data source during testing.
2. **Testability**: The use of an asynchronous session (`DBSession`) allows for easy mocking and unit testing without needing a real database.

#### Deviations:
- The pattern is extended with additional validation logic, such as token decoding and user activation checks, which are not typical in pure repository implementations but enhance security and functionality.
- The `CurrentUser` type alias combines multiple dependencies into one, simplifying the dependency injection process for subsequent functions that require both a valid and active user.

#### Appropriate Use Cases:
This pattern is appropriate when you need to manage complex data access logic and ensure that your application remains decoupled from specific database implementations. It's particularly useful in scenarios where security checks (like token validation) are necessary before accessing the repository methods.

---

*Generated by CodeWorm on 2026-02-21 09:44*
