# decorator_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/siem-dashboard/backend/app/core/decorators/response.py
**Language:** python
**Lines:** 1-43
**Complexity:** 0.0

---

## Source Code

```python
"""
©AngelaMos | 2026
response.py
"""

import functools
from typing import Any
from collections.abc import Callable

from flask import Response, jsonify

from app.core.serialization import auto_serialize


def R(status: int = 200) -> Callable[..., Any]:  # noqa: N802
    """
    Auto-serialize the return value into a JSON response
    """
    def decorator(fn: Callable[..., Any]) -> Callable[..., Any]:
        @functools.wraps(fn)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            result = fn(*args, **kwargs)
            return _build_response(result, status)

        return wrapper

    return decorator


def _build_response(
    result: Any,
    default_status: int,
) -> Any:
    """
    Dispatch on return type to produce the correct Flask response
    """
    if isinstance(result, Response):
        return result
    if isinstance(result, tuple):
        data, code = result
        return jsonify(auto_serialize(data)), code
    return jsonify(auto_serialize(result)), default_status

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

In the provided code, the `R` function is a decorator that wraps another function to automatically serialize its return value into a JSON response using Flask's `Response`. This implementation follows the decorator pattern by taking a callable (the decorated function) and returning a new callable (`wrapper`) that modifies or extends the behavior of the original function.

**Benefits:**
- **Encapsulation:** The decorator encapsulates the logic for auto-serializing responses, making the main functions cleaner.
- **Flexibility:** It allows easy modification of response handling without changing the decorated functions' code.
- **Reusability:** The `R` decorator can be applied to multiple functions that need similar behavior.

**Deviations:**
- The `R` function itself is a higher-order function, returning another decorator (`decorator`). This is slightly non-standard but still follows the core principle of wrapping and modifying callable objects.
- The use of `_build_response` as an internal helper function to handle different return types (e.g., Flask `Response`, tuple with data and status) adds complexity but enhances flexibility.

**Appropriateness:**
This pattern is appropriate in scenarios where you need to modify the behavior of functions without changing their core logic, such as adding response serialization or logging. It’s particularly useful in frameworks like Flask where common tasks can be abstracted into reusable decorators.

---

*Generated by CodeWorm on 2026-02-18 23:41*
