# decorator_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/siem-dashboard/backend/app/core/decorators/schema.py
**Language:** python
**Lines:** 1-79
**Complexity:** 0.0

---

## Source Code

```python
"""
©AngelaMos | 2026
schema.py
"""

import functools
from typing import Any, Literal
from collections.abc import Callable

from flask import g, request
from pydantic import (
    BaseModel,
    ValidationError as PydanticValidationError,
)
from app.core.errors import ValidationError


def S(  # noqa: N802
    schema_class: type[BaseModel],
    source: Literal["auto",
                    "query",
                    "body"] = "auto",
) -> Callable[..., Any]:
    """
    Validate request data with Pydantic and store on g.validated
    """
    def decorator(fn: Callable[..., Any]) -> Callable[..., Any]:
        @functools.wraps(fn)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            raw = _extract_data(source)
            try:
                g.validated = schema_class.model_validate(raw)
            except PydanticValidationError as exc:
                raise ValidationError(
                    message = "Validation failed",
                    errors = [
                        {
                            "field": ".".join(str(loc) for loc in e["loc"]),
                            "message": e["msg"],
                            "type": e["type"],
                        } for e in exc.errors()
                    ],
                ) from exc
            return fn(*args, **kwargs)

        return wrapper

    return decorator


def _extract_data(
    source: Literal["auto",
                    "query",
                    "body"],
) -> dict[str,
          Any]:
    """
    Pull raw data from the request based on the declared source
    """
    if source == "query":
        return dict(request.args)
    if source == "body":
        return _get_body()
    if source == "auto":
        if request.method in ("GET", "DELETE", "HEAD", "OPTIONS"):
            return dict(request.args)
        return _get_body()
    return {}


def _get_body() -> dict[str, Any]:
    """
    Extract JSON body from the request or return empty dict
    """
    data = request.get_json(silent = True)
    if data is None:
        return {}
    return data  # type: ignore[no-any-return]

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

In the provided code, the `S` function acts as a decorator that validates request data using Pydantic schemas and stores the validated object in `g.validated`. Here’s how it works:

- **Implementation**: The `S` function is defined with type hints for its parameters. It returns another function (`decorator`) which itself takes a callable (the target function) as an argument. This inner function, `wrapper`, handles the validation logic and calls the original function if successful.
  
- **Benefits**:
  - **Modularity**: The decorator pattern allows you to validate request data independently of business logic, making your code more modular and easier to maintain.
  - **Consistency**: Ensures that all relevant endpoints are validated consistently using Pydantic schemas.

- **Deviations**:
  - The `S` function is decorated with `functools.wraps(fn)` to preserve the metadata of the original function, but this isn’t strictly necessary for validation purposes.
  - `_extract_data` and `_get_body` functions are used to extract data from different sources (query or body), adding flexibility.

- **Appropriateness**:
  - This pattern is appropriate when you need to apply cross-cutting concerns like validation consistently across multiple functions without cluttering their bodies. It’s particularly useful in web frameworks where request handling and validation are common tasks.

This implementation effectively uses the decorator pattern to encapsulate validation logic, making it reusable and maintainable.

---

*Generated by CodeWorm on 2026-02-18 21:36*
