# decorator_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/siem-dashboard/backend/app/core/decorators/endpoint.py
**Language:** python
**Lines:** 1-89
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2026
endpoint.py
"""

import functools
from typing import Any
from collections.abc import Callable, Sequence

import structlog
from flask import g, jsonify

from app.core.errors import AppError, AuthenticationError, ForbiddenError
from app.core.auth import decode_access_token, extract_bearer_token
from app.models.User import User


logger = structlog.get_logger()


def endpoint(
    auth_required: bool = True,
    roles: Sequence[str] | None = None,
) -> Callable[..., Any]:
    """
    Outermost decorator that provides auth extraction, role gating,
    and an error boundary
    """
    effective_auth = auth_required or roles is not None

    def decorator(fn: Callable[..., Any]) -> Callable[..., Any]:
        @functools.wraps(fn)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            try:
                _resolve_auth(effective_auth)
                if roles is not None:
                    _enforce_roles(roles)
                return fn(*args, **kwargs)
            except AppError:
                raise
            except Exception:
                logger.exception(
                    "unhandled_error",
                    endpoint = fn.__name__,
                )
                return jsonify({
                    "error": "InternalServerError",
                    "message": "Internal server error",
                }), 500

        return wrapper

    return decorator


def _resolve_auth(required: bool) -> None:
    """
    Extract JWT and load user onto flask g or raise if required
    """
    g.current_user = None
    token = extract_bearer_token()
    if not token:
        if required:
            raise AuthenticationError()
        return

    try:
        payload = decode_access_token(token)
    except Exception as exc:
        if required:
            raise AuthenticationError("Invalid or expired token") from exc
        return

    user = User.get_or_none(payload["sub"])
    if user is None:
        if required:
            raise AuthenticationError("User not found")
        return
    g.current_user = user


def _enforce_roles(allowed: Sequence[str]) -> None:
    """
    Verify the authenticated user holds one of the required roles
    """
    user = g.current_user
    if user is None or user.role not in allowed:
        raise ForbiddenError()

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Decorator Pattern

The `endpoint` function in the provided code implements a decorator pattern to handle authentication, role-based access control (RBAC), and error handling for Flask endpoints. The outermost `endpoint` function returns an inner `decorator`, which wraps the actual endpoint function.

**Benefits:**
- **Modularity:** The `endpoint` decorator encapsulates common functionality like authentication and RBAC checks.
- **Reusability:** This pattern allows reusing the same authentication logic across multiple endpoints without duplicating code.
- **Error Handling:** Centralized error handling ensures consistent response formats for errors, improving maintainability.

**Deviations:**
- The `endpoint` decorator is designed to be flexible with optional parameters (`auth_required` and `roles`), allowing it to handle different scenarios dynamically.
- The `_resolve_auth` function uses a try-except block to catch exceptions, which might not be the most Pythonic approach. Typically, explicit error handling would be preferred over exception catching.

**Appropriateness:**
This pattern is highly appropriate for web applications where multiple endpoints require similar authentication and authorization checks. It ensures that common logic is centralized and can be easily maintained or extended without modifying each endpoint individually.

---

*Generated by CodeWorm on 2026-02-18 22:50*
