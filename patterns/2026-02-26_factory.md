# factory

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/life_manager/facets/planner/routes.py
**Language:** python
**Lines:** 1-83
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2026
routes.py
"""

from datetime import date
from uuid import UUID

from fastapi import APIRouter, Query, status

from core.security.auth.dependencies import DBSession
from core.foundation.responses import NOT_FOUND_404
from aspects.life_manager.facets.planner.schemas import (
    TimeBlockCreate,
    TimeBlockUpdate,
    TimeBlockResponse,
    TimeBlockListResponse,
)
from aspects.life_manager.facets.planner.service import PlannerService


router = APIRouter(prefix = "/planner", tags = ["Life Planner"])


@router.get(
    "/blocks",
    response_model = TimeBlockListResponse,
)
async def get_time_blocks(
    db: DBSession,
    block_date: date = Query(default_factory = date.today),
) -> TimeBlockListResponse:
    """
    Get all time blocks for a date
    """
    return await PlannerService.get_blocks_by_date(db, block_date)


@router.post(
    "/blocks",
    response_model = TimeBlockResponse,
    status_code = status.HTTP_201_CREATED,
)
async def create_time_block(
    db: DBSession,
    data: TimeBlockCreate,
) -> TimeBlockResponse:
    """
    Create a time block
    """
    return await PlannerService.create_block(db, data)


@router.put(
    "/blocks/{block_id}",
    response_model = TimeBlockResponse,
    responses = {**NOT_FOUND_404},
)
async def update_time_block(
    db: DBSession,
    block_id: UUID,
    data: TimeBlockUpdate,
) -> TimeBlockResponse:
    """
    Update a time block
    """
    return await PlannerService.update_block(db, block_id, data)


@router.delete(
    "/blocks/{block_id}",
    status_code = status.HTTP_204_NO_CONTENT,
    responses = {**NOT_FOUND_404},
)
async def delete_time_block(
    db: DBSession,
    block_id: UUID,
) -> None:
    """
    Delete a time block
    """
    await PlannerService.delete_block(db, block_id)

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Dependency Injection

**Implementation:**
The `routes.py` file uses dependency injection through the `DBSession` parameter in each route function. This parameter is passed to functions like `get_time_blocks`, `create_time_block`, `update_time_block`, and `delete_time_block`. The `DBSession` acts as a dependency that provides database access.

**Benefits:**
- **Testability:** Functions can be easily tested by mocking the `DBSession`.
- **Decoupling:** It decouples the route functions from specific implementations of database operations, making the code more modular and easier to maintain.
- **Consistency:** Ensures that all database interactions are handled consistently across different routes.

**Deviations:**
- The pattern is not strictly a factory pattern. A factory pattern typically involves creating objects based on certain conditions or parameters, which is not the case here.
- The `DBSession` dependency is passed via function arguments rather than being injected at a higher level (e.g., through a constructor).

**Appropriateness:**
This pattern is appropriate for this context because it allows for clean separation of concerns and easy testing. It ensures that database operations are handled consistently across different parts of the application, making the codebase more maintainable and testable.

### Conclusion
Dependency injection in this code enhances modularity and testability by ensuring that database interactions are encapsulated within a single parameter. This approach is well-suited for web service development where clear separation between business logic and infrastructure concerns is crucial.

---

*Generated by CodeWorm on 2026-02-26 09:37*
