# factory

**Type:** Pattern Analysis
**Repository:** angelamos-operations
**File:** CarterOS-Server/src/core/infrastructure/cache/service.py
**Language:** python
**Lines:** 1-238
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
service.py
"""

import json
from typing import (
    Any,
    TypeVar,
    Generic,
)
from collections.abc import Callable
from collections.abc import Awaitable

from redis.asyncio import Redis
from pydantic import BaseModel

from config import settings
from core.infrastructure.cache.keys import (
    build_cache_key,
    get_ttl_with_jitter,
)
from core.foundation.logging import get_logger


logger = get_logger(__name__)

T = TypeVar("T", bound = BaseModel)


class CacheService(Generic[T]):
    """
    Generic caching service for Pydantic models

    Provides cache-aside pattern with automatic serialization

    Usage:
        user_cache = CacheService(redis_client, namespace="users", model=User)
        user = await user_cache.get("123")
        await user_cache.set("123", user_obj, ttl=600)
    """
    def __init__(
        self,
        redis: Redis,
        namespace: str,
        model: type[T] | None = None,
        default_ttl: int | None = None,
        use_jitter: bool = True,
    ):
        self.redis = redis
        self.namespace = namespace
        self.model = model
        self.default_ttl = default_ttl or settings.CACHE_DEFAULT_TTL
        self.use_jitter = use_jitter

    def _build_key(
        self,
        identifier: str,
        params: dict[str,
                     Any] | None = None
    ) -> str:
        """
        Build namespaced cache key
        """
        return build_cache_key(self.namespace, identifier, params)

    def _get_ttl(self, ttl: int | None = None) -> int:
        """
        Get TTL with optional jitter
        """
        effective_ttl = ttl or self.default_ttl
        if self.use_jitter:
            return get_ttl_with_jitter(effective_ttl)
        return effective_ttl

    async def get(
        self,
        identifier: str,
        params: dict[str,
                     Any] | None = None,
    ) -> T | None:
        """
        Get cached value, deserialize to Pydantic model if configured
        """
        try:
            key = self._build_key(identifier, params)
            data = await self.redis.get(key)

            if data is None:
                return None

            if self.model:
                return self.model.model_validate_json(data)

            return json.loads(data) if isinstance(data, str) else data

        except Exception as e:
            logger.warning(f"Cache get failed for {identifier}: {e}")
            return None

    async def set(
        self,
        identifier: str,
        value: T | dict[str,
                        Any] | str,
        ttl: int | None = None,
        params: dict[str,
                     Any] | None = None,
    ) -> bool:
        """
        Set cached value with automatic serialization
        """
        try:
            key = self._build_key(identifier, params)
            effective_ttl = self._get_ttl(ttl)

            if isinstance(value, BaseModel):
                data = value.model_dump_json()
            el
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `get_or_set` method in the `CacheService` class implements a factory method pattern. It checks if an item exists in the cache and, if not, retrieves it using a provided factory function to generate the value.

- **Implementation**: The `get_or_set` method takes a `factory` parameter which is a callable that returns an asynchronous result (`Awaitable[T]`). If the cached value does not exist, the factory function is called to compute the value, and then this value is stored in the cache before being returned.
  
  ```python
  async def get_or_set(
      self,
      identifier: str,
      factory: Callable[[], Awaitable[T]],
      ttl: int | None = None,
      params: dict[str, Any] | None = None,
  ) -> T:
      cached = await self.get(identifier, params)
      if cached is not None:
          return cached

      value = await factory()
      await self.set(identifier, value, ttl=ttl, params=params)
      return value
  ```

- **Benefits**: This pattern ensures that the cache is updated only when necessary, reducing unnecessary computations and improving performance. It also abstracts away the details of how values are generated, making the code more modular.

- **Deviations**: The `get_or_set` method uses a generic type `T`, allowing for flexibility in caching different types of data (e.g., Pydantic models or raw JSON). However, it does not enforce that the factory function always returns an instance of `T`.

- **Appropriateness**: This pattern is appropriate when you need to cache values and ensure they are computed only once. It's particularly useful in scenarios where computations are expensive or time-consuming.

This implementation effectively combines caching with lazy evaluation, making it a robust solution for managing cached data in asynchronous applications.

---

*Generated by CodeWorm on 2026-02-26 09:38*
