# factory

**Type:** Pattern Analysis
**Repository:** kill-pr0cess.inc
**File:** backend/src/lib.rs
**Language:** rust
**Lines:** 1-301
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Â©AngelaMos | 2025
 * Core Library Module
 */

pub mod database;
pub mod models;
pub mod routes;
pub mod services;
pub mod utils;

pub use utils::{
    config::Config,
    error::{AppError, Result},
    metrics::MetricsCollector,
};

pub use database::{
    connection::{DatabasePool, create_pool},
};

pub use models::{
    github::{Repository, RepositoryStats, GitHubUser},
    fractals::{FractalRequest, FractalResponse, FractalType},
    performance::{PerformanceMetric, SystemInfo, BenchmarkResult},
};

pub use services::{
    github_service::GitHubService,
    fractal_service::FractalService,
    performance_service::PerformanceService,
    cache_service::CacheService,
};

#[derive(Clone)]
pub struct AppState {
    pub db_pool: DatabasePool,
    pub redis_client: redis::Client,
    pub github_service: GitHubService,
    pub fractal_service: FractalService,
    pub performance_service: PerformanceService,
    pub cache_service: CacheService,
    pub config: Config,
    pub metrics: MetricsCollector,
}

impl AppState {
    pub async fn new(config: Config) -> Result<Self> {
        let db_pool = create_pool(&config.database_url).await?;

        let redis_client = redis::Client::open(config.redis_url.clone())
            .map_err(|e| AppError::DatabaseError(format!("Redis connection failed: {}", e)))?;

        let metrics = MetricsCollector::new()?;

        let cache_service = CacheService::new(redis_client.clone());
        let github_service = GitHubService::new(
            config.github_token.clone(),
            cache_service.clone(),
        );
        let fractal_service = FractalService::new();
        let performance_service = PerformanceService::new(
            db_pool.clone(),
        );

        Ok(AppState {
            db_pool,
            redis_client,
            github_service,
            fractal_service,
            performance_service,
            cache_service,
            config,
            metrics,
        })
    }

    pub async fn health_check(&self) -> Result<serde_json::Value> {
        use sqlx::Row;

        let db_status = match sqlx::query("SELECT 1 as test")
            .fetch_one(&self.db_pool)
            .await
        {
            Ok(_) => "healthy",
            Err(_) => "unhealthy",
        };

        let mut conn = self.redis_client.get_async_connection().await
            .map_err(|e| AppError::DatabaseError(format!("Redis connection failed: {}", e)))?;

        let redis_status = match redis::cmd("PING")
            .query_async::<_, String>(&mut conn)
            .await
        {
            Ok(_) => "healthy",
            Err(_) => "unhealthy",
        };

        let system_info_json = self.performance_service.get_system_info().await?;

        Ok(serde_json::json!({
            "status": if db_status == "healthy" && redis_status == "healthy" { "healthy" } else { "unhealthy" },
            "timestamp": chrono::Utc::now(),
            "services": {
                "database": db_status,
        
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided Rust code, the `AppState` struct and its associated methods (`new`, `health_check`, `shutdown`) demonstrate a **Factory Method** design pattern. The `new` method creates an instance of `AppState` by initializing various services and components.

#### Implementation
- **Initialization**: The `new` method initializes database connections, Redis clients, service instances, and other dependencies.
- **Error Handling**: It uses the `Result` type to handle potential errors during initialization.
- **Macro Usage**: Macros like `time_operation!` and `cached_operation!` are used to measure operation times and cache results.

#### Benefits
1. **Decoupling**: The factory method decouples the creation of complex objects from their usage, making the code more modular.
2. **Flexibility**: It allows for easy extension by adding new services or modifying existing ones without changing the `AppState` struct's implementation.
3. **Error Management**: Centralized error handling ensures that all initialization steps are properly managed.

#### Deviations
- The factory method is used within a single class (`AppState`) rather than across multiple classes, which is more typical for the pattern.
- Macros are used to abstract common operations like timing and caching, adding an additional layer of abstraction.

#### Appropriateness
This pattern is appropriate in this context because it encapsulates complex initialization logic and error handling. It ensures that all dependencies are properly set up before the application starts, making the code easier to maintain and extend. However, for simpler applications or when the creation process is straightforward, a more direct approach might suffice.

---

*Generated by CodeWorm on 2026-02-26 09:58*
