# factory

**Type:** Pattern Analysis
**Repository:** kill-pr0cess.inc
**File:** backend/src/services/mod.rs
**Language:** rust
**Lines:** 1-416
**Complexity:** 0.0

---

## Source Code

```rust
/*
 * Services module aggregator providing centralized access to all business logic services for the dark performance showcase.
 * I'm organizing GitHub API integration, fractal computation, performance monitoring, and caching into a cohesive service layer that maintains clean separation of concerns.
 */

pub mod fractal_service;
pub mod github_service;
pub mod performance_service;
pub mod cache_service;

// Re-export all services for convenient access throughout the application
pub use fractal_service::FractalService;
pub use github_service::GitHubService;
pub use performance_service::PerformanceService;
pub use cache_service::CacheService;

use crate::{
    database::DatabasePool,
    utils::error::{AppError, Result},
};
use std::sync::Arc;
use tokio::sync::RwLock;

/// Service registry for centralized service management and dependency injection
/// I'm implementing a service registry pattern for clean dependency management
pub struct ServiceRegistry {
    pub fractal_service: Arc<FractalService>,
    pub github_service: Arc<GitHubService>,
    pub performance_service: Arc<PerformanceService>,
    pub cache_service: Arc<CacheService>,
}

impl ServiceRegistry {
    /// Create a new service registry with all services initialized
    /// I'm ensuring all services are properly configured and connected
    pub async fn new(
        db_pool: DatabasePool,
        redis_client: redis::Client,
        github_token: String,
    ) -> Result<Self> {
        tracing::info!("Initializing service registry");

        // Initialize cache service first as other services depend on it
        let cache_service = Arc::new(CacheService::with_config(
            redis_client,
            "perf_showcase:".to_string(),
            3600, // 1 hour default TTL
        ));

        // Initialize GitHub service with cache dependency
        let github_service = Arc::new(GitHubService::new(
            github_token.clone(),
            (*cache_service).clone(),
        ));

        // Initialize fractal service (no external dependencies)
        let fractal_service = Arc::new(FractalService::new());

        // Initialize performance service with database dependency
        let performance_service = Arc::new(PerformanceService::new(db_pool.clone()));

        tracing::info!("All services initialized successfully");

        Ok(Self {
            fractal_service,
            github_service,
            performance_service,
            cache_service,
        })
    }

    /// Perform health checks on all services
    /// I'm implementing comprehensive service health verification
    pub async fn health_check(&self) -> Result<serde_json::Value> {
        let mut health_results = serde_json::Map::new();

        // Check cache service health
        match self.cache_service.health_check().await {
            Ok(cache_health) => {
                health_results.insert("cache".to_string(), cache_health);
            }
            Err(e) => {
                health_results.inser
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided code, a factory method pattern is implemented through the `ServiceRegistry::new` function. This function initializes and configures all services by creating instances of `FractalService`, `GitHubService`, `PerformanceService`, and `CacheService`. Each service is wrapped in an `Arc<>()` to ensure thread-safe access.

**Benefits:**
- **Decoupling:** The factory method decouples the creation logic from the usage, making it easier to add or modify services without changing client code.
- **Centralized Management:** All service initializations are handled in one place, simplifying dependency management and ensuring all services are properly configured before use.

**Deviations:**
- While the `ServiceRegistry::new` function acts as a factory method by creating instances of various services, it does not follow the canonical pattern where multiple subclasses extend a common base class or interface. Instead, each service is initialized directly.
- The health check mechanism for services (e.g., `health_check`, `get_rate_limit_status`) is implemented separately within the registry, which adds complexity but ensures comprehensive monitoring.

**When Appropriate:**
This pattern is appropriate when you need to manage and initialize multiple related objects with varying configurations. It's particularly useful in scenarios where services have complex initialization processes or dependencies that need to be managed centrally.

---

*Generated by CodeWorm on 2026-02-26 10:08*
