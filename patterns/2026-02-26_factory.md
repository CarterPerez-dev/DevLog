# factory

**Type:** Pattern Analysis
**Repository:** fastapi-rc
**File:** fastapi-rc/examples/04_full_api_example.py
**Language:** python
**Lines:** 1-406
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
04_full_api_example.py

API example with multi domain caching strategy
"""

import uvicorn
from typing import Annotated
from datetime import datetime
from contextlib import asynccontextmanager

from fastapi import (
    FastAPI,
    Depends,
    Query,
    status,
)
from pydantic import BaseModel

from fastapi_rc import (
    cachemanager,
    RedisClient,
    CacheService,
)


class User(BaseModel):
    """
    User entity
    """
    id: str
    email: str
    name: str
    created_at: datetime


class Product(BaseModel):
    """
    Product entity
    """
    id: str
    name: str
    price: float
    stock: int


class Order(BaseModel):
    """
    Order entity with computed total
    """
    id: str
    user_id: str
    product_ids: list[str]
    total: float
    created_at: datetime


class Stats(BaseModel):
    """
    Aggregated statistics
    """
    total_users: int
    total_products: int
    total_orders: int
    revenue: float
    cache_hit_rate: float


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifespan with Redis initialization
    """
    cachemanager.init(
        redis_url = "redis://localhost:6379/0",
        max_connections = 100,
        socket_timeout = 5.0,
        health_check_interval = 30,
    )
    yield
    await cachemanager.close()


app = FastAPI(
    title = "E-Commerce API",
    description = "Multi domain caching strategy example",
    version = "1.0.0",
    lifespan = lifespan,
)


async def get_user_cache(redis: RedisClient) -> CacheService[User]:
    """
    User cache: 10 minute TTL (frequently accessed)
    """
    return CacheService(
        redis,
        namespace = "users",
        model = User,
        default_ttl = 600,
        use_jitter = True,
        prefix = "ecommerce",
        version = "v1",
    )


async def get_product_cache(redis: RedisClient) -> CacheService[Product]:
    """
    Product cache: 30 minute TTL (semi-static data)
    """
    return CacheService(
        redis,
        namespace = "products",
        model = Product,
        default_ttl = 1800,
        use_jitter = True,
        prefix = "ecommerce",
        version = "v1",
    )


async def get_order_cache(redis: RedisClient) -> CacheService[Order]:
    """
    Order cache: 5 minute TTL (frequently changing)
    """
    return CacheService(
        redis,
        namespace = "orders",
        model = Order,
        default_ttl = 300,
        use_jitter = True,
        prefix = "ecommerce",
        version = "v1",
    )


UserCache = Annotated[CacheService[User], Depends(get_user_cache)]
ProductCache = Annotated[CacheService[Product], Depends(get_product_cache)]
OrderCache = Annotated[CacheService[Order], Depends(get_order_cache)]


async def fetch_user(user_id: str) -> User:
    """
    Simulate database query
    """
    return User(
        id = user_id,
        email = f"user{user_id}@example.com",
        name = f"User {user_id}",
        created_at = datetime.now
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided code, the `factory` parameter in the `get_or_set` method of `CacheService` acts as a factory method pattern. This pattern is used to create objects (in this case, user and product instances) when needed.

#### Implementation:
- The `factory` function is passed as an argument to `get_or_set`, which is responsible for creating the object if it's not already cached.
  ```python
  await user_cache.get_or_set(
      identifier = user_id,
      factory = lambda: fetch_user(user_id),
  )
  ```
- Similarly, for products:
  ```python
  product = await product_cache.get_or_set(
      identifier = product_id,
      factory = lambda pid = product_id: fetch_product(pid),
  )
  ```

#### Benefits:
1. **Decoupling:** The `factory` method decouples the cache from the data source, allowing for easier changes in how objects are created.
2. **Flexibility:** It allows different strategies for object creation based on context or conditions.

#### Deviations:
- The factory function is simple and inline, whereas a more complex scenario might require a separate class or function to handle the creation logic.
- The `factory` parameter is used consistently across all cache operations, ensuring uniformity in how objects are retrieved or created.

#### Appropriateness:
This pattern is appropriate when you need to create objects based on certain conditions and want to keep the caching mechanism independent of object creation. It's particularly useful in scenarios where the data source might change or require different initialization logic.

In summary, the factory method pattern enhances flexibility and maintainability by separating the cache retrieval logic from the object creation process.

---

*Generated by CodeWorm on 2026-02-26 10:33*
