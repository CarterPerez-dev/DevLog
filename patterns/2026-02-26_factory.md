# factory

**Type:** Pattern Analysis
**Repository:** my-portfolio
**File:** v1/backend/conftest.py
**Language:** python
**Lines:** 1-518
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2025
conftest.py

Test configuration, fixtures, and factories
"""

import sys
from pathlib import Path


sys.path.insert(0, str(Path(__file__).parent / "app"))

import hashlib
import secrets
from datetime import (
    UTC,
    date,
    datetime,
    timedelta,
)
from uuid import uuid4
from collections.abc import AsyncIterator

import pytest
from httpx import (
    AsyncClient,
    ASGITransport,
)
from sqlalchemy.ext.asyncio import (
    AsyncSession,
    create_async_engine,
)

from core.security import (
    hash_password,
    create_access_token,
)
from config import UserRole
from core.database import get_db_session

from core.Base import Base
from user.User import User
from auth.RefreshToken import RefreshToken
from project.Project import Project
from experience.Experience import Experience
from certification.Certification import Certification
from blog.Blog import Blog
from config import (
    Language,
    ProjectStatus,
    EmploymentType,
    CertificationCategory,
    BlogCategory,
)


TEST_DATABASE_URL = "postgresql+asyncpg://test:test@localhost:9366/test_db"


@pytest.fixture
async def db_session() -> AsyncIterator[AsyncSession]:
    """
    Per test session with fresh tables
    """
    engine = create_async_engine(TEST_DATABASE_URL, echo = False)

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)

    async with AsyncSession(engine, expire_on_commit = False) as session:
        yield session

    await engine.dispose()


@pytest.fixture
async def client(db_session: AsyncSession) -> AsyncIterator[AsyncClient]:
    """
    Async HTTP client with DB session override
    """
    from factory import create_app

    app = create_app()

    async def override_get_db():
        yield db_session

    app.dependency_overrides[get_db_session] = override_get_db

    async with AsyncClient(
            transport = ASGITransport(app = app),
            base_url = "http://test",
    ) as ac:
        yield ac

    app.dependency_overrides.clear()


@pytest.fixture
def auth_headers(access_token: str) -> dict[str, str]:
    """
    Authorization headers for authenticated requests
    """
    return {"Authorization": f"Bearer {access_token}"}


@pytest.fixture
def admin_auth_headers(admin_access_token: str) -> dict[str, str]:
    """
    Authorization headers for admin requests
    """
    return {"Authorization": f"Bearer {admin_access_token}"}


class UserFactory:
    """
    Factory for creating test users
    """
    _counter = 0

    @classmethod
    async def create(
        cls,
        session: AsyncSession,
        *,
        email: str | None = None,
        password: str = "TestPass123",
        full_name: str | None = None,
        role: UserRole = UserRole.USER,
        is_active: bool = True,
        is_verified: bool = True,
    ) -> User:
        cls._counter += 1

        user = User(
            email = email or f"user{cls.
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `UserFactory` and `RefreshTokenFactory` classes in the provided code implement the **Factory Method** design pattern. These factories are responsible for creating instances of `User` and `RefreshToken`, respectively, with predefined configurations.

#### Implementation Details:
- Each factory class has a static method `create` that takes an `AsyncSession` as a parameter and returns a fully configured instance.
- The `UserFactory.create` method allows customization through optional parameters such as email, password, full name, role, etc.
- Similarly, the `RefreshTokenFactory.create` method customizes tokens with options like `is_revoked`, `expires_delta`, and generates a unique token hash.

#### Benefits:
1. **Encapsulation**: The factories encapsulate the creation logic, making it easier to manage and modify how objects are created without changing client code.
2. **Flexibility**: Allows for easy customization of object properties during creation.
3. **Testability**: Facilitates testing by providing controlled test data.

#### Deviations:
- The `UserFactory` and `RefreshTokenFactory` classes reset their internal state (`_counter`) between tests, which is a deviation from the canonical factory pattern but ensures that each test starts with a clean slate.

#### Appropriate Use Cases:
This pattern is appropriate in scenarios where you need to create complex objects with varying configurations or when testing requires controlled and consistent data. It's particularly useful for initializing database entities and tokens in test environments, ensuring that tests are isolated and predictable.

---

*Generated by CodeWorm on 2026-02-26 11:00*
