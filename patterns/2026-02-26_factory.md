# factory

**Type:** Pattern Analysis
**Repository:** fastapi-rc
**File:** fastapi-rc/examples/02_cache_service.py
**Language:** python
**Lines:** 1-227
**Complexity:** 0.0

---

## Source Code

```python
"""
ⒸAngelaMos | 2025
02_cache_service.py

Advanced usage with CacheService wrapper
"""

import uvicorn
from typing import Annotated
from contextlib import asynccontextmanager

from fastapi import (
    FastAPI,
    Depends,
    HTTPException,
    status,
)
from pydantic import (
    BaseModel,
    Field,
)

from fastapi_rc import (
    cachemanager,
    RedisClient,
    CacheService,
)


class User(BaseModel):
    """
    User model
    """
    id: str
    email: str
    name: str
    role: str


class UserCreate(BaseModel):
    """
    User creation schema
    """
    email: str = Field(..., min_length = 3)
    name: str = Field(..., min_length = 1)
    role: str = "user"


class UserUpdate(BaseModel):
    """
    User update schema
    """
    name: str | None = None
    role: str | None = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Initialize Redis with production config
    """
    cachemanager.init(
        redis_url = "redis://localhost:6379/0",
        max_connections = 50,
        socket_timeout = 5.0,
        socket_connect_timeout = 2.0,
        health_check_interval = 30,
    )
    yield
    await cachemanager.close()


app = FastAPI(lifespan = lifespan)


async def get_user_cache(redis: RedisClient) -> CacheService[User]:
    """
    Custom cache dependency for users

    10 minute TTL with jitter to prevent stampedes
    """
    return CacheService(
        redis,
        namespace = "users",
        model = User,
        default_ttl = 600,
        use_jitter = True,
        prefix = "api",
        version = "v1",
    )


UserCache = Annotated[CacheService[User], Depends(get_user_cache)]


async def fetch_user_from_db(user_id: str) -> User:
    """
    Simulate database fetch
    """
    if user_id == "999":
        raise HTTPException(
            status_code = status.HTTP_404_NOT_FOUND,
            detail = "User not found",
        )

    return User(
        id = user_id,
        email = f"user{user_id}@example.com",
        name = f"User {user_id}",
        role = "user",
    )


@app.get("/users/{user_id}", response_model = User)
async def get_user(user_id: str, user_cache: UserCache):
    """
    Get user with cache-aside pattern

    Automatically caches miss, returns cached hit
    """
    user = await user_cache.get_or_set(
        identifier = user_id,
        factory = lambda: fetch_user_from_db(user_id),
        ttl = 600,
    )

    return user


@app.post(
    "/users",
    response_model = User,
    status_code = status.HTTP_201_CREATED
)
async def create_user(data: UserCreate, user_cache: UserCache):
    """
    Create user and cache immediately
    """
    user = User(
        id = "new_123",
        email = data.email,
        name = data.name,
        role = data.role,
    )

    await user_cache.set(
        identifier = user.id,
        value = user,
        ttl = 600,
    )

    return user


@app.put("/users/{user_id}", response_model = User)
async def update_user(
    user_id: s
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided code, the `get_user_cache` function acts as a factory method to create instances of `CacheService`. This factory method dynamically configures and returns a cache service for user data.

**Implementation:**
- The `get_user_cache` function initializes a `CacheService` with specific parameters such as TTL (600 seconds), jitter, namespace, model type (`User`), and other settings.
- It uses the `Depends` mechanism to inject this cache service into routes that need it.

**Benefits:**
1. **Flexibility:** The factory method allows for dynamic configuration of the cache service based on route requirements.
2. **Encapsulation:** It encapsulates the creation logic, making the code cleaner and more maintainable.
3. **Reusability:** The same factory can be used to create different instances with varying configurations.

**Deviations:**
- While the pattern is implemented correctly, there's no explicit use of a separate class or interface for the factory method; it’s directly defined in the route logic.
- The `CacheService` instance is not reused across multiple requests but created anew each time. This could be optimized by caching the service instance if the configuration remains constant.

**Appropriateness:**
This pattern is appropriate when different parts of an application require cache services with varying configurations, such as different namespaces or TTLs. It ensures that the creation logic is centralized and can be easily modified without affecting the routes themselves.

---

*Generated by CodeWorm on 2026-02-26 10:42*
