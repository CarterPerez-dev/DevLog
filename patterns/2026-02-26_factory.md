# factory

**Type:** Pattern Analysis
**Repository:** fastapi-rc
**File:** fastapi-rc/examples/03_production_patterns.py
**Language:** python
**Lines:** 1-291
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
03_production_patterns.py

Caching patterns for enterprise applications
"""

import json
import uvicorn
from typing import Annotated
from datetime import datetime
from contextlib import asynccontextmanager

from fastapi import (
    FastAPI,
    Depends,
    Query,
    status,
)
from pydantic import BaseModel

from fastapi_rc import (
    cachemanager,
    RedisClient,
    CacheService,
    get_ttl_with_jitter,
)


class Product(BaseModel):
    """
    Product model
    """
    id: str
    name: str
    category: str
    price: float
    in_stock: bool
    created_at: datetime


class ProductList(BaseModel):
    """
    Paginated product list
    """
    items: list[Product]
    total: int
    page: int
    per_page: int


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Production lifespan with full configuration
    """
    cachemanager.init(
        redis_url = "redis://localhost:6379/0",
        max_connections = 100,
        socket_timeout = 5.0,
        socket_connect_timeout = 2.0,
        health_check_interval = 30,
        decode_responses = True,
    )
    yield
    await cachemanager.close()


app = FastAPI(
    title = "Product API with Redis Caching",
    lifespan = lifespan,
)


async def get_product_cache(redis: RedisClient) -> CacheService[Product]:
    """
    Product cache with 15 minute TTL
    """
    return CacheService(
        redis,
        namespace = "products",
        model = Product,
        default_ttl = 900,
        use_jitter = True,
        prefix = "api",
        version = "v1",
    )


ProductCache = Annotated[CacheService[Product], Depends(get_product_cache)]


async def fetch_product_from_db(product_id: str) -> Product:
    """
    Simulate expensive database query
    """
    return Product(
        id = product_id,
        name = f"Product {product_id}",
        category = "electronics",
        price = 299.99,
        in_stock = True,
        created_at = datetime.now(),
    )


async def fetch_products_from_db(
    category: str | None,
    page: int,
    per_page: int,
) -> ProductList:
    """
    Simulate expensive database query with filters
    """
    products = [
        Product(
            id = str(i),
            name = f"{category or 'General'} Product {i}",
            category = category or "general",
            price = 99.99 * i,
            in_stock = i % 2 == 0,
            created_at = datetime.now(),
        ) for i in range((page - 1) * per_page, page * per_page)
    ]

    return ProductList(
        items = products,
        total = 100,
        page = page,
        per_page = per_page,
    )


@app.get("/products/{product_id}", response_model = Product)
async def get_product(product_id: str, product_cache: ProductCache):
    """
    Pattern 1: Simple cache-aside with CacheService
    """
    product = await product_cache.get_or_set(
        identifier = product_id,
        factory = lambda: fetch_product_from_db(product_id),
    )

    return p
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided code, the `factory` method pattern is used to create objects in a controlled manner. This is evident in several places:

1. **Simple Cache-Aside with CacheService:**
   ```python
   product = await product_cache.get_or_set(
       identifier=product_id,
       factory=lambda: fetch_product_from_db(product_id),
   )
   ```
2. **Query Parameter Caching with Hash:**
   ```python
   products = await product_cache.get_or_set(
       identifier="list",
       factory=lambda: fetch_products_from_db(category, page, per_page),
       params={"category": category, "page": page, "per_page": per_page},
       ttl=180,
   )
   ```
3. **Batch Caching with Redis Pipeline:**
   ```python
   for product in products:
       cache_key = f"api:v1:products:{product.id}"
       pipe.set(cache_key, product.model_dump_json(), ex=get_ttl_with_jitter(900))
   ```

**Benefits:**

- **Decoupling:** The factory method decouples the creation of objects from their use. This makes the code more modular and easier to maintain.
- **Flexibility:** It allows for different implementations of object creation, which can be useful in caching scenarios where different strategies might be needed.

**Deviations:**

- In the batch caching example, a `pipeline` is used to set multiple keys with expiration times. This is an optimization that goes beyond the standard factory method pattern.
- The use of lambdas for factories adds flexibility but may reduce readability compared to predefined classes or functions.

**Appropriateness:**

This pattern is highly appropriate in scenarios where object creation needs to be controlled, such as caching mechanisms. It ensures that objects are created only when necessary and reused from cache if available, optimizing performance and resource usage.

---

*Generated by CodeWorm on 2026-02-26 10:32*
