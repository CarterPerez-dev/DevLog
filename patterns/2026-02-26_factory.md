# factory

**Type:** Pattern Analysis
**Repository:** fastapi-rc
**File:** fastapi-rc/fastapi_rc/service.py
**Language:** python
**Lines:** 1-243
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
service.py
"""

import json
import logging
from typing import (
    Any,
    TypeVar,
    Generic,
)
from collections.abc import Callable
from collections.abc import Awaitable

from redis.asyncio import Redis
from pydantic import BaseModel

from fastapi_rc.keys import (
    build_cache_key,
    get_ttl_with_jitter,
)


logger = logging.getLogger(__name__)

T = TypeVar("T", bound = BaseModel)


class CacheService(Generic[T]):
    """
    Generic caching service for Pydantic models

    Provides cache-aside pattern with automatic serialization

    Usage:
        user_cache = CacheService(
            redis_client,
            namespace="users",
            model=User,
            default_ttl=600
        )
        user = await user_cache.get("123")
        await user_cache.set("123", user_obj, ttl=600)
    """
    def __init__(
        self,
        redis: Redis,
        namespace: str,
        model: type[T] | None = None,
        default_ttl: int = 300,
        use_jitter: bool = True,
        prefix: str = "cache",
        version: str = "v1",
    ):
        self.redis = redis
        self.namespace = namespace
        self.model = model
        self.default_ttl = default_ttl
        self.use_jitter = use_jitter
        self.prefix = prefix
        self.version = version

    def _build_key(
        self,
        identifier: str,
        params: dict[str, Any] | None = None
    ) -> str:
        """
        Build namespaced cache key
        """
        return build_cache_key(
            self.namespace,
            identifier,
            params,
            prefix = self.prefix,
            version = self.version,
        )

    def _get_ttl(self, ttl: int | None = None) -> int:
        """
        Get TTL with optional jitter
        """
        effective_ttl = ttl or self.default_ttl
        if self.use_jitter:
            return get_ttl_with_jitter(effective_ttl)
        return effective_ttl

    async def get(
        self,
        identifier: str,
        params: dict[str, Any] | None = None,
    ) -> T | None:
        """
        Get cached value, deserialize to Pydantic model if configured
        """
        try:
            key = self._build_key(identifier, params)
            data = await self.redis.get(key)

            if data is None:
                return None

            if self.model:
                return self.model.model_validate_json(data)

            return json.loads(data) if isinstance(data, str) else data

        except Exception as e:
            logger.warning(f"Cache get failed for {identifier}: {e}")
            return None

    async def set(
        self,
        identifier: str,
        value: T | dict[str, Any] | str,
        ttl: int | None = None,
        params: dict[str, Any] | None = None,
    ) -> bool:
        """
        Set cached value with automatic serialization
        """
        try:
            key = self._build_key(identifier, params)
            effective_ttl = self._g
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `get_or_set` method in the `CacheService` class implements a factory method pattern. It checks if an item exists in the cache and, if not, retrieves it via a provided factory function.

- **Implementation**: The `get_or_set` method takes a `factory` parameter which is a callable that returns an `awaitable` object of type `T`. If the cached value does not exist, it calls this factory to get the data, caches it, and then returns the result.
  
  ```python
  async def get_or_set(
      self,
      identifier: str,
      factory: Callable[[], Awaitable[T]],
      ttl: int | None = None,
      params: dict[str, Any] | None = None,
  ) -> T:
      cached = await self.get(identifier, params)
      if cached is not None:
          return cached

      value = await factory()
      await
  ```

- **Benefits**: This pattern allows for lazy loading and caching of data. It ensures that the data is only fetched from the database or other sources when necessary, reducing unnecessary calls and improving performance.

- **Deviations**: The method does not explicitly return the result after calling `await factory()`, which might be a typo or an oversight in the code snippet provided.

- **Appropriateness**: This pattern is appropriate when you need to cache data but also want to ensure that the cached value is up-to-date. It's particularly useful in scenarios where fetching data can be expensive, and you want to avoid redundant calls to the factory function.

---

*Generated by CodeWorm on 2026-02-26 10:46*
