# repository_pattern

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/social/services/friendship_ops.py
**Language:** python
**Lines:** 1-515
**Complexity:** 0.0

---

## Source Code

```python
"""
Friendship Service Operations
/api/domains/social/services/friendship_ops.py
"""

from __future__ import annotations

from bson import ObjectId
from datetime import datetime, UTC, timedelta

from api.core.validation.exceptions import NotFoundError
from api.domains.account.models.User import User

from ..types import (
    FriendUserDict,
    PendingRequestDict,
    SentRequestDict,
    SearchUserDict,
)
from ..models.Friendship import Friendship, FriendshipStatus
from api.websockets.social.service import SocialSocketService


class FriendshipService:
    """
    Service class for friendship operations
    """
    @staticmethod
    def send_friend_request(
        requester_id: str | ObjectId,
        recipient_id: str | ObjectId,
        existing_friendship_id: str | ObjectId | None = None
    ) -> Friendship:
        """
        Create a new friend request or reuse existing rejected one
        """
        requester_id = ObjectId(requester_id) if isinstance(
            requester_id,
            str
        ) else requester_id
        recipient_id = ObjectId(recipient_id) if isinstance(
            recipient_id,
            str
        ) else recipient_id

        if existing_friendship_id is not None:
            existing_friendship_id = ObjectId(existing_friendship_id
                                              ) if isinstance(
                                                  existing_friendship_id,
                                                  str
                                              ) else existing_friendship_id

            friendship = Friendship.objects(id = existing_friendship_id
                                            ).first()
            if friendship:
                friendship.update(
                    set__status = FriendshipStatus.PENDING.value,
                    set__createdAt = datetime.now(UTC)
                )
                friendship.reload()

                requester = User.objects(
                    id = requester_id
                ).only("username",
                       "level",
                       "currentAvatar",
                       "nameColor").first()

                if requester:
                    SocialSocketService.emit_friend_request_received(
                        friendship_id = str(friendship.id),
                        requester_id = str(requester_id),
                        requester_username = requester.username,
                        requester_level = requester.level,
                        requester_avatar = str(requester.currentAvatar)
                        if requester.currentAvatar else None,
                        requester_name_color = requester.nameColor,
                        recipient_id = str(recipient_id),
                        created_at = friendship.createdAt
                    )

                return friendship

        friendship = Friendship(
            requesterUserId = requester_id,
            recipientUserId = recipient_id,
 
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used: Repository Pattern**

The `FriendshipService` class in the provided code implements a simplified version of the **Repository Pattern**, which abstracts data access operations and encapsulates business logic related to data retrieval and manipulation.

#### Implementation Details:
- The `send_friend_request` and `accept_friend_request` methods use PyMongo's `objects` method to query, update, and save `Friendship` documents. These methods handle the creation, updating, and acceptance of friend requests.
- The `User` model is used to fetch user details based on their IDs.

#### Benefits:
1. **Encapsulation**: Data access logic (e.g., querying MongoDB) is encapsulated within the service class, making it easier to manage and test.
2. **Separation of Concerns**: Business logic related to friend requests is separated from data access logic, improving code organization and maintainability.
3. **Flexibility**: The pattern allows for easy switching between different storage mechanisms or databases.

#### Deviations:
- The `Repository Pattern` typically involves a dedicated repository class that handles all data operations. Here, the service class directly interacts with MongoDB using PyMongo methods.
- The pattern is not fully adhered to since there are no separate repository classes; instead, the service class performs both business logic and data access.

#### Appropriateness:
This pattern is appropriate for small-scale applications or when a full-fledged repository layer is not necessary. However, in larger systems, it might be beneficial to introduce dedicated repository classes for better separation of concerns and testability.

---

*Generated by CodeWorm on 2026-02-23 13:26*
