# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/siem-dashboard/backend/app/controllers/rule_ctrl.py
**Language:** python
**Lines:** 1-119
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2026
rule_ctrl.py
"""

from typing import Any
from datetime import datetime, timedelta, UTC

from flask import g

from app.engine.correlation import (
    CorrelationState,
    evaluate_rule,
)
from app.models.CorrelationRule import CorrelationRule
from app.models.LogEvent import LogEvent


def list_rules() -> list[Any]:
    """
    Return all correlation rules
    """
    return list(CorrelationRule.objects.order_by("-created_at"))  # type: ignore[no-untyped-call]


def get_rule(rule_id: str) -> CorrelationRule:
    """
    Return a single correlation rule by ID
    """
    return CorrelationRule.get_by_id(rule_id)


def create_rule() -> CorrelationRule:
    """
    Create a new correlation rule from validated request data
    """
    data = g.validated
    rule = CorrelationRule(
        name=data.name,
        description=data.description,
        rule_type=data.rule_type,
        conditions=data.conditions,
        severity=data.severity,
        enabled=data.enabled,
        mitre_tactic=data.mitre_tactic,
        mitre_technique=data.mitre_technique,
    )
    rule.save()  # type: ignore[no-untyped-call]
    return rule


def update_rule(rule_id: str) -> CorrelationRule:
    """
    Partially update an existing correlation rule
    """
    data = g.validated
    rule = CorrelationRule.get_by_id(rule_id)
    updates = data.model_dump(exclude_none=True)
    for field_name, value in updates.items():
        setattr(rule, field_name, value)
    rule.save()  # type: ignore[no-untyped-call]
    return rule


def delete_rule(rule_id: str) -> dict[str, Any]:
    """
    Delete a correlation rule by ID
    """
    rule = CorrelationRule.get_by_id(rule_id)
    rule.delete()  # type: ignore[no-untyped-call]
    return {"deleted": True}


def test_rule(rule_id: str) -> dict[str, Any]:
    """
    Simulate a rule against historical log events and return matches
    """
    data = g.validated
    rule = CorrelationRule.get_by_id(rule_id)

    cutoff = datetime.now(UTC).replace(
        second=0, microsecond=0,
    )
    since = cutoff - timedelta(hours=data.hours)

    events = LogEvent.objects(timestamp__gte=since).order_by("timestamp")  # type: ignore[no-untyped-call]

    state = CorrelationState()
    alerts_fired: list[dict[str, Any]] = []

    for event in events:
        event_data = {
            "id": str(event.id),
            "timestamp": str(event.timestamp),
            "source_type": event.source_type,
            "severity": event.severity,
            "event_type": event.event_type,
            "source_ip": event.source_ip,
            "dest_ip": event.dest_ip,
            "hostname": event.hostname,
            "username": event.username,
        }

        result = evaluate_rule(rule, event_data, state)
        if result:
            alerts_fired.append({
                "group_value": result.group_value,
                "matched_event_count": len(result.matched_event_ids),
                "matched_event_ids": result.ma
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

**Implementation:**
The `rule_ctrl.py` file implements a repository pattern by encapsulating data access logic within methods like `list_rules`, `get_rule`, `create_rule`, `update_rule`, and `delete_rule`. These methods interact with the database through models (`CorrelationRule`), providing a clean separation between business logic and persistence.

**Benefits:**
- **Encapsulation:** The repository pattern abstracts data access, making it easier to switch databases or storage mechanisms.
- **Testability:** Methods are isolated, allowing for easy unit testing without real database interactions.
- **Maintainability:** Changes in how data is stored can be made centrally within the repository implementation.

**Deviations:**
- The methods do not return `CorrelationRule` instances directly but rather use type hints (`list[Any]`, `dict[str, Any]`). This could lead to potential issues if the types are not correctly managed.
- The `evaluate_rule` function is called within the `test_rule` method, which might be better abstracted into a separate service layer for more complex logic.

**Appropriateness:**
This pattern is appropriate in this context as it provides clear separation of concerns and enhances maintainability. However, if the business logic becomes more complex, introducing a service layer could further improve the design by separating data access from rule evaluation.

---

*Generated by CodeWorm on 2026-02-19 01:17*
