# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/app/auth/repository.py
**Language:** python
**Lines:** 1-179
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
repository.py
"""

from uuid import UUID
from datetime import UTC, datetime

from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from .RefreshToken import RefreshToken
from core.base_repository import BaseRepository


class RefreshTokenRepository(BaseRepository[RefreshToken]):
    """
    Repository for RefreshToken model database operations
    """
    model = RefreshToken

    @classmethod
    async def get_by_hash(
        cls,
        session: AsyncSession,
        token_hash: str,
    ) -> RefreshToken | None:
        """
        Get refresh token by its hash
        """
        result = await session.execute(
            select(RefreshToken).where(
                RefreshToken.token_hash == token_hash
            )
        )
        return result.scalars().first()

    @classmethod
    async def get_valid_by_hash(
        cls,
        session: AsyncSession,
        token_hash: str,
    ) -> RefreshToken | None:
        """
        Get valid (not revoked, not expired) refresh token by hash
        """
        result = await session.execute(
            select(RefreshToken).where(
                RefreshToken.token_hash == token_hash,
                RefreshToken.is_revoked == False,
                RefreshToken.expires_at > datetime.now(UTC),
            )
        )
        return result.scalars().first()

    @classmethod
    async def create_token(
        cls,
        session: AsyncSession,
        user_id: UUID,
        token_hash: str,
        family_id: UUID,
        expires_at: datetime,
        device_id: str | None = None,
        device_name: str | None = None,
        ip_address: str | None = None,
    ) -> RefreshToken:
        """
        Create a new refresh token
        """
        token = RefreshToken(
            user_id = user_id,
            token_hash = token_hash,
            family_id = family_id,
            expires_at = expires_at,
            device_id = device_id,
            device_name = device_name,
            ip_address = ip_address,
        )
        session.add(token)
        await session.flush()
        await session.refresh(token)
        return token

    @classmethod
    async def revoke_token(
        cls,
        session: AsyncSession,
        token: RefreshToken,
    ) -> RefreshToken:
        """
        Revoke a single token
        """
        token.revoke()
        await session.flush()
        await session.refresh(token)
        return token

    @classmethod
    async def revoke_family(
        cls,
        session: AsyncSession,
        family_id: UUID,
    ) -> int:
        """
        Revoke all tokens in a family (for replay attack response)

        Returns count of revoked tokens
        """
        result = await session.execute(
            update(RefreshToken).where(
                RefreshToken.family_id == family_id,
                RefreshToken.is_revoked == False,
            ).values(is_revoked = True,
                     
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used: Repository Pattern**

The `RefreshTokenRepository` class implements the **Repository Pattern**, which abstracts data access operations, providing a clean interface for business logic to interact with data storage.

#### Implementation Details:
- The class inherits from `BaseRepository`, likely defining common CRUD operations.
- Methods like `get_by_hash`, `create_token`, and `revoke_token` handle specific database interactions such as querying, creating, and updating tokens.
- The use of SQLAlchemy for ORM operations ensures type safety and reduces boilerplate code.

#### Benefits:
1. **Encapsulation**: Business logic is separated from data access, making the codebase more maintainable.
2. **Testability**: Repository methods can be easily tested in isolation without needing a database connection.
3. **Flexibility**: Easier to switch between different storage backends by changing the repository implementation.

#### Deviations:
- The class uses `@classmethod` for all methods, indicating it operates on the class rather than instances (Singleton-like behavior).
- Methods like `revoke_family` and `revoke_all_user_tokens` return a count of affected rows, which is not typical in the standard Repository Pattern but useful for logging or auditing.

#### Appropriateness:
This pattern is highly appropriate for this scenario where data access operations are complex and need to be abstracted. It ensures that business logic remains clean and focused on application tasks rather than database interactions. The use of SQLAlchemy further enhances its suitability by providing robust ORM capabilities.

---

*Generated by CodeWorm on 2026-02-19 22:08*
