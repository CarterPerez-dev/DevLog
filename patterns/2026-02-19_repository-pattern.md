# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/app/user/repository.py
**Language:** python
**Lines:** 1-112
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
repository.py
"""
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from config import UserRole
from .User import User
from core.base_repository import BaseRepository


class UserRepository(BaseRepository[User]):
    """
    Repository for User model database operations
    """
    model = User

    @classmethod
    async def get_by_email(
        cls,
        session: AsyncSession,
        email: str,
    ) -> User | None:
        """
        Get user by email address
        """
        result = await session.execute(
            select(User).where(User.email == email)
        )
        return result.scalars().first()

    @classmethod
    async def get_by_id(
        cls,
        session: AsyncSession,
        id: UUID,
    ) -> User | None:
        """
        Get user by ID
        """
        return await session.get(User, id)

    @classmethod
    async def email_exists(
        cls,
        session: AsyncSession,
        email: str,
    ) -> bool:
        """
        Check if email is already registered
        """
        result = await session.execute(
            select(User.id).where(User.email == email)
        )
        return result.scalars().first() is not None

    @classmethod
    async def create_user(
        cls,
        session: AsyncSession,
        email: str,
        hashed_password: str,
        full_name: str | None = None,
        role: UserRole = UserRole.USER,
    ) -> User:
        """
        Create a new user
        """
        user = User(
            email = email,
            hashed_password = hashed_password,
            full_name = full_name,
            role = role,
        )
        session.add(user)
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def update_password(
        cls,
        session: AsyncSession,
        user: User,
        hashed_password: str,
    ) -> User:
        """
        Update user password and increment token version
        """
        user.hashed_password = hashed_password
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

    @classmethod
    async def increment_token_version(
        cls,
        session: AsyncSession,
        user: User,
    ) -> User:
        """
        Invalidate all user tokens
        """
        user.increment_token_version()
        await session.flush()
        await session.refresh(user)
        return user

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

The `UserRepository` class implements the **Repository Pattern**, which encapsulates data access logic for a specific entity (`User`). This implementation provides methods to perform CRUD operations, ensuring that database interactions are abstracted away from the business logic.

#### Implementation Details:
- The `get_by_email`, `get_by_id`, `email_exists`, `create_user`, and `update_password` methods handle common database operations.
- Each method is a class method (`@classmethod`) that takes an `AsyncSession` for database interaction, ensuring asynchronous operations are handled properly.

#### Benefits:
1. **Encapsulation:** The repository abstracts the database interactions, making the business logic cleaner and more testable.
2. **Decoupling:** It decouples the application from the data access layer, allowing changes in the database schema or storage mechanism without affecting the business logic.
3. **Consistency:** Ensures consistent behavior across different parts of the application.

#### Deviations:
- The `BaseRepository` class is not shown but assumed to provide common functionality like session handling and model mapping.
- Methods are implemented as class methods, which might be less flexible for unit testing compared to instance methods.

#### Appropriateness:
This pattern is highly appropriate in this context where the application needs to interact with a database. It provides a clear separation of concerns between data access and business logic, making the codebase easier to maintain and extend. However, if the repository needs to be used across multiple entities or requires more complex interactions, additional refactoring might be necessary.

---

*Generated by CodeWorm on 2026-02-19 20:38*
