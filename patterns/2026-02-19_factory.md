# factory

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/dns-lookup/dnslookup/resolver.py
**Language:** python
**Lines:** 1-403
**Complexity:** 0.0

---

## Source Code

```python
"""
ⒸAngelaMos | 2026
resolver.py

Async DNS resolution with record type support
"""

from __future__ import annotations

import asyncio
import time
from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any

import dns.asyncresolver
import dns.exception
import dns.message
import dns.name
import dns.query
import dns.rcode
import dns.rdatatype
import dns.resolver
import dns.reversename


class RecordType(StrEnum):
    """
    Supported DNS record types
    """
    A = "A"
    AAAA = "AAAA"
    MX = "MX"
    NS = "NS"
    TXT = "TXT"
    CNAME = "CNAME"
    SOA = "SOA"
    PTR = "PTR"


ALL_RECORD_TYPES = [
    RecordType.A,
    RecordType.AAAA,
    RecordType.MX,
    RecordType.NS,
    RecordType.TXT,
    RecordType.CNAME,
    RecordType.SOA,
]


@dataclass
class DNSRecord:
    """
    Represents a single DNS record
    """
    record_type: RecordType
    value: str
    ttl: int
    priority: int | None = None


@dataclass
class DNSResult:
    """
    Result of a DNS lookup
    """
    domain: str
    records: list[DNSRecord] = field(default_factory = list)
    errors: list[str] = field(default_factory = list)
    query_time_ms: float = 0.0
    nameserver: str | None = None


@dataclass
class TraceHop:
    """
    Represents a single hop in DNS resolution trace
    """
    zone: str
    server: str
    server_ip: str
    response: str
    is_authoritative: bool = False


@dataclass
class TraceResult:
    """
    Result of a DNS trace
    """
    domain: str
    hops: list[TraceHop] = field(default_factory = list)
    final_answer: str | None = None
    error: str | None = None


def create_resolver(
    nameserver: str | None = None,
    timeout: float = 5.0,
) -> dns.asyncresolver.Resolver:
    """
    Create a configured async DNS resolver
    """
    resolver = dns.asyncresolver.Resolver()
    resolver.timeout = timeout
    resolver.lifetime = timeout * 2

    if nameserver:
        resolver.nameservers = [nameserver]

    return resolver


def extract_record_value(rdata: Any,
                         record_type: RecordType
                         ) -> tuple[str,
                                    int | None]:
    """
    Extract value and priority from rdata based on record type
    """
    priority = None

    if record_type == RecordType.A or record_type == RecordType.AAAA:
        value = rdata.address
    elif record_type == RecordType.MX:
        value = str(rdata.exchange).rstrip(".")
        priority = rdata.preference
    elif record_type in (RecordType.NS,
                         RecordType.CNAME,
                         RecordType.PTR):
        value = str(rdata.target).rstrip(".")
    elif record_type == RecordType.TXT:
        value = rdata.to_text()
    elif record_type == RecordType.SOA:
        value = f"NS: {str(rdata.mname).rstrip('.')}, Serial: {rdata.serial}"
    else:
        value = rdata.to_text()

    return value, priority


async def query_record_type(
    domain: str,
    record_type
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `create_resolver` function in the provided code implements a factory method design pattern. It creates an instance of `dns.asyncresolver.Resolver` with specific configurations, such as nameserver and timeout settings.

#### Implementation:
- The `create_resolver` function takes optional parameters for `nameserver` and `timeout`, allowing flexible configuration.
- It configures the resolver by setting its `nameservers` and `lifetime`.
- This function returns a configured resolver instance, abstracting the complexity of DNS resolution setup.

#### Benefits:
1. **Flexibility:** The factory method allows creating resolvers with different configurations easily.
2. **Encapsulation:** It encapsulates the resolver creation logic, making it easier to manage and modify without changing client code.
3. **Reusability:** Configured resolvers can be reused across multiple queries.

#### Deviations:
- While the `create_resolver` function is a factory method, it does not follow the standard pattern of having a separate class or interface for creating objects. Instead, it's implemented as a standalone function within the same module.
- The function also handles exceptions and timeouts, which are part of the resolver’s functionality rather than just its creation.

#### Appropriate Use:
This pattern is appropriate when you need to create complex objects with specific configurations that may vary based on runtime conditions or external factors. It's particularly useful in scenarios where multiple configurations might be required without cluttering client code with setup logic.

---

*Generated by CodeWorm on 2026-02-19 09:12*
