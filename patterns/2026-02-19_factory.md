# factory

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/conftest.py
**Language:** python
**Lines:** 1-292
**Complexity:** 0.0

---

## Source Code

```python
"""
Â©AngelaMos | 2025
conftest.py

Test configuration, fixtures, and factories
"""

import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent / "app"))

import hashlib
import secrets
from datetime import (
    UTC,
    datetime,
    timedelta,
)
from uuid import uuid4
from collections.abc import AsyncIterator

import pytest
from httpx import (
    AsyncClient,
    ASGITransport,
)
import pytest_asyncio
from sqlalchemy.ext.asyncio import (
    AsyncSession,
    create_async_engine,
)
from sqlalchemy.pool import StaticPool

from core.security import (
    hash_password,
    create_access_token,
)
from config import UserRole
from core.database import get_db_session

from core.Base import Base
from user.User import User
from auth.RefreshToken import RefreshToken


@pytest_asyncio.fixture(scope = "session", loop_scope = "session")
async def test_engine():
    """
    Session scoped async engine with in memory SQLite
    StaticPool keeps single connection so DB persists
    """
    engine = create_async_engine(
        "sqlite+aiosqlite:///:memory:",
        poolclass = StaticPool,
        connect_args = {"check_same_thread": False},
        echo = False,
    )
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield engine
    await engine.dispose()


@pytest.fixture
async def db_session(test_engine) -> AsyncIterator[AsyncSession]:
    """
    Per test session with transaction rollback for isolation
    App commits become savepoints that rollback with test
    """
    async with test_engine.connect() as conn:
        await conn.begin()

        session = AsyncSession(
            bind = conn,
            expire_on_commit = False,
            join_transaction_mode = "create_savepoint",
        )

        yield session

        await session.close()
        await conn.rollback()


@pytest.fixture
async def client(db_session: AsyncSession) -> AsyncIterator[AsyncClient]:
    """
    Async HTTP client with DB session override
    """
    from factory import create_app

    app = create_app()

    async def override_get_db():
        yield db_session

    app.dependency_overrides[get_db_session] = override_get_db

    async with AsyncClient(
            transport = ASGITransport(app = app),
            base_url = "http://test",
    ) as ac:
        yield ac

    app.dependency_overrides.clear()


@pytest.fixture
def auth_headers(access_token: str) -> dict[str, str]:
    """
    Authorization headers for authenticated requests
    """
    return {"Authorization": f"Bearer {access_token}"}


@pytest.fixture
def admin_auth_headers(admin_access_token: str) -> dict[str, str]:
    """
    Authorization headers for admin requests
    """
    return {"Authorization": f"Bearer {admin_access_token}"}


class UserFactory:
    """
    Factory for creating test users
    """
    _counter = 0

    @classmethod
    async def create(
        cls,
        session: AsyncSession,
        *,
        email: s
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

In the provided code, the `UserFactory` and `RefreshTokenFactory` classes implement a **Factory Method** design pattern. These factories are responsible for creating instances of `User` and `RefreshToken` objects with specific configurations.

#### Implementation:
- The `UserFactory.create()` method generates users with default or custom attributes.
- Similarly, `RefreshTokenFactory.create()` creates refresh tokens linked to a user, with optional parameters like expiration and revocation status.

#### Benefits:
1. **Encapsulation:** The factories encapsulate the object creation logic, making it easier to manage and modify how objects are created without changing the client code.
2. **Flexibility:** These factories allow for easy customization of object attributes during creation, such as setting default passwords or roles.
3. **Testability:** They facilitate testing by providing controlled methods to generate test data.

#### Deviations:
- The `UserFactory` and `RefreshTokenFactory` are implemented as class methods rather than abstract factory classes, adhering more closely to the Factory Method pattern's intent but with a slight deviation from the classic implementation.
- There is no explicit interface or abstract base class defining the creation process, which is typical in the canonical Factory Method pattern.

#### Applicability:
This pattern is **appropriate** when you need controlled and customizable object creation processes. It is particularly useful in testing frameworks where consistent but configurable test data are required. However, for more complex scenarios involving multiple factories or inheritance hierarchies, a more generalized factory design might be necessary.

---

*Generated by CodeWorm on 2026-02-19 15:40*
