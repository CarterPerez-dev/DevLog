# repository_pattern

**Type:** Pattern Analysis
**Repository:** my-portfolio
**File:** v1/backend/app/experience/service.py
**Language:** python
**Lines:** 1-91
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
service.py
"""

from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

import config
from config import Language
from core.exceptions import ExperienceNotFound
from .repository import ExperienceRepository
from .schemas import (
    ExperienceBriefResponse,
    ExperienceListResponse,
    ExperienceResponse,
)


class ExperienceService:
    """
    Business logic for experience operations.
    """
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_id(self, experience_id: UUID) -> ExperienceResponse:
        """
        Get experience by ID.
        """
        experience = await ExperienceRepository.get_by_id(
            self.session,
            experience_id,
        )
        if not experience:
            raise ExperienceNotFound(str(experience_id))
        return ExperienceResponse.model_validate(experience)

    async def list_visible(
        self,
        language: Language,
        skip: int = config.PAGINATION_DEFAULT_SKIP,
        limit: int = config.PAGINATION_DEFAULT_LIMIT,
    ) -> ExperienceListResponse:
        """
        List visible experiences for a language.
        """
        experiences = await ExperienceRepository.get_visible_by_language(
            self.session,
            language,
            skip,
            limit,
        )
        total = await ExperienceRepository.count_visible_by_language(
            self.session,
            language,
        )
        return ExperienceListResponse(
            items = [ExperienceResponse.model_validate(e) for e in experiences],
            total = total,
            skip = skip,
            limit = limit,
        )

    async def list_current(
        self,
        language: Language,
    ) -> list[ExperienceResponse]:
        """
        List current (ongoing) positions for a language.
        """
        experiences = await ExperienceRepository.get_current_by_language(
            self.session,
            language,
        )
        return [ExperienceResponse.model_validate(e) for e in experiences]

    async def get_timeline(
        self,
        language: Language,
    ) -> list[ExperienceBriefResponse]:
        """
        Get brief experience data for timeline display.
        """
        experiences = await ExperienceRepository.get_visible_by_language(
            self.session,
            language,
        )
        return [ExperienceBriefResponse.model_validate(e) for e in experiences]

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

**Implementation:**
The `ExperienceService` class encapsulates business logic for managing experiences, delegating database operations to the `ExperienceRepository`. The repository methods handle fetching and listing experiences based on various criteria.

**Benefits:**
- **Separation of Concerns:** Business logic is separated from data access logic.
- **Testability:** Repository methods can be easily mocked or replaced during testing.
- **Flexibility:** Easier to change database technology without affecting the service layer.

**Deviations:**
- The `ExperienceService` class directly initializes with an `AsyncSession`, which could be abstracted further using dependency injection via a constructor parameter.
- The repository methods are called directly within the service methods, but there is no explicit interface or contract defined between them.

**Appropriateness:**
This pattern is appropriate for this context as it clearly separates business logic from data access and provides a clean interface for managing experiences. It is suitable when you need to abstract database operations and ensure that your business logic remains independent of the underlying storage mechanism. However, consider using dependency injection frameworks or libraries like FastAPI's `Depends` to manage session lifetimes more effectively in production environments.

---

*Generated by CodeWorm on 2026-02-28 13:33*
