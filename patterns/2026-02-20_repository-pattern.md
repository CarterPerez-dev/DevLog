# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/examples/minimal-production/backend/app/user/service.py
**Language:** python
**Lines:** 1-95
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
service.py
"""

from uuid import UUID
from sqlalchemy.ext.asyncio import (
    AsyncSession,
)

from core.exceptions import (
    EmailAlreadyExists,
    InvalidCredentials,
    UserNotFound,
)
from core.security import (
    hash_password,
    verify_password,
)
from .schemas import (
    UserCreate,
    UserResponse,
)
from .User import User
from .repository import UserRepository


class UserService:
    """
    Business logic for user operations
    """
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def create_user(
        self,
        user_data: UserCreate,
    ) -> UserResponse:
        """
        Register a new user
        """
        if await UserRepository.email_exists(self.session,
                                             user_data.email):
            raise EmailAlreadyExists(user_data.email)

        hashed = await hash_password(user_data.password)
        user = await UserRepository.create_user(
            self.session,
            email = user_data.email,
            hashed_password = hashed,
        )
        return UserResponse.model_validate(user)

    async def get_user_by_id(
        self,
        user_id: UUID,
    ) -> UserResponse:
        """
        Get user by ID
        """
        user = await UserRepository.get_by_id(self.session, user_id)
        if not user:
            raise UserNotFound(str(user_id))
        return UserResponse.model_validate(user)

    async def change_password(
        self,
        user: User,
        current_password: str,
        new_password: str,
    ) -> None:
        """
        Change user password
        """
        is_valid, _ = await verify_password(current_password, user.hashed_password)
        if not is_valid:
            raise InvalidCredentials()

        hashed = await hash_password(new_password)
        await UserRepository.update_password(self.session, user, hashed)

    async def deactivate_user(
        self,
        user: User,
    ) -> UserResponse:
        """
        Deactivate user account
        """
        updated = await UserRepository.update(
            self.session,
            user,
            is_active = False
        )
        return UserResponse.model_validate(updated)

```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Repository Pattern

**Implementation:**
The `UserService` class encapsulates business logic for user operations, delegating data access to the `UserRepository`. Methods like `create_user`, `get_user_by_id`, and `deactivate_user` interact with the repository through asynchronous methods. For example, `create_user` checks if an email already exists using `email_exists` from `UserRepository`.

**Benefits:**
- **Separation of Concerns:** The business logic is separated from data access concerns.
- **Testability:** Repository methods can be easily mocked or replaced for unit testing.
- **Flexibility:** Easier to switch between different database implementations.

**Deviations:**
- The `UserRepository` is not explicitly defined as a separate class; instead, its methods are called directly within the `UserService`.
- There's no explicit transaction management, which might be necessary in more complex scenarios involving multiple repository operations.

**Appropriateness:**
This pattern is appropriate for this context where the business logic and data access responsibilities are clearly separated. It provides a good balance between simplicity and maintainability, making it easier to manage and test user-related operations. However, if the application grows or requires more complex transactional behavior, additional patterns like Unit of Work might be considered.

---

*Generated by CodeWorm on 2026-02-20 21:24*
