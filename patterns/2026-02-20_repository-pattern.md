# repository_pattern

**Type:** Pattern Analysis
**Repository:** Cybersecurity-Projects
**File:** TEMPLATES/fullstack-template/backend/app/core/dependencies.py
**Language:** python
**Lines:** 1-147
**Complexity:** 0.0

---

## Source Code

```python
"""
â’¸AngelaMos | 2025
dependencies.py
"""

from __future__ import annotations

from typing import Annotated
from uuid import UUID

import jwt
from fastapi import Depends, Request
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession

from config import (
    API_PREFIX,
    TokenType,
    UserRole,
)
from .database import get_db_session
from .exceptions import (
    InactiveUser,
    PermissionDenied,
    TokenError,
    TokenRevokedError,
    UserNotFound,
)
from user.User import User
from .security import decode_access_token
from user.repository import UserRepository


oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl = f"{API_PREFIX}/auth/login",
    auto_error = True,
)

oauth2_scheme_optional = OAuth2PasswordBearer(
    tokenUrl = f"{API_PREFIX}/auth/login",
    auto_error = False,
)

DBSession = Annotated[AsyncSession, Depends(get_db_session)]


async def get_current_user(
    token: Annotated[str,
                     Depends(oauth2_scheme)],
    db: DBSession,
) -> User:
    """
    Validate access token and return current user
    """
    try:
        payload = decode_access_token(token)
    except jwt.InvalidTokenError as e:
        raise TokenError(message = str(e)) from e

    if payload.get("type") != TokenType.ACCESS.value:
        raise TokenError(message = "Invalid token type")

    user_id = UUID(payload["sub"])
    user = await UserRepository.get_by_id(db, user_id)

    if user is None:
        raise UserNotFound(identifier = str(user_id))

    if payload.get("token_version") != user.token_version:
        raise TokenRevokedError()

    return user


async def get_current_active_user(
    user: Annotated[User,
                    Depends(get_current_user)],
) -> User:
    """
    Ensure user is active
    """
    if not user.is_active:
        raise InactiveUser()
    return user


async def get_optional_user(
    token: Annotated[str | None,
                     Depends(oauth2_scheme_optional)],
    db: DBSession,
) -> User | None:
    """
    Return current user if authenticated, None otherwise
    """
    if token is None:
        return None

    try:
        payload = decode_access_token(token)
        if payload.get("type") != TokenType.ACCESS.value:
            return None
        user_id = UUID(payload["sub"])
        user = await UserRepository.get_by_id(db, user_id)
        if user and user.token_version == payload.get("token_version"):
            return user
    except (jwt.InvalidTokenError, ValueError):
        pass

    return None


class RequireRole:
    """
    Dependency class to check user role
    """
    def __init__(self, *allowed_roles: UserRole) -> None:
        self.allowed_roles = allowed_roles

    async def __call__(
        self,
        user: Annotated[User,
                        Depends(get_current_active_user)],
    ) -> User:
        if user.role not in self.allowed_roles:
            raise PermissionDenied(
                message =
               
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used: Repository Pattern**

The `dependencies.py` file implements the **Repository Pattern**, which abstracts data access operations behind a well-defined interface. This pattern is used in the `UserRepository` class, although it's not explicitly defined as such.

- **Implementation**: The `UserRepository.get_by_id()` method is called within the `get_current_user` and `get_optional_user` dependencies to fetch user data from the database.
  
- **Benefits**:
  - **Encapsulation**: Data access logic is encapsulated in the `UserRepository`, making it easier to change or replace the underlying storage mechanism without affecting other parts of the application.
  - **Testability**: The repository can be easily mocked during unit tests, allowing for more isolated testing.

- **Deviations**:
  - The pattern is not strictly adhered to as there's no explicit `UserRepository` class. Instead, the method calls are directly within dependency functions.
  - Dependency injection is used effectively with `Depends`, but the repository interface is implicit rather than explicit.

- **Appropriateness**: This pattern is highly appropriate in this context because it abstracts database operations and enhances maintainability. However, for a more robust implementation, defining an explicit `UserRepository` class would be beneficial.

### When to Use

This pattern is suitable when you need to manage data access across multiple parts of your application, ensuring that changes to the data layer do not affect other components. It's particularly useful in large applications where database interactions are frequent and complex.

---

*Generated by CodeWorm on 2026-02-20 00:20*
