# factory

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/content/qa/conftest.py
**Language:** python
**Lines:** 1-278
**Complexity:** 0.0

---

## Source Code

```python
"""
Content Domain Test Configuration
/api/domains/content/qa/conftest.py
"""

import contextlib
import pytest
from qa.conftest import (
    app,
    client,
    db,
    redis_client,
    audit_capture,
    api_client,
    valid_object_id,
    flask_g,
)

from qa.super_global.fixtures.database import (
    db_state_manager,
    isolated_db_test,
    seeded_db_test,
    db_transaction_test,
    db_performance_monitor,
)

from qa.super_global.fixtures.factories import (
    user_factory,
    achievement_factory,
)

from qa.account_qa.conftest import (
    comprehensive_user_factory,
    enhanced_auth_headers,
)


@pytest.fixture
def daily_question_factory(db_state_manager):
    """
    Factory for creating test daily questions
    """
    created_questions = []

    def _create_question(**kwargs):
        from api.domains.content.models.Daily import DailyQuestion

        count = len(created_questions)
        defaults = {
            'dayIndex':
            count + 1,
            'prompt':
            f'What is cybersecurity concept #{count + 1}?',
            'options': [
                f'Correct answer #{count + 1}',
                f'Wrong answer A #{count + 1}',
                f'Wrong answer B #{count + 1}',
                f'Wrong answer C #{count + 1}',
            ],
            'correctIndex':
            0,
            'explanation':
            f'This is the explanation for question #{count + 1} about cybersecurity.'
        }

        defaults.update(kwargs)

        question = DailyQuestion(**defaults)
        question.save()
        created_questions.append(question)

        return question

    yield _create_question

    for question in created_questions:
        with contextlib.suppress(Exception):
            question.delete()


@pytest.fixture
def daily_answer_factory(db_state_manager, user_factory):
    """
    Factory for creating test daily answers
    """
    created_answers = []

    def _create_answer(user = None, **kwargs):
        from api.domains.content.models.Daily import DailyAnswer
        from bson import ObjectId

        if not user:
            user = user_factory()

        count = len(created_answers)
        defaults = {
            'userId': user.id if hasattr(user,
                                         'id') else ObjectId(),
            'dayIndex': count + 1,
            'userAnswerIndex': 0,
            'isCorrect': True
        }

        defaults.update(kwargs)

        answer = DailyAnswer(**defaults)
        answer.save()
        created_answers.append(answer)

        return answer

    yield _create_answer

    for answer in created_answers:
        with contextlib.suppress(Exception):
            answer.delete()


@pytest.fixture
def content_test_data():
    """
    Test data for content domain scenarios
    """
    return {
        'valid_questions': [
            {
                'dayIndex':
                1,
                'prompt':
                'What is the primary purpose of encrypti
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `daily_question_factory` and `daily_answer_factory` fixtures in the provided code implement a factory method pattern. These factories are responsible for creating test data instances, such as `DailyQuestion` and `DailyAnswer`, with customizable parameters.

#### Implementation Details:
- **Factory Functions**: The `_create_question` and `_create_answer` functions within the `daily_question_factory` and `daily_answer_factory` fixtures serve as factory methods. They accept optional keyword arguments to customize the created instances.
- **Instance Management**: Each factory maintains a list of created instances (`created_questions` and `created_answers`) and ensures they are properly cleaned up after tests using context managers.

#### Benefits:
1. **Flexibility**: Allows for easy creation of test data with varying attributes, making it suitable for different testing scenarios.
2. **Encapsulation**: Hides the complexities of object instantiation and database interactions behind a simple interface.
3. **Test Isolation**: Ensures that each test starts with a clean state by managing the lifecycle of created instances.

#### Deviations:
- The factories use context managers (`contextlib.suppress`) to handle cleanup, which is a deviation from the standard pattern where cleanup might be more explicit or involve additional steps.
- The `db_state_manager` fixture is used to manage database states, adding an extra layer of abstraction and complexity not typically seen in basic factory implementations.

#### Appropriate Use:
This pattern is appropriate for test scenarios requiring dynamic creation and management of complex objects. It is particularly useful when dealing with nested or interdependent data structures like questions and answers, ensuring that tests can be isolated and controlled effectively.

---

*Generated by CodeWorm on 2026-02-23 17:58*
