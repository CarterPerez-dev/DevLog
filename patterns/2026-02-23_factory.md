# factory

**Type:** Pattern Analysis
**Repository:** CertGames-Core
**File:** backend/api/domains/tools/services/llm_ops.py
**Language:** python
**Lines:** 1-271
**Complexity:** 0.0

---

## Source Code

```python
"""
LLM Operations Service - Shared functionality for AI engines
/api/domains/tools/services/llm_ops.py
"""

import re
import time
import json
import logging
from typing import Any
from flask import current_app, g
from collections.abc import Generator

from api.core.validation.exceptions import (
    ServiceError,
    AIGenerationError,
)
from api.core.limiters.throttle_helpers import (
    update_ai_usage_log,
    get_streaming_error_generator,
)


logger = logging.getLogger(__name__)


class LLMOps:
    """
    Shared operations for LLM/AI services.
    """
    @staticmethod
    def get_client():
        """
        Get OpenAI client from Flask extensions.
        """
        return current_app.extensions.get('openai_client')

    @staticmethod
    def check_client_availability() -> Generator[str] | None:
        """
        Check if OpenAI client is available.
        """
        client = LLMOps.get_client()
        if not client:
            error_gen: Generator[str] = get_streaming_error_generator(
                "OpenAI client not available"
            )()
            return error_gen
        return None

    @staticmethod
    def extract_content_from_chunk(chunk: Any) -> str | None:
        """
        Extract content from OpenAI streaming chunk.
        API uses: chunk.choices[0].delta.content
        """
        try:
            if hasattr(chunk, "choices") and chunk.choices:
                choice = chunk.choices[0]
                if hasattr(choice,
                           "delta") and hasattr(choice.delta,
                                                "content"):
                    content: str | None = choice.delta.content
                    return content
        except (AttributeError, IndexError, TypeError):
            pass
        return None

    @staticmethod
    def create_chat_completion(
        messages: list[dict[str,
                            str]],
        model: str = "gpt-4o",
        max_tokens: int = 1500,
        temperature: float = 0.7,
        stream: bool = True,
        **kwargs
    ):
        """
        Create a chat completion with standard error handling and usage tracking
        """
        client = LLMOps.get_client()
        if not client:
            raise ServiceError("OpenAI client not available")

        if stream and 'stream_options' not in kwargs:
            kwargs['stream_options'] = {"include_usage": True}

        try:
            return client.chat.completions.create(
                messages = messages,
                model = model,
                max_tokens = max_tokens,
                temperature = temperature,
                stream = stream,
                **kwargs
            )
        except Exception as e:
            logger.error("OpenAI API error: %s", str(e))
            raise AIGenerationError(
                f"Failed to generate response: {str(e)}"
            ) from e

    @staticmethod
    def stream_response(response) -> Generator[str]:
        """
        St
```

---

## Pattern Analysis

### Pattern Analysis

**Pattern Used:** Factory Method

The `LLMOps` class in the provided code implements a **Factory Method** design pattern, which allows for the creation of objects without specifying the exact class of object that will be created.

- **Implementation**: The `get_client()` method acts as a factory to retrieve the OpenAI client from Flask extensions. This is a simplified form of the Factory Method where the client retrieval logic is encapsulated within this static method.
  
- **Benefits**:
  - **Decoupling**: It decouples the creation of the client object from its usage, making it easier to switch or mock the client in tests.
  - **Flexibility**: Allows for easy extension by adding new methods that return different types of clients if needed.

- **Deviations**:
  - The `get_client()` method is static and does not follow the typical Factory Method pattern where a factory class creates objects. Instead, it directly returns an object from the Flask extensions.
  - There are no other factory methods or classes in this code snippet that create different types of objects.

- **Appropriateness**:
  - This pattern is appropriate for scenarios where you need to abstract the creation process and ensure that specific instances (like the OpenAI client) are retrieved consistently throughout the application. However, if more complex object creation logic is needed, a full-fledged Factory Method or Abstract Factory pattern might be more suitable.

In summary, while the code snippet uses a simplified form of the Factory Method, it effectively abstracts the client retrieval process, making the code more maintainable and testable.

---

*Generated by CodeWorm on 2026-02-23 14:03*
