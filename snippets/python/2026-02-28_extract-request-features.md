# extract_request_features

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/core/features/extractor.py
**Language:** python
**Lines:** 41-105
**Complexity:** 10.0

---

## Source Code

```python
def extract_request_features(
    entry: ParsedLogEntry,
    country_code: str = "",
) -> dict[str, int | float | bool | str]:
    """
    Extract 23 stateless per-request features from a parsed log entry.
    """
    full_uri = entry.path
    if entry.query_string:
        full_uri = f"{entry.path}?{entry.query_string}"

    ua_lower = entry.user_agent.lower()
    non_alnum = sum(1 for c in entry.path if not c.isalnum())
    path_len = len(entry.path)

    _, ext = splitext(entry.path)

    return {
        "http_method":
        entry.method,
        "path_depth":
        len([s for s in entry.path.split("/") if s]),
        "path_entropy":
        _shannon_entropy(entry.path),
        "path_length":
        path_len,
        "query_string_length":
        len(entry.query_string),
        "query_param_count":
        (len(entry.query_string.split("&")) if entry.query_string else 0),
        "has_encoded_chars":
        bool(ENCODED_CHARS.search(full_uri)),
        "has_double_encoding":
        bool(DOUBLE_ENCODED.search(full_uri)),
        "status_code":
        entry.status_code,
        "status_class":
        f"{entry.status_code // 100}xx",
        "response_size":
        entry.response_size,
        "hour_of_day":
        entry.timestamp.hour,
        "day_of_week":
        entry.timestamp.weekday(),
        "is_weekend":
        entry.timestamp.weekday() >= 5,
        "ua_length":
        len(entry.user_agent),
        "ua_entropy":
        _shannon_entropy(entry.user_agent),
        "is_known_bot":
        any(sig in ua_lower for sig in BOT_USER_AGENTS),
        "is_known_scanner":
        any(sig in ua_lower for sig in SCANNER_USER_AGENTS),
        "has_attack_pattern":
        bool(ATTACK_COMBINED.search(full_uri)),
        "special_char_ratio":
        non_alnum / path_len if path_len else 0.0,
        "file_extension":
        ext,
        "country_code":
        country_code,
        "is_private_ip":
        _is_private_ip(entry.ip),
    }
```

---

## Documentation

### Documentation for `extract_request_features`

**Purpose and Behavior:**
The function `extract_request_features` processes a `ParsedLogEntry` object to extract 23 stateless features from HTTP requests, including metadata like HTTP method, path details, user agent information, timestamp, and response size. It returns these features as a dictionary.

**Key Implementation Details:**
- The function accepts a required `entry` parameter of type `ParsedLogEntry` and an optional `country_code`.
- It calculates various metrics such as path depth, entropy, special character ratio, and checks for known bots or scanners.
- Uses regular expressions to identify double encoding, encoded characters, and attack patterns.

**When/Why to Use:**
This function is ideal for threat detection systems where detailed HTTP request analysis is needed. It provides a comprehensive set of features that can be used in machine learning models to detect anomalies or malicious activities.

**Patterns/Gotchas:**
- The use of `_shannon_entropy` and regular expressions like `ENCODED_CHARS`, `DOUBLE_ENCODED`, and `ATTACK_COMBINED` are key but require these functions/variables to be defined elsewhere.
- The function assumes the presence of certain attributes in `ParsedLogEntry`, such as `method`, `path`, `query_string`, `user_agent`, `status_code`, `response_size`, `timestamp`, and `ip`.
- Handling of division by zero in calculating `special_char_ratio` is done gracefully, returning 0.0 when the path length is 0.

This function encapsulates complex feature extraction logic into a reusable component suitable for cybersecurity applications.

---

*Generated by CodeWorm on 2026-02-28 07:54*
