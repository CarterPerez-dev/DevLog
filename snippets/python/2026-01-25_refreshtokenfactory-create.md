# RefreshTokenFactory.create

**Repository:** my-portfolio
**File:** v1/backend/conftest.py
**Language:** python
**Lines:** 160-182
**Complexity:** 4.0

---

## Source Code

```python
async def create(
        cls,
        session: AsyncSession,
        user: User,
        *,
        is_revoked: bool = False,
        expires_delta: timedelta = timedelta(days = 7),
    ) -> tuple[RefreshToken,
               str]:
        raw_token = secrets.token_urlsafe(32)
        token_hash = hashlib.sha256(raw_token.encode()).hexdigest()

        token = RefreshToken(
            user_id = user.id,
            token_hash = token_hash,
            family_id = uuid4(),
            expires_at = datetime.now(UTC) + expires_delta,
            is_revoked = is_revoked,
        )
        session.add(token)
        await session.flush()
        await session.refresh(token)
        return token, raw_token
```

---

## Documentation

### Documentation for `create` Method

**Purpose and Behavior**
The `create` method is a class method that generates a new `RefreshToken` instance associated with a given user. It uses an asynchronous session to add the token to the database, ensuring it's flushed and refreshed before returning.

**Key Implementation Details**
- **Class Method**: Uses `@classmethod`, allowing it to be called on the class itself.
- **Session Management**: Utilizes an `AsyncSession` for database operations.
- **Token Generation**: Generates a secure URL-safe token using `secrets.token_urlsafe()`.
- **Hashing**: Hashes the raw token with SHA-256 and stores both the hash and the original token.
- **Expiry Calculation**: Sets the token's expiry time based on the current UTC datetime plus an optional delta.

**When/Why to Use This Code**
Use this method when you need to create a new refresh token for a user in your application. It ensures that tokens are securely generated, stored, and managed with proper expiration times.

**Patterns/Gotchas**
- **Security**: Always return the raw token as it contains sensitive information.
- **Session Management**: Ensure the session is properly closed or awaited after use to avoid leaks.
- **Concurrency**: As this method is asynchronous, ensure it's used in an appropriate context (e.g., within a coroutine).

---

*Generated by CodeWorm on 2026-01-25 17:22*
