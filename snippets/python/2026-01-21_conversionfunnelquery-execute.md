# ConversionFunnelQuery.execute

**Repository:** CertGames-Core
**File:** backend/api/admin/domains/revenue/queries.py
**Language:** python
**Lines:** 54-137
**Complexity:** 13.0

---

## Source Code

```python
def execute(self) -> dict[str, Any]:
        """
        Calculate funnel conversion rates
        """
        funnel_steps = [
            'signed_up',
            'completed_first_test',
            'used_50_questions',
            'viewed_pricing',
            'started_checkout',
            'completed_purchase'
        ]

        match_criteria: dict[str,
                             Any] = {
                                 'createdAt': {
                                     '$gte': self.start_date,
                                     '$lte': self.end_date
                                 }
                             }
        if self.platform:
            match_criteria['signUpSource'] = self.platform

        total_users = User.objects(__raw__ = match_criteria).count()

        metrics_match: dict[str, Any] = {}
        if self.platform:
            metrics_match['originalSignupSource'] = self.platform

        metrics = SubscriptionMetrics.objects(__raw__ = metrics_match)

        step_counts = {
            'signed_up': total_users,
            'completed_first_test': 0,
            'used_50_questions': 0,
            'viewed_pricing': 0,
            'started_checkout': 0,
            'completed_purchase': 0
        }

        for metric in metrics:
            if metric.funnelSteps:
                for step in funnel_steps[1 :]:
                    if step in metric.funnelSteps:
                        step_counts[step] += 1

        funnel_data = []
        for i, step in enumerate(funnel_steps):
            count = step_counts[step]
            rate = (count / total_users * 100) if total_users > 0 else 0

            drop_off = 0
            if i > 0:
                prev_count = step_counts[funnel_steps[i - 1]]
                if prev_count > 0:
                    drop_off = (prev_count - count) / prev_count * 100

            funnel_data.append(
                {
                    'step': step,
                    'count': count,
                    'conversion_rate': round(rate,
                                             2),
                    'drop_off_rate': round(drop_off,
                                           2)
                }
            )

        return {
            'total_users':
            total_users,
            'funnel_steps':
            funnel_data,
            'overall_conversion':
            round(
                (step_counts['completed_purchase'] / total_users *
                 100) if total_users > 0 else 0,
                2
            ),
            'period': {
                'start': self.start_date.isoformat(),
                'end': self.end_date.isoformat()
            }
        }
```

---

## Documentation

### Documentation for `execute` Method

**Purpose and Behavior:**
The `execute` method calculates the conversion rates through a user's journey in an application, from signing up to completing a purchase. It processes data from two collections: `User` and `SubscriptionMetrics`, filtering by date range and platform if specified.

**Key Implementation Details:**
- **Funnel Steps:** The steps are defined as a list of strings representing different stages of the user's journey.
- **Criteria Matching:** Filters for users and metrics are dynamically built based on provided start/end dates and optional platforms.
- **Step Counts Calculation:** Tracks how many users progress through each step in the funnel, excluding the first step (signed up).
- **Conversion Rates & Drop-off Rates:** Computes conversion rates and drop-off rates at each step, ensuring division by zero is handled gracefully.

**When/Why to Use:**
This method should be used when you need detailed insights into user engagement and conversion within a specific time period or platform. It's particularly useful for analytics and reporting purposes in applications with multi-step onboarding processes.

**Patterns & Gotchas:**
- **Dynamic Filtering:** The use of dynamic criteria matching allows flexibility but requires careful handling to avoid performance issues.
- **Division by Zero:** Ensure that the code handles cases where `total_users` is zero to prevent runtime errors.
- **Type Hints:** While not strictly necessary, type hints improve readability and maintainability.

---

*Generated by CodeWorm on 2026-01-21 00:10*
