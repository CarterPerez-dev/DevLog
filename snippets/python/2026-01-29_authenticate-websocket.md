# authenticate_websocket

**Repository:** vuemantics
**File:** backend/auth/dependencies.py
**Language:** python
**Lines:** 41-125
**Complexity:** 13.0

---

## Source Code

```python
async def authenticate_websocket(websocket: WebSocket) -> str | None:
    """
    Authenticate WebSocket connection via first message pattern

    Returns:
        User ID if authentication successful, None otherwise
    """
    origin = websocket.headers.get("origin", "")
    if origin and origin not in config.settings.cors_origins:
        logger.warning(f"WebSocket from unauthorized origin: {origin}")
        return None

    await websocket.accept()

    try:
        auth_data = await asyncio.wait_for(
            websocket.receive_json(),
            timeout = config.WEBSOCKET_AUTH_TIMEOUT
        )
    except TimeoutError:
        await websocket.send_json(
            AuthError(message = "Authentication timeout").model_dump()
        )
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_AUTH_TIMEOUT,
            reason = "Authentication timeout"
        )
        return None
    except WebSocketDisconnect:
        logger.debug(
            "WebSocket disconnected before auth (likely React StrictMode)"
        )
        return None
    except Exception as e:
        logger.error(f"Error receiving auth message: {e}")
        with contextlib.suppress(RuntimeError):
            await websocket.close(
                code = config.WEBSOCKET_CLOSE_INVALID_MESSAGE,
                reason = "Invalid message format"
            )
        return None

    if auth_data.get("type") != "auth" or not auth_data.get("token"):
        await websocket.send_json(
            AuthError(message = "Authentication required").model_dump()
        )
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_AUTH_REQUIRED,
            reason = "Authentication required"
        )
        return None

    try:
        payload = decode_token(
            auth_data["token"],
            expected_type = TokenType.ACCESS
        )

        user_id_raw = payload.get("sub")
        if not user_id_raw:
            raise AuthenticationError("Missing user ID in token")

        user_id: str = str(user_id_raw)
        user = await User.find_by_id(UUID(user_id))
        if not user or not user.is_active:
            raise AuthenticationError("User not found or inactive")

        token_version = payload.get("token_version", 0)
        if token_version != user.token_version:
            raise AuthenticationError("Token has been invalidated")

        await websocket.send_json(
            AuthSuccess(user_id = user_id).model_dump()
        )

        return user_id

    except AuthenticationError as e:
        logger.warning(f"WebSocket auth failed: {e}")
        await websocket.send_json(AuthError(message = str(e)).model_dump())
        await websocket.close(
            code = config.WEBSOCKET_CLOSE_INVALID_TOKEN,
            reason = "Invalid token"
        )
        return None
```

---

## Documentation

### Documentation for `authenticate_websocket`

**Purpose and Behavior:**
The function `authenticate_websocket` is designed to authenticate WebSocket connections by validating the first message received from a client. It checks the origin of the connection, accepts it if authorized, and then processes the authentication data. If successful, it returns the user ID; otherwise, it logs errors or sends appropriate error messages back to the client.

**Key Implementation Details:**
- **Origin Check:** Verifies that the WebSocket request comes from an allowed origin.
- **Timeout Handling:** Uses `asyncio.wait_for` to handle potential delays in receiving authentication data.
- **Error Handling:** Catches various exceptions, such as timeouts and invalid messages, logging errors appropriately.
- **Token Decoding:** Validates the token using a custom `decode_token` function, ensuring it matches user expectations.

**When/Why to Use:**
This code should be used whenever WebSocket connections need to be authenticated based on their initial message. It ensures secure and authorized communication by validating both the origin and the content of the first message.

**Patterns/Gotchas:**
- **Context Managers:** The `with contextlib.suppress` block is used to handle potential `RuntimeError` exceptions gracefully.
- **Type Checking:** Ensures that the received data contains valid authentication information, preventing unauthorized access.
- **Error Propagation:** Errors are logged and communicated back to the client, providing clear feedback on what went wrong.

---

*Generated by CodeWorm on 2026-01-29 10:32*
