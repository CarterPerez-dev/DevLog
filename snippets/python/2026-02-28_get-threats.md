# get_threats

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/ai-threat-detection/backend/app/services/threat_service.py
**Language:** python
**Lines:** 51-99
**Complexity:** 6.0

---

## Source Code

```python
async def get_threats(
    session: AsyncSession,
    limit: int = 50,
    offset: int = 0,
    severity: str | None = None,
    source_ip: str | None = None,
    since: datetime | None = None,
    until: datetime | None = None,
) -> ThreatListResponse:
    """
    Query threat events with optional filters, returning a paginated response.
    """
    query = select(ThreatEvent)
    count_query = select(func.count()).select_from(ThreatEvent)

    if severity:
        query = query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
        count_query = count_query.where(
            ThreatEvent.severity == severity.upper())  # type: ignore[arg-type]
    if source_ip:
        query = query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]
        count_query = count_query.where(
            ThreatEvent.source_ip == source_ip)  # type: ignore[arg-type]
    if since:
        query = query.where(ThreatEvent.created_at
                            >= since)  # type: ignore[arg-type]
        count_query = count_query.where(ThreatEvent.created_at
                                        >= since)  # type: ignore[arg-type]
    if until:
        query = query.where(ThreatEvent.created_at
                            <= until)  # type: ignore[arg-type]
        count_query = count_query.where(ThreatEvent.created_at
                                        <= until)  # type: ignore[arg-type]

    query = query.order_by(
        ThreatEvent.created_at.desc())  # type: ignore[attr-defined]
    query = query.offset(offset).limit(limit)

    total = (await session.execute(count_query)).scalar_one()
    rows = (await session.execute(query)).scalars().all()

    return ThreatListResponse(
        total=total,
        limit=limit,
        offset=offset,
        items=[_to_response(row) for row in rows],
    )
```

---

## Documentation

### Documentation for `get_threats` Function

**Purpose and Behavior:**
The `get_threats` function is an asynchronous method that queries a database for threat events, applying optional filters such as severity, source IP, and time range. It returns a paginated response containing the total count of matching threats and a list of threat items.

**Key Implementation Details:**
- **Parameters:** The function accepts several optional parameters to filter the query results (e.g., `severity`, `source_ip`, `since`, `until`), along with pagination controls (`limit`, `offset`).
- **Query Construction:** It constructs SQL queries using SQLAlchemy, applying filters conditionally based on provided arguments.
- **Pagination and Sorting:** The result set is paginated and sorted by the creation time of threat events in descending order.
- **Response Formatting:** The function returns a `ThreatListResponse` object containing the total count, limit, offset, and a list of threat items.

**When/Why to Use:**
Use this function when you need to retrieve a filtered and paginated list of threat events from your database. It is particularly useful for implementing search functionality in security monitoring applications where users can filter threats by severity, source IP, or time range.

**Patterns/Gotchas:**
- **Type Hints:** The use of type hints ensures that the function parameters are correctly typed.
- **SQLAlchemy Usage:** The function leverages SQLAlchemy for database queries, which requires proper setup and configuration. Ensure your database models (`ThreatEvent`) and session management are correctly implemented.
- **Filtering Logic:** The filtering logic is applied to both the main query and count query using `where` clauses, ensuring accurate pagination even with filters.

This function provides a flexible and efficient way to handle complex threat event queries in a cybersecurity application.

---

*Generated by CodeWorm on 2026-02-28 08:08*
