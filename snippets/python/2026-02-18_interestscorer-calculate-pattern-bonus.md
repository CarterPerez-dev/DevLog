# InterestScorer._calculate_pattern_bonus

**Type:** Documentation
**Repository:** CodeWorm
**File:** codeworm/analysis/scoring.py
**Language:** python
**Lines:** 208-240
**Complexity:** 11.0

---

## Source Code

```python
def _calculate_pattern_bonus(
        self,
        decorators: list[str] | None,
        is_async: bool,
        source: str,
    ) -> float:
        """
        Calculate bonus points for interesting code patterns
        """
        bonus = 0.0

        if is_async:
            bonus += self.PATTERN_BONUSES["async"]

        if decorators:
            bonus += len(decorators) * self.PATTERN_BONUSES["decorator"]

            decorator_text = " ".join(decorators).lower()
            if "property" in decorator_text:
                bonus += self.PATTERN_BONUSES["property"]
            if "classmethod" in decorator_text or "staticmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["class_method"]
            if "abstractmethod" in decorator_text:
                bonus += self.PATTERN_BONUSES["abstract"]
            if "dataclass" in decorator_text:
                bonus += self.PATTERN_BONUSES["dataclass"]

        if "yield" in source:
            bonus += self.PATTERN_BONUSES["generator"]
        if "__enter__" in source or "__exit__" in source:
            bonus += self.PATTERN_BONUSES["context_manager"]

        return bonus
```

---

## Documentation

### Documentation for `_calculate_pattern_bonus`

#### Purpose and Behavior
The function `InterestScorer._calculate_pattern_bonus` evaluates a piece of Python code based on specific patterns, such as async functions, decorators, generators, context managers, and data classes. It returns a bonus score indicating the presence of these patterns.

#### Key Implementation Details
- **Parameters**: 
  - `decorators`: A list of decorator names (or `None`).
  - `is_async`: A boolean indicating if the code is asynchronous.
  - `source`: The source code as a string.
- **Bonus Calculation**:
  - Adds points for each async function, decorators, and specific types of decorators like property, class methods, abstract methods, data classes, generators, context managers (`__enter__`/`__exit__`).
  - Points are adjusted based on the presence of certain keywords in the source code.

#### When/Why to Use
Use this function when you need to score or categorize Python code based on interesting patterns. It's particularly useful for static analysis tools, linters, or code review bots that aim to identify best practices and modern coding techniques.

#### Patterns and Gotchas
- **Type Hints**: The `decorators` parameter is annotated with a union of list[str] or None, indicating flexibility in input.
- **Trade-offs**: While this function effectively identifies patterns, it may not cover all edge cases. For instance, complex decorators might be missed if they don't contain specific keywords.
- **Context Managers**: The function checks for both `__enter__` and `__exit__`, ensuring comprehensive coverage of context manager usage.

This function is a good example of how to implement pattern recognition in Python code analysis tools using simple conditional logic and string manipulation.

---

*Generated by CodeWorm on 2026-02-18 09:14*
