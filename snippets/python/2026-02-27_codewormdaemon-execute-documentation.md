# CodeWormDaemon._execute_documentation_cycle

**Type:** Documentation
**Repository:** CodeWorm
**File:** codeworm/daemon.py
**Language:** python
**Lines:** 332-392
**Complexity:** 7.0

---

## Source Code

```python
async def _execute_documentation_cycle(self) -> None:
        """
        Execute one full documentation cycle
        Selects a random doc type, finds a target, generates, commits
        """
        backoff = self.stats.get_backoff_seconds()
        if backoff > 0:
            self.logger.info(
                "backing_off",
                seconds = backoff,
                consecutive_failures = self.stats.consecutive_failures,
            )
            await asyncio.sleep(backoff)

        self.logger.info(
            "cycle_starting",
            cycle_num = self.stats.total_cycles + 1
        )
        self._emit_event(
            "cycle_starting",
            {"cycle_num": self.stats.total_cycles + 1}
        )

        if not await self._ensure_ollama_ready():
            return

        target = await self._find_documentation_target()
        if not target:
            self.stats.record_skip("no_candidates")
            self.logger.warning(
                "cycle_skipped_no_candidates",
                repos_exhausted = list(self.stats.repos_exhausted),
            )
            self.stats.repos_exhausted.clear()
            next_run = self.scheduler.get_next_run_time()
            if next_run:
                self._emit_event("next_cycle", {"time": next_run.isoformat()})
            return

        self._emit_event(
            "analyzing",
            {
                "target": target.display_name,
                "doc_type": target.doc_type.value,
                "repo": target.snippet.repo,
            }
        )

        success = await self._document_target(target)
        if success:
            self.stats.record_success()
            self._log_cycle_stats()
            self._emit_stats()
        else:
            self.stats.record_failure("documentation_failed")

        self.analyzer.close_repos()

        next_run = self.scheduler.get_next_run_time()
        if next_run:
            self._emit_event("next_cycle", {"time": next_run.isoformat()})
```

---

## Documentation

### Documentation for `_execute_documentation_cycle`

**Purpose and Behavior:**
The function `CodeWormDaemon._execute_documentation_cycle` orchestrates a single cycle of documentation generation. It selects a random document type, finds a target, generates the documentation, and commits it if successful. The process involves backoff handling, event emission, and stats recording.

**Key Implementation Details:**
1. **Backoff Handling:** If there's a backoff period due to consecutive failures, the function waits before proceeding.
2. **Event Emission:** It logs events at key stages like cycle start, target analysis, and success/failure outcomes.
3. **Target Selection:** A target is chosen using `_find_documentation_target()`, and if no targets are found, it skips the cycle.
4. **Documentation Generation:** The function attempts to document the selected target with `_document_target(target)`.
5. **Stats Recording:** Success or failure stats are recorded, and relevant events are emitted.

**When/Why to Use:**
This code is crucial for automated documentation generation in systems like CodeWorm. It ensures that documentation cycles are managed efficiently, handling retries and backoffs appropriately. Use this function when setting up continuous integration pipelines or periodic documentation updates.

**Patterns and Gotchas:**
- **Asynchronous Handling:** The use of `asyncio.sleep` and other asynchronous operations is essential for managing delays and non-blocking behavior.
- **Event Emission:** Consistent event emission helps in tracking the lifecycle of each cycle, making debugging easier.
- **Stats Management:** Proper handling of stats ensures that performance metrics are accurately recorded, aiding in optimization.

---

*Generated by CodeWorm on 2026-02-27 21:46*
