# SSEHandler.do_GET

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/Aenebris/examples/websockets/sse_server.py
**Language:** python
**Lines:** 13-103
**Complexity:** 8.0

---

## Source Code

```python
def do_GET(self):
        if self.path == "/health":
            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            self.wfile.write(json.dumps({"status": "healthy"}).encode())
            return

        if self.path == "/events":
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.send_header("X-Accel-Buffering", "no")
            self.end_headers()

            print(f"[SSE] Client connected: {self.client_address}")

            try:
                event_id = 0
                while True:
                    event_id += 1
                    data = {
                        "id": event_id,
                        "timestamp": datetime.now().isoformat(),
                        "message": f"Event #{event_id}"
                    }

                    event = f"id: {event_id}\nevent: tick\ndata: {json.dumps(data)}\n\n"
                    self.wfile.write(event.encode())
                    self.wfile.flush()

                    print(f"[SSE] Sent event #{event_id}")
                    time.sleep(1)

            except (BrokenPipeError, ConnectionResetError):
                print(f"[SSE] Client {self.client_address} disconnected")
            return

        if self.path == "/stream/fast":
            self.send_response(200)
            self.send_header("Content-Type", "text/event-stream")
            self.send_header("Cache-Control", "no-cache")
            self.send_header("Connection", "keep-alive")
            self.end_headers()

            print(f"[SSE-FAST] Client connected: {self.client_address}")

            try:
                for i in range(100):
                    data = {"seq": i, "ts": datetime.now().isoformat()}
                    event = f"data: {json.dumps(data)}\n\n"
                    self.wfile.write(event.encode())
                    self.wfile.flush()
                    time.sleep(0.05)

                self.wfile.write(b"event: done\ndata: complete\n\n")
                self.wfile.flush()
                print(f"[SSE-FAST] Stream complete")

            except (BrokenPipeError, ConnectionResetError):
                print(f"[SSE-FAST] Client disconnected early")
            return

        self.send_response(200)
        self.send_header("Content-Type", "text/html")
        self.end_headers()
        html = """<!DOCTYPE html>
<html>
<head><title>SSE Test</title></head>
<body>
<h1>SSE Test Endpoints</h1>
<ul>
  <li><a href="/events">/events</a> - Continuous 1-second ticks</li>
  <li><a href="/stream/fast">/stream/fast</a> - Fast burst (100 events)</li>
  <li><a href="/health">/health</a> - Health check</li>
</ul>
<h2>Live Events:</h2>
<pre id="output"></pre>
<script>
const es = new EventSource('/events');
es.onmessage = (e) => {
  document.getElementById('output').textContent += e.data + '\\n';
};
es.addEventListener('tick', (e) => {
  document.getElementById('output').textContent += e.data + '\\n';
});
</script>
</body>
</html>"""
        self.wfile.write(html.encode())
```

---

## Documentation

### Documentation for `do_GET` Method in `SSEHandler`

**Purpose and Behavior:**
The `do_GET` method handles HTTP GET requests at different paths, responding with health checks, server-sent events (SSE), and a simple HTML page. It supports three endpoints:
- `/health`: Returns a JSON response indicating the service is healthy.
- `/events`: Provides continuous 1-second interval event streams.
- `/stream/fast`: Sends a fast burst of 100 events with a 5ms delay between each.

**Key Implementation Details:**
- Uses `self.send_response`, `send_header`, and `end_headers` to set HTTP response headers.
- Implements server-sent events (SSE) using the `wfile` for streaming data.
- Handles exceptions like `BrokenPipeError` and `ConnectionResetError` gracefully.

**When/Why to Use:**
This code is useful in scenarios where real-time updates are needed, such as monitoring systems or dashboards. The `/events` endpoint can be used for live event tracking, while the `/stream/fast` provides a quick burst of data for testing purposes.

**Patterns and Gotchas:**
- **Pattern:** The use of `try-except` blocks to handle connection errors ensures that the server doesn't crash on client disconnections.
- **Gotcha:** Ensure proper handling of `wfile.flush()` to avoid buffering issues, especially in long-running SSE streams.

---

*Generated by CodeWorm on 2026-01-17 17:02*
