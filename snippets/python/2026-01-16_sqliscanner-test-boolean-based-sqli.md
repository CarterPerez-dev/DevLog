# SQLiScanner._test_boolean_based_sqli

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/api-security-scanner/backend/scanners/sqli_scanner.py
**Language:** python
**Lines:** 141-214
**Complexity:** 15.0

---

## Source Code

```python
def _test_boolean_based_sqli(self) -> dict[str, Any]:
        """
        Test for boolean based blind SQL injection

        Compares responses from true vs false conditions to detect SQLi

        Returns:
            dict[str, Any]: Boolean based SQLi test results
        """
        try:
            baseline_response = self.make_request("GET", "/?id=1")
            baseline_length = len(baseline_response.text)
            baseline_status = baseline_response.status_code

            if baseline_status != 200:
                return {
                    "vulnerable": False,
                    "description": "Baseline request failed",
                    "baseline_status": baseline_status,
                }

            boolean_payloads = SQLiPayloads.BOOLEAN_BASED_BLIND
            true_payloads = [
                p for p in boolean_payloads
                if "AND '1'='1" in p or "AND 1=1" in p
            ]
            false_payloads = [
                p for p in boolean_payloads if "AND '1'='2" in p
                or "AND 1=2" in p or "AND 1=0" in p
            ]

            true_lengths = []
            for payload in true_payloads:
                response = self.make_request("GET", f"/?id={payload}")
                true_lengths.append(len(response.text))

            false_lengths = []
            for payload in false_payloads:
                response = self.make_request("GET", f"/?id={payload}")
                false_lengths.append(len(response.text))

            avg_true = statistics.mean(true_lengths)
            avg_false = statistics.mean(false_lengths)

            length_diff = abs(avg_true - avg_false)

            if length_diff > 100 and avg_true != avg_false:
                return {
                    "vulnerable":
                    True,
                    "baseline_length":
                    baseline_length,
                    "true_condition_avg_length":
                    avg_true,
                    "false_condition_avg_length":
                    avg_false,
                    "length_difference":
                    length_diff,
                    "confidence":
                    "HIGH" if length_diff > 500 else "MEDIUM",
                }

            return {
                "vulnerable": False,
                "description": "No boolean-based SQLi detected",
                "length_difference": length_diff,
            }

        except Exception as e:
            return {
                "vulnerable": False,
                "error": str(e),
                "description": "Error testing boolean-based SQLi",
            }
```

---

## Documentation

### Documentation for `_test_boolean_based_sqli` Method

**Purpose and Behavior:**
This method tests a web application for boolean-based blind SQL injection vulnerabilities by comparing response lengths from true and false conditions. It sends requests with payloads that contain SQL injection markers, measures the response lengths, and calculates the average differences to determine if the application is vulnerable.

**Key Implementation Details:**
- The function uses `statistics.mean` to calculate the average response length for both true and false conditions.
- It filters boolean-based payloads from a predefined list (`SQLiPayloads.BOOLEAN_BASED_BLIND`).
- Error handling is implemented using a try-except block, returning an error message if something goes wrong.

**When/Why to Use:**
This method should be used in security testing frameworks to identify potential SQL injection vulnerabilities. It's particularly useful for applications where direct data leakage might not occur but can still be exploited through boolean-based conditions.

**Patterns and Gotchas:**
- The function relies on comparing response lengths, which may not always accurately detect SQLi if the application uses caching or other optimizations.
- Ensure that the `SQLiPayloads` class is correctly defined elsewhere in your codebase to avoid issues.
- Be cautious with the threshold values (e.g., length difference > 100) as they might need adjustment based on the specific environment.

---

*Generated by CodeWorm on 2026-01-16 15:52*
