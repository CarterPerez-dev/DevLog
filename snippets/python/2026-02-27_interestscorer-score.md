# InterestScorer.score

**Type:** Documentation
**Repository:** CodeWorm
**File:** codeworm/analysis/scoring.py
**Language:** python
**Lines:** 148-206
**Complexity:** 2.0

---

## Source Code

```python
def score(
        self,
        metrics: ComplexityMetrics,
        git_stats: GitStats | None = None,
        decorators: list[str] | None = None,
        is_async: bool = False,
        source: str = "",
    ) -> InterestScore:
        """
        Calculate interest score for a function
        """
        if git_stats is None:
            git_stats = GitStats()

        complexity_score = min(
            metrics.cyclomatic_complexity / self.COMPLEXITY_CAP,
            1.0
        ) * 100
        length_score = min(metrics.nloc / self.LENGTH_CAP, 1.0) * 100
        nesting_score = min(
            metrics.max_nesting_depth / self.NESTING_CAP,
            1.0
        ) * 100
        param_score = min(metrics.parameter_count / self.PARAM_CAP, 1.0) * 100

        churn_score = min(git_stats.commit_count_30d / self.CHURN_CAP, 1.0) * 100

        days_old = git_stats.days_since_modified
        novelty_score = max(
            0,
            (self.NOVELTY_DAYS - days_old) / self.NOVELTY_DAYS
        ) * 100

        pattern_bonus = self._calculate_pattern_bonus(
            decorators,
            is_async,
            source
        )

        weighted_total = (
            complexity_score * self.WEIGHTS["complexity"] +
            length_score * self.WEIGHTS["length"] +
            nesting_score * self.WEIGHTS["nesting"] +
            param_score * self.WEIGHTS["parameters"] +
            churn_score * self.WEIGHTS["churn"] +
            novelty_score * self.WEIGHTS["novelty"] + pattern_bonus
        )

        return InterestScore(
            total = min(weighted_total,
                        100),
            complexity_score = complexity_score * self.WEIGHTS["complexity"],
            length_score = length_score * self.WEIGHTS["length"],
            nesting_score = nesting_score * self.WEIGHTS["nesting"],
            parameter_score = param_score * self.WEIGHTS["parameters"],
            churn_score = churn_score * self.WEIGHTS["churn"],
            novelty_score = novelty_score * self.WEIGHTS["novelty"],
            pattern_bonus = pattern_bonus,
        )
```

---

## Documentation

### Documentation for `score` Method in InterestScorer Class

**Purpose and Behavior:**
The `score` method calculates an interest score for a function based on various metrics such as cyclomatic complexity, line length, nesting depth, parameter count, recent commit activity, age of the code, and design patterns. It returns a detailed breakdown of scores along with a weighted total.

**Key Implementation Details:**
- **Metrics Handling:** The method accepts `ComplexityMetrics` and optionally `GitStats`, which are used to compute various score components.
- **Default Parameters:** `git_stats` is optional and defaults to an instance of `GitStats`. `decorators` and `is_async` are also optional, defaulting to `None` and `False`, respectively.
- **Score Calculation:** Each metric is normalized between 0 and 100 using predefined caps (`COMPLEXITY_CAP`, `LENGTH_CAP`, etc.). The scores are then weighted according to a dictionary of weights (`self.WEIGHTS`).
- **Pattern Bonus:** A bonus score is calculated based on the presence of specific design patterns, which can be provided via `decorators`.

**When/Why to Use:**
This method should be used when evaluating the maintainability and interest level of functions in large codebases. It helps prioritize refactoring or further investigation by highlighting problematic areas such as high complexity or recent changes.

**Patterns/Gotchas:**
- **Default Arguments:** The use of default arguments for `git_stats`, `decorators`, and `is_async` allows flexibility but requires careful handling to avoid unintended side effects.
- **Weighted Scores:** The weighted total ensures that no single metric dominates the score, providing a balanced evaluation.

---

*Generated by CodeWorm on 2026-02-27 22:00*
