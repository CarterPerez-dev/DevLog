# trace_dns

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/dns-lookup/dnslookup/resolver.py
**Language:** python
**Lines:** 255-386
**Complexity:** 24.0

---

## Source Code

```python
def trace_dns(domain: str, record_type: str = "A") -> TraceResult:
    """
    Trace DNS resolution path from root to authoritative servers
    """
    result = TraceResult(domain = domain)

    try:
        name = dns.name.from_text(domain)
        rdtype = dns.rdatatype.from_text(record_type)

        root_servers = [
            ("a.root-servers.net",
             "198.41.0.4"),
            ("b.root-servers.net",
             "170.247.170.2"),
            ("c.root-servers.net",
             "192.33.4.12"),
        ]

        current_servers = root_servers
        current_zone = "."

        while True:
            server_name, server_ip = current_servers[0]

            try:
                query = dns.message.make_query(name, rdtype)
                response = dns.query.udp(
                    query,
                    server_ip,
                    timeout = 3.0
                )

                rcode = response.rcode()

                if rcode != dns.rcode.NOERROR:
                    result.error = f"DNS error: {dns.rcode.to_text(rcode)}"
                    break

                if response.answer:
                    for rrset in response.answer:
                        for rdata in rrset:
                            result.final_answer = str(rdata)
                            break

                    result.hops.append(
                        TraceHop(
                            zone = current_zone,
                            server = server_name,
                            server_ip = server_ip,
                            response =
                            f"{record_type}: {result.final_answer}",
                            is_authoritative = True,
                        )
                    )
                    break

                if response.authority:
                    ns_records = []
                    for rrset in response.authority:
                        if rrset.rdtype == dns.rdatatype.NS:
                            for rdata in rrset:
                                ns_name = str(rdata.target
                                              ).rstrip(".")
                                ns_records.append(ns_name)
                            new_zone = str(rrset.name).rstrip(".")
                            if not new_zone:
                                new_zone = "."

                    if ns_records:
                        referral_msg = f"Referred to {new_zone or 'next'} servers"
                        result.hops.append(
                            TraceHop(
                                zone = current_zone,
                                server = server_name,
                                server_ip = server_ip,
                                response = referral_msg,
                            )
                        )

                        glue_ips = {}
                        if response.additional:
                            for rrset in response.additional:
                                if rrset.rdtype == dns.rdatatype.A:
                                    for rdata in rrset:
                                        glue_ips[str(
                                            rrset.name
                                        ).rstrip(".")] = rdata.address

                        new_servers = []
                        for ns in ns_records:
                            if ns in glue_ips:
                                new_servers.append((ns, glue_ips[ns]))
                            else:
                                try:
                                    answers = dns.resolver.resolve(
                                        ns,
                                        "A"
                                    )
                                    for rdata in answers:
                                        new_servers.append(
                                            (ns,
                                             rdata.address)
                                        )
                                        break
                                except dns.exception.DNSException:
                                    continue

                        if new_servers:
                            current_servers = new_servers
                            current_zone = new_zone
                        else:
                            result.error = "Could not resolve nameserver IPs"
                            break
                    else:
                        result.error = "No NS records in authority section"
                        break
                else:
                    result.error = "No answer or authority in response"
                    break

            except dns.exception.Timeout:
                result.error = f"Timeout querying {server_name}"
                break
            except dns.exception.DNSException as e:
                result.error = str(e)
                break

    except Exception as e:
        result.error = str(e)

    return result
```

---

## Documentation

### Documentation for `trace_dns` Function

**Purpose and Behavior:**
The `trace_dns` function traces the DNS resolution path from the root servers to authoritative servers for a given domain and record type (defaulting to "A"). It logs each hop, including server responses and errors. If successful, it returns the final answer; otherwise, it provides an error message.

**Key Implementation Details:**
- The function uses Python's `dnspython` library to send DNS queries.
- It iterates through a list of root servers, querying them in sequence until it finds authoritative servers or encounters an error.
- Error handling is robust, catching timeouts and other exceptions, and logging appropriate messages.

**When/Why to Use:**
Use this function when you need detailed tracing of DNS resolution paths for debugging or security analysis. It's particularly useful for understanding how DNS queries are resolved and identifying potential issues in the DNS infrastructure.

**Patterns/Gotchas:**
- The use of a `try-except` block ensures that all errors are caught and logged.
- The function relies on external libraries (`dnspython`) which must be installed separately.
- Performance can degrade with complex domain names or slow network conditions, as it queries multiple servers.

---

*Generated by CodeWorm on 2026-01-15 20:48*
