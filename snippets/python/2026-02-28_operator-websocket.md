# operator_websocket

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/c2-beacon/backend/app/ops/router.py
**Language:** python
**Lines:** 45-110
**Complexity:** 7.0

---

## Source Code

```python
async def operator_websocket(ws: WebSocket) -> None:
    """
    WebSocket endpoint for operator dashboard connections
    """
    ops_manager: OpsManager = ws.app.state.ops_manager
    registry: BeaconRegistry = ws.app.state.registry
    task_manager: TaskManager = ws.app.state.task_manager

    await ops_manager.connect(ws)

    try:
        async with get_db() as db:
            beacons = await registry.get_all(db)

        beacon_list = []
        for b in beacons:
            record = b.model_dump()
            record["active"] = registry.is_active(b.id)
            beacon_list.append(record)

        await ws.send_text(json.dumps({
            "type": "beacon_list",
            "payload": beacon_list,
        }))

        while True:
            raw = await ws.receive_text()
            data = json.loads(raw)

            if data.get("type") == "submit_task":
                payload = data["payload"]
                task = TaskRecord(
                    id = str(uuid.uuid4()),
                    beacon_id = payload["beacon_id"],
                    command = CommandType(payload["command"]),
                    args = payload.get("args"),
                )

                async with get_db() as db:
                    await task_manager.submit(task, db)

                await ws.send_text(
                    json.dumps(
                        {
                            "type": "task_submitted",
                            "payload": {
                                "local_id": payload.get("local_id"),
                                "task_id": task.id,
                            },
                        }
                    )
                )

                logger.info(
                    "Task %s (%s) submitted for beacon %s",
                    task.id,
                    task.command,
                    task.beacon_id,
                )

    except WebSocketDisconnect:
        pass
    except json.JSONDecodeError:
        logger.warning("Invalid JSON from operator")
    finally:
        ops_manager.disconnect(ws)
```

---

## Documentation

### Documentation for `operator_websocket`

**Purpose and Behavior:**
The `operator_websocket` function is an asynchronous WebSocket endpoint designed to handle connections from the operator dashboard. It connects to the `OpsManager`, retrieves beacon records, and processes task submissions.

**Key Implementation Details:**
- **Dependencies:** The function uses state objects (`ops_manager`, `registry`, `task_manager`) from the application context.
- **Database Interaction:** It interacts with a database using `get_db()` to fetch beacon records and submit tasks.
- **Error Handling:** It catches `WebSocketDisconnect` and `JSONDecodeError` exceptions, ensuring graceful disconnection and logging invalid JSON errors.
- **Logging:** Logs task submissions for debugging purposes.

**When/Why to Use:**
Use this code when implementing WebSocket functionality in a backend system that requires real-time communication between the operator dashboard and the server. It ensures secure and efficient handling of beacon records and task submissions, critical for maintaining operational control.

**Patterns/Gotchas:**
- **Asynchronous Context Management:** The use of `async with` for database connections is crucial to ensure proper resource management.
- **Error Handling:** Proper exception handling prevents crashes and logs errors effectively. Ensure logging configurations are in place for production environments.
- **JSON Decoding:** Validate JSON inputs to avoid runtime errors, especially under high load or malicious input scenarios.

---

*Generated by CodeWorm on 2026-02-28 16:02*
