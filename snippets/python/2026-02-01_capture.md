# capture

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/network-traffic-analyzer/src/netanal/main.py
**Language:** python
**Lines:** 94-190
**Complexity:** 7.0

---

## Source Code

```python
def capture(
    interface: Annotated[
        str | None,
        typer.Option(
            "--interface",
            "-i",
            help = "Network interface to capture on"
        ),
    ] = None,
    filter_expr: Annotated[
        str | None,
        typer.Option(
            "--filter",
            "-f",
            help = "BPF filter expression"
        ),
    ] = None,
    count: Annotated[
        int | None,
        typer.Option(
            "--count",
            "-c",
            help = "Number of packets to capture"
        ),
    ] = None,
    timeout: Annotated[
        float | None,
        typer.Option(
            "--timeout",
            "-t",
            help = "Capture timeout in seconds"
        ),
    ] = None,
    output: Annotated[
        Path | None,
        typer.Option(
            "--output",
            "-o",
            help = "Output file for results (JSON)"
        ),
    ] = None,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            help = "Show individual packets"
        ),
    ] = False,
) -> None:
    """
    [bold green]Capture[/bold green] live network packets

    Examples:
        anal capture -i eth0 --count 100
        anal capture --filter "tcp port 80" --timeout 30
        anal capture -i lo -c 50 --verbose
    """
    can_capture, msg = check_capture_permissions()
    if not can_capture:
        print_error(f"Cannot capture packets: {msg}")
        raise typer.Exit(1)

    if filter_expr and not validate_bpf_filter(filter_expr):
        print_error(f"Invalid BPF filter: {filter_expr}")
        raise typer.Exit(1)

    config = CaptureConfig(
        interface = interface,
        bpf_filter = filter_expr,
        packet_count = count,
        timeout_seconds = timeout,
    )

    packets_captured: list[PacketInfo] = []

    def on_packet(packet: PacketInfo) -> None:
        if verbose:
            print_packet(packet)
        if output:
            packets_captured.append(packet)

    console.print(f"[cyan]Starting capture on {interface or 'all interfaces'}...[/cyan]")
    console.print("[dim]Press Ctrl+C to stop[/dim]\n")

    engine = CaptureEngine(config = config, on_packet = on_packet if verbose or output else None)

    with GracefulCapture(engine) as cap:
        stats = cap.wait()

    console.print()
    print_capture_summary(stats)
    print_protocol_table(stats)
    print_top_talkers(stats)

    if output:
        export_to_json(stats, output, packets_captured)
        print_success(f"Results saved to {output}")
```

---

## Documentation

### Documentation for `capture` Function

**Purpose and Behavior:**
The `capture` function sets up a network packet capture using the `typer` library for command-line interface (CLI) options. It captures packets based on specified filters, counts, timeouts, and interfaces, then processes them according to verbose or output settings.

**Key Implementation Details:**
- **Options:** Accepts various CLI options like interface, filter expression, count, timeout, and output file.
- **Validation:** Validates BPF filters and packet capture permissions. Logs errors if validation fails.
- **Capture Engine:** Uses a `CaptureEngine` to handle packet capture logic, with an optional callback for handling packets.
- **Graceful Capture:** Utilizes a context manager (`GracefulCapture`) to manage the lifecycle of the packet capture process.

**When/Why to Use:**
This function is ideal for network traffic analysis where you need to capture and process live packets based on specific criteria. Itâ€™s particularly useful in cybersecurity or network monitoring scenarios requiring detailed packet inspection or bulk data collection.

**Patterns/Gotchas:**
- **Graceful Capture:** The use of `GracefulCapture` ensures clean termination, handling interruptions gracefully.
- **Error Handling:** Comprehensive error handling prevents the program from crashing and provides clear feedback to the user.
- **Performance Considerations:** Be mindful of packet count and timeout settings; excessive values can lead to performance issues.

---

*Generated by CodeWorm on 2026-02-01 09:26*
