# seed_domain

**Repository:** my-portfolio
**File:** v1/data/tools/seed.py
**Language:** python
**Lines:** 204-278
**Complexity:** 22.0

---

## Source Code

```python
async def seed_domain(
    session: AsyncSession,
    domain: str,
    dry_run: bool = False,
    clear: bool = False,
) -> tuple[int, int]:
    config = DOMAIN_CONFIG[domain]
    model = config["model"]
    files = scan_seed_files(domain)

    if not files:
        print(f"  {color('dim', 'No files found')}")
        return 0, 0

    if clear and not dry_run:
        await session.execute(delete(model))
        print(f"  {color('yellow', 'Cleared existing records')}")

    inserted = 0
    errors = 0

    for file_path, lang_code, is_array_file in files:
        try:
            with open(file_path) as f:
                raw_data = json.load(f)

            records = raw_data if is_array_file else [raw_data]

            for idx, data in enumerate(records):
                try:
                    if "language" not in data or data["language"] is None:
                        data["language"] = lang_code

                    transformed = transform_data(data, config)

                    if dry_run:
                        label = f"{file_path.name}[{idx}]" if is_array_file else file_path.name
                        print(f"  {color('blue', '○')} {label} (dry-run)")
                    else:
                        upsert_keys = config.get("upsert_keys", [])
                        if upsert_keys:
                            stmt = insert(model).values(**transformed)
                            update_cols = {
                                k: v for k, v in transformed.items()
                                if k not in upsert_keys and k != "id"
                            }
                            stmt = stmt.on_conflict_do_update(
                                index_elements=upsert_keys,
                                set_=update_cols,
                            )
                            await session.execute(stmt)
                        else:
                            record = model(**transformed)
                            session.add(record)

                    inserted += 1

                except TypeError as e:
                    label = f"{file_path.name}[{idx}]" if is_array_file else file_path.name
                    print(f"  {color('red', '✗')} {label}: Field error - {e}")
                    errors += 1

            if not dry_run and is_array_file:
                print(f"  {color('green', '✓')} {file_path.name} ({len(records)} records)")
            elif not dry_run:
                print(f"  {color('green', '✓')} {file_path.name}")

        except json.JSONDecodeError as e:
            print(f"  {color('red', '✗')} {file_path.name}: Invalid JSON - {e}")
            errors += 1
        except Exception as e:
            print(f"  {color('red', '✗')} {file_path.name}: {e}")
            errors += 1

    return inserted, errors
```

---

## Documentation

### Documentation for `seed_domain`

**Purpose and Behavior:**
The `seed_domain` function seeds a database with data from JSON files, handling file scanning, record insertion, and updates based on configuration settings. It supports dry runs and clearing existing records.

**Key Implementation Details:**
- **Parameters:** `session`, `domain`, `dry_run`, `clear`
- **Returns:** A tuple of `(inserted, errors)`
- **Steps:** 
  - Scans for seed files.
  - Clears existing records if specified and not in dry run mode.
  - Reads JSON data from files, transforms it, and inserts or updates records.
  - Handles exceptions for file reading, JSON decoding, and database operations.

**When/Why to Use:**
Use this function during initial setup or periodic data refreshes. It's ideal when you need to programmatically populate a database with structured data from external sources while maintaining flexibility in handling existing records.

**Patterns/Gotchas:**
- **Dry Run Mode:** Useful for testing without committing changes.
- **Error Handling:** Comprehensive error messages help trace issues back to specific files and lines.
- **Database Operations:** Uses SQLAlchemy's `on_conflict_do_update` for efficient upserts, but requires careful configuration of `upsert_keys`.

This function encapsulates complex database operations in a reusable and maintainable manner.

---

*Generated by CodeWorm on 2026-01-25 00:37*
