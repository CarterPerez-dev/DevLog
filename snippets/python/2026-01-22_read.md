# read

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/metadata-scrubber-tool/src/commands/read.py
**Language:** python
**Lines:** 24-62
**Complexity:** 10.0

---

## Source Code

```python
def read(
    file_path: Path = typer.Argument(
        exists=True,  # Must exist on the filesystem
        file_okay=True,  # Can be a file
        dir_okay=True,  # Can be a directory
        readable=True,  # Must be readable (permissions check)
        resolve_path=True,  # Auto-convert to absolute path
        help="The path to the file you want to process",
    ),
    recursive: bool = typer.Option(False, "--recursive", "-r", help="Recursively process files in the specified directory."),
    ext: str = typer.Option(None,"--extension", "-ext", help="The file extension to filter by. eg: jpg, png, pdf"),
):
    if recursive and not ext:
        raise typer.BadParameter("If you provide --recursive or -r, you must also provide --extension or -ext.")
    if ext and not recursive:
        raise typer.BadParameter("If you provide --extension or -ext, you must also provide --recursive or -r.")

    for file in get_target_files(file_path, ext) if recursive else [file_path]:
        try:
            # Get the correct object from the factory
            handler = MetadataFactory.get_handler(str(file))

            # Read
            console.print(f"üîé Reading [bold cyan]{file.name}[/bold cyan]...")
            current_data = handler.read()
            if log.isEnabledFor(logging.DEBUG):
                # if verbose mode is enabled, log the Info
                log.info(f"Successfully read metadata from {file.name}")
            print_metadata_table(current_data)

        except Exception as e:
            # display error in console
            console.print(f"‚ùå [bold red]Skipped[/bold red] [cyan]{file.name}[/cyan]: [dim]{e}[/dim]")

            # LOG: Full technical details (Stack trace) for you to debug

            if log.isEnabledFor(logging.DEBUG):
                # if verbose mode is enabled, log the traceback
                log.error(f"Failed to read metadata from {file}", exc_info=True)
```

---

## Documentation

### Documentation for `read` Function

**Purpose and Behavior:**
The `read` function processes files or directories based on command-line arguments, reading metadata from each file using a factory method pattern. It supports recursive processing and filtering by file extension.

**Key Implementation Details:**
- **Type Hints:** The function uses type hints for parameters like `file_path`, `recursive`, and `ext`.
- **Typer Arguments:** Command-line options are defined using the `typer` library, ensuring robust argument validation.
- **Error Handling:** It gracefully handles exceptions by logging detailed error messages and skipping problematic files.
- **Logging:** Logs both success and failure details, aiding in debugging.

**When/Why to Use This Code:**
Use this function when you need to read metadata from multiple files or directories recursively. The function ensures that only readable files are processed and supports filtering by file extension, making it versatile for various use cases in a metadata scrubbing tool.

**Patterns and Gotchas:**
- **Dependency on `typer`:** Ensure the `typer` library is installed if you plan to run this code from the command line.
- **Recursive Processing:** The function requires both recursive processing (`--recursive`) and file extension filtering (`--extension`) together, or neither. Misuse can lead to errors.
- **Logging:** The detailed logging mechanism helps in diagnosing issues but increases overhead; ensure it is enabled only when necessary.

This function exemplifies robust command-line argument handling and error management in Python, making it a reliable choice for file processing tasks.

---

*Generated by CodeWorm on 2026-01-22 11:25*
