# Batch.__call__

**Type:** Documentation
**Repository:** Telehook
**File:** src/telehook/middleware/batch.py
**Language:** python
**Lines:** 20-33
**Complexity:** 3.0

---

## Source Code

```python
async def __call__(self, message: Message, next_: SendFunc) -> None:
        self._next = next_
        self._buffer.append(message)

        if len(self._buffer) >= self._max_size:
            await self.flush()
            return

        if self._timer is None:
            loop = asyncio.get_running_loop()
            self._timer = loop.call_later(
                self._window,
                lambda: asyncio.ensure_future(self.flush()),
            )
```

---

## Documentation

### Documentation for `Batch.__call__`

**Purpose and Behavior:**
The `Batch.__call__` method processes incoming messages by buffering them until the buffer reaches a specified maximum size (`_max_size`). Once the buffer is full, it schedules a task to flush the buffer. If the buffer exceeds this size while a timer is already set, the existing timer is canceled before scheduling a new one.

**Key Implementation Details:**
- **Parameters:** 
  - `message`: The incoming message of type `Message`.
  - `next_`: A function reference for further processing.
- **Instance Variables:**
  - `_buffer`: Stores messages waiting to be processed.
  - `_max_size`: Maximum number of messages allowed in the buffer before flushing.
  - `_window`: Time window (in seconds) after which the buffer is flushed if not full.
  - `_timer`: A timer that schedules a flush operation.

**When/Why to Use:**
This code is useful for implementing batch processing where you need to accumulate a set number of messages or wait for a certain period before sending them. It ensures efficient handling of message streams by batching similar operations, which can be beneficial in scenarios like logging or notification systems.

**Patterns and Gotchas:**
- **Async/Await:** The method is asynchronous, making it suitable for I/O-bound tasks.
- **Timer Management:** Properly handle timer cancellation to avoid redundant flushes. Ensure that the `_timer` is reset before scheduling a new one if the buffer exceeds its size while a timer is already set.

This pattern helps in managing resource usage efficiently by batching similar operations and deferring them until necessary, which can be crucial for performance optimization in real-time systems.

---

*Generated by CodeWorm on 2026-02-28 19:59*
