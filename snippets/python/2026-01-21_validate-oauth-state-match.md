# validate_oauth_state_match

**Repository:** CertGames-Core
**File:** backend/api/domains/account/middleware/rules.py
**Language:** python
**Lines:** 103-187
**Complexity:** 27.0

---

## Source Code

```python
def validate_oauth_state_match(provider = None):
    """
    Validate OAuth state parameter for CSRF protection.
    """
    request_state = g.validated.get('state')

    if not request_state:
        raise ValidationError("State parameter is required")

    if provider == 'apple' or g.get('oauth_provider') == 'apple':
        valid_states = session.get('apple_valid_states', [])

        if not valid_states:
            raise AuthenticationError("No valid Apple states in session")

        current_time = datetime.now(UTC).timestamp()
        state_found = False

        if isinstance(valid_states[0], tuple):
            for state, timestamp in valid_states:
                if state == request_state:
                    if current_time - timestamp > 600:
                        raise AuthenticationError(
                            "Apple OAuth state expired (10 min limit)"
                        )
                    state_found = True
                    break

            if not state_found:
                raise AuthenticationError("Invalid Apple OAuth state")

            valid_states = [
                (s, t) for s, t in valid_states
                if s != request_state
            ]
        else:
            if request_state not in valid_states:
                raise AuthenticationError("Invalid Apple OAuth state")
            valid_states.remove(request_state)

        session['apple_valid_states'] = valid_states
    elif provider == 'google' or request.endpoint and 'google' in request.endpoint:
        valid_states = session.get('google_valid_states', [])

        if not valid_states:
            raise AuthenticationError("No valid Google states in session")

        current_time = datetime.now(UTC).timestamp()
        state_found = False

        if isinstance(valid_states[0], tuple):
            for state, timestamp in valid_states:
                if state == request_state:
                    if current_time - timestamp > 600:
                        raise AuthenticationError(
                            "Google OAuth state expired (10 min limit)"
                        )
                    state_found = True
                    break

            if not state_found:
                raise AuthenticationError("Invalid Google OAuth state")

            valid_states = [
                (s, t) for s, t in valid_states
                if s != request_state
            ]
        else:
            if request_state not in valid_states:
                raise AuthenticationError("Invalid Google OAuth state")
            valid_states.remove(request_state)

        session['google_valid_states'] = valid_states
    else:
        session_state = session.get('oauth_state')

        if not session_state:
            raise AuthenticationError("No OAuth state in session")

        if request_state != session_state:
            raise AuthenticationError(
                "Invalid OAuth state - CSRF protection"
            )

        session.pop('oauth_state', None)
```

---

## Documentation

### Documentation for `validate_oauth_state_match`

**Purpose and Behavior:**
The function `validate_oauth_state_match` ensures the security of OAuth state parameters by validating them against session data, preventing Cross-Site Request Forgery (CSRF) attacks. It checks if the provided state matches a valid state in the session and updates the session to remove used states.

**Key Implementation Details:**
- **Parameter Handling:** The function accepts an optional `provider` parameter which determines the type of OAuth validation.
- **State Validation Logic:** For Apple and Google providers, it checks both single-state and tuple-based (state, timestamp) formats. If a state is expired or invalid, it raises specific errors.
- **Session Management:** Valid states are updated in the session to reflect used states.

**When/Why to Use:**
This function should be used during OAuth authentication processes to ensure security by validating state parameters. It helps prevent CSRF attacks and ensures that only valid states are accepted.

**Patterns and Gotchas:**
- The code uses conditional logic based on provider types, which can make it harder to maintain if more providers are added.
- Handling of tuple-based states requires careful timestamp comparison to ensure expiration checks are accurate.
- The function assumes the presence of certain global variables (`g.validated`, `session`) and context objects (`request.endpoint`), which must be properly set up in the application.

---

*Generated by CodeWorm on 2026-01-21 13:36*
