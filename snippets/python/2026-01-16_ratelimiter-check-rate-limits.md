# RateLimiter._check_rate_limits

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/api-rate-limiter/src/fastapi_420/limiter.py
**Language:** python
**Lines:** 216-295
**Complexity:** 13.0

---

## Source Code

```python
async def _check_rate_limits(
        self,
        request: Request,
        rules: list[RateLimitRule],
        key_func: Callable[[Request],
                           str] | None = None,
        raise_on_limit: bool = True,
    ) -> RateLimitResult:
        """
        Check all rules and return/raise for the most restrictive failure
        """
        if not self._initialized:
            await self.init()

        storage = await self._get_active_storage()
        if storage is None:
            if self._settings.FAIL_OPEN:
                return RateLimitResult(
                    allowed = True,
                    limit = 0,
                    remaining = 0,
                    reset_after = 0,
                )
            raise StorageError(operation = "check", backend = None)

        fingerprint = await self._fingerprinter.extract(request)  # type: ignore[union-attr]
        endpoint = self._get_endpoint(request)

        if key_func:
            identifier = key_func(request)
        else:
            identifier = fingerprint.to_composite_key(
                self._settings.fingerprint.LEVEL
            )

        worst_result: RateLimitResult | None = None

        for rule in rules:
            key = RateLimitKey(
                prefix = self._settings.KEY_PREFIX,
                version = self._settings.KEY_VERSION,
                layer = Layer.USER,
                endpoint = endpoint,
                identifier = identifier,
                window = rule.window_seconds,
            ).build()

            result = await self._algorithm.check(  # type: ignore[union-attr]
                storage = storage,
                key = key,
                rule = rule,
            )

            if not result.allowed:  # noqa: SIM102
                if worst_result is None or result.retry_after > (worst_result.retry_after or 0):  # type: ignore[operator]
                    worst_result = result

        if worst_result is not None:
            if self._settings.LOG_VIOLATIONS:
                logger.warning(
                    "Rate limit exceeded",
                    extra = {
                        "endpoint": endpoint,
                        "identifier": identifier[: 16],
                        "remaining": worst_result.remaining,
                        "reset_after": worst_result.reset_after,
                    },
                )

            if raise_on_limit:
                raise EnhanceYourCalm(
                    result = worst_result,
                    message = self._settings.HTTP_420_MESSAGE,
                    detail = self._settings.HTTP_420_DETAIL,
                )

            return worst_result

        best_result = result
        return best_result
```

---

## Documentation

### Documentation for `RateLimiter._check_rate_limits`

**Purpose and Behavior:**
The `_check_rate_limits` method in the `RateLimiter` class checks rate limits against a list of rules for incoming requests. It returns or raises an exception based on the most restrictive limit encountered.

**Key Implementation Details:**
- **Initialization:** The method first initializes storage if not already initialized.
- **Storage Retrieval:** It retrieves active storage and handles cases where no storage is available.
- **Fingerprinting:** Uses a fingerprinter to generate a unique identifier for the request.
- **Rule Evaluation:** Iterates through each rule, building keys and checking against the rate limit algorithm. The most restrictive result is tracked.
- **Logging and Exception Handling:** Logs violations if configured and raises an `EnhanceYourCalm` exception when `raise_on_limit` is set to `True`.

**When/Why to Use:**
Use this method in FastAPI applications where you need robust rate limiting with customizable rules. It ensures that requests are handled according to predefined limits, enhancing security and preventing abuse.

**Patterns/Gotchas:**
- **Type Hints:** Proper use of type hints for parameters like `Request`, `RateLimitRule`, and `RateLimitResult`.
- **Async/Await:** The method is asynchronous, making it suitable for I/O-bound operations.
- **Customization:** Flexibility through optional `key_func` and `raise_on_limit` parameters allows customization based on specific use cases.

This implementation provides a flexible and robust rate limiting mechanism, ideal for API security.

---

*Generated by CodeWorm on 2026-01-16 04:42*
