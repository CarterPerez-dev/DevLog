# InsightsRepository.aggregate_by_length_range

**Repository:** angelamos-operations
**File:** CarterOS-Server/src/aspects/analytics/facets/insights/repository.py
**Language:** python
**Lines:** 303-347
**Complexity:** 6.0

---

## Source Code

```python
async def aggregate_by_length_range(
        cls, session: AsyncSession
    ) -> dict[str, dict]:
        """Aggregate performance by video length ranges"""
        videos = await cls.get_all_videos(session)

        range_stats = defaultdict(lambda: {
            "videos": [],
            "total_views": 0,
            "total_engagement": 0,
            "total_watch_percentage": 0,
        })

        for video in videos:
            seconds = cls.convert_length_to_seconds(video.length)
            range_label = cls.get_length_range_label(seconds)
            engagement_rate = cls.calculate_engagement_rate(video)

            range_stats[range_label]["videos"].append(video)
            range_stats[range_label]["total_views"] += video.views
            range_stats[range_label]["total_engagement"] += engagement_rate
            range_stats[range_label]["total_watch_percentage"] += video.watched_full_video_percentage

        # Calculate averages and add min/max seconds
        result = {}
        for range_label, stats in range_stats.items():
            count = len(stats["videos"])
            # Extract min/max from range label (e.g., "1:00-1:30" -> 60, 90)
            if range_label == "3:00+":
                min_sec, max_sec = 180, 999
            else:
                parts = range_label.split("-")
                min_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[0].split(":"))))
                max_sec = sum(int(x) * 60 ** i for i, x in enumerate(reversed(parts[1].split(":"))))

            result[range_label] = {
                "min_seconds": min_sec,
                "max_seconds": max_sec,
                "video_count": count,
                "avg_views": stats["total_views"] / count,
                "avg_engagement_rate": stats["total_engagement"] / count,
                "avg_watch_percentage": stats["total_watch_percentage"] / count,
            }

        return result
```

---

## Documentation

### Documentation for `aggregate_by_length_range`

**Purpose and Behavior**
The function `aggregate_by_length_range` in the `InsightsRepository` class aggregates video performance metrics by length ranges. It processes a list of videos, categorizes them into predefined length ranges, and calculates statistics such as total views, engagement rate, and watch percentage for each range.

**Key Implementation Details**
- **Input**: Takes an `AsyncSession` object to query the database.
- **Output**: Returns a dictionary where keys are length range labels (e.g., "1:00-1:30"), and values contain aggregated statistics.
- **Processing**: Uses `defaultdict` to accumulate video data by length ranges. It calculates average metrics for each range, including min and max seconds from the range label.

**When/Why to Use This Code**
Use this function when you need to analyze video performance based on their lengths. It helps in understanding how different duration videos perform differently in terms of views, engagement, and watch percentage.

**Patterns and Gotchas**
- The use of `defaultdict` simplifies accumulation logic but requires careful handling of default factory.
- Length ranges are dynamically calculated from string labels, which can lead to errors if the format is not consistent.
- Ensure that video attributes like `length`, `views`, and `watched_full_video_percentage` are correctly formatted and accessible.

---

*Generated by CodeWorm on 2026-01-31 16:22*
