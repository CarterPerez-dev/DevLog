# ScanService.run_scan

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/api-security-scanner/backend/services/scan_service.py
**Language:** python
**Lines:** 30-102
**Complexity:** 5.0

---

## Source Code

```python
def run_scan(db: Session, user_id: int, scan_request: ScanRequest) -> ScanResponse:
        """
        Execute security scan with selected tests

        Args:
            db: Database session
            user_id: User ID initiating the scan
            scan_request: Scan configuration and tests to run

        Returns:
            ScanResponse: Scan results with all test outcomes
        """
        scan = ScanRepository.create_scan(
            db=db,
            user_id=user_id,
            target_url=str(scan_request.target_url),
        )

        scanner_mapping: dict[TestType, type[BaseScanner]] = {
            TestType.RATE_LIMIT: RateLimitScanner,
            TestType.AUTH: AuthScanner,
            TestType.SQLI: SQLiScanner,
            TestType.IDOR: IDORScanner,
        }

        results: list[TestResultCreate] = []

        for test_type in scan_request.tests_to_run:
            scanner_class: type[BaseScanner] | None = scanner_mapping.get(test_type)

            if not scanner_class:
                continue

            try:
                scanner = scanner_class(
                    target_url=str(scan_request.target_url),
                    auth_token=scan_request.auth_token,
                    max_requests=scan_request.max_requests,
                )

                result = scanner.scan()
                results.append(result)

            except Exception as e:
                results.append(
                    TestResultCreate(
                        test_name=test_type,
                        status="error",
                        severity="info",
                        details=f"Scanner error: {str(e)}",
                        evidence_json={"error": str(e)},
                        recommendations_json=[
                            "Check target URL is accessible",
                            "Verify authentication token if provided",
                        ],
                    )
                )

        for result in results:
            TestResultRepository.create_test_result(
                db=db,
                scan_id=scan.id,
                test_name=result.test_name,
                status=result.status,
                severity=result.severity,
                details=result.details,
                evidence_json=result.evidence_json,
                recommendations_json=result.recommendations_json,
            )

        db.refresh(scan)

        return ScanResponse.model_validate(scan)
```

---

## Documentation

### Documentation for `run_scan` Function

**Purpose and Behavior**
The `run_scan` function in the `ScanService` class executes a security scan based on user-defined tests. It initializes scans, runs selected test types using appropriate scanners, logs results, and returns a structured response.

**Key Implementation Details**
- **Type Hints**: The function uses type hints for parameters and return values to ensure clarity.
- **Scanner Mapping**: A dictionary maps `TestType` enums to their corresponding scanner classes.
- **Exception Handling**: Each test execution is wrapped in a try-except block to handle errors gracefully, logging them as results.
- **Database Interaction**: Uses session-based database operations to create and update scan records.

**When/Why to Use This Code**
Use this function when you need to perform security scans on web applications. It allows for flexible configuration of tests and provides detailed error handling and logging mechanisms.

**Patterns and Gotchas**
- **Type Mapping**: The use of a dictionary to map test types to scanner classes is a clean way to handle different test cases.
- **Error Handling**: Graceful error handling ensures that even if one test fails, others can still be executed.
- **Database Operations**: Ensure the database session (`db`) is properly managed and closed after operations.

This function is ideal for integrating into larger security testing frameworks where flexibility in test selection and robust logging are crucial.

---

*Generated by CodeWorm on 2026-01-17 14:46*
