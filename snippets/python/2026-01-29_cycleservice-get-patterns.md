# CycleService.get_patterns

**Repository:** ios-test
**File:** fastapi/app/cycle/service.py
**Language:** python
**Lines:** 267-350
**Complexity:** 17.0

---

## Source Code

```python
async def get_patterns(self, user_id: UUID) -> CyclePattern:
        """
        Analyze historical patterns
        """
        partner = await PartnerRepository.get_by_user_id(self.session, user_id)
        if not partner:
            raise PartnerNotFound(str(user_id))

        period_logs = await PeriodLogRepository.get_actual_logs(
            self.session,
            partner.id,
            limit = 12,
        )

        cycle_lengths = [
            log.cycle_length for log in period_logs
            if log.cycle_length is not None
        ]

        if cycle_lengths:
            avg_cycle = sum(cycle_lengths) / len(cycle_lengths)
            cycle_range = (min(cycle_lengths), max(cycle_lengths))
        else:
            avg_cycle = float(partner.average_cycle_length)
            cycle_range = (partner.average_cycle_length, partner.average_cycle_length)

        period_lengths = []
        for log in period_logs:
            if log.end_date:
                length = (log.end_date - log.start_date).days + 1
                period_lengths.append(length)

        avg_period = (
            sum(period_lengths) / len(period_lengths)
            if period_lengths
            else float(partner.average_period_length)
        )

        daily_logs = await DailyLogRepository.get_by_partner_id(
            self.session,
            partner.id,
            limit = 90,
        )

        symptoms_by_phase: dict[str, list[str]] = defaultdict(list)
        mood_counts_by_phase: dict[str, dict[str, int]] = defaultdict(lambda: defaultdict(int))

        for log in daily_logs:
            if not partner.last_period_start:
                continue

            days_since = (log.log_date - partner.last_period_start).days + 1
            if days_since <= 0:
                continue

            cycle_day = ((days_since - 1) % partner.average_cycle_length) + 1
            phase = self._get_phase(cycle_day, partner.average_cycle_length)
            phase_key = phase.value

            for symptom in log.symptoms:
                if symptom not in symptoms_by_phase[phase_key]:
                    symptoms_by_phase[phase_key].append(symptom)

            if log.mood:
                mood_counts_by_phase[phase_key][log.mood.value] += 1

        common_symptoms = {
            phase: symptoms[:5] for phase, symptoms in symptoms_by_phase.items()
        }

        mood_trends: dict[str, str | None] = {}
        for phase, counts in mood_counts_by_phase.items():
            if counts:
                mood_trends[phase] = max(counts, key = counts.get)
            else:
                mood_trends[phase] = None

        return CyclePattern(
            average_cycle_length = round(avg_cycle, 1),
            cycle_length_range = cycle_range,
            average_period_length = round(avg_period, 1),
            common_symptoms_by_phase = common_symptoms,
            mood_trends_by_phase = mood_trends,
        )
```

---

## Documentation

### Documentation for `CycleService.get_patterns`

**Purpose and Behavior:**
This asynchronous method analyzes historical menstrual cycle data to generate a summary pattern for a user, including average cycle length, period length, common symptoms by phase, and mood trends.

**Key Implementation Details:**
- **Repositories:** Utilizes `PartnerRepository`, `PeriodLogRepository`, and `DailyLogRepository` to fetch relevant data.
- **Data Processing:** Computes average cycle and period lengths based on historical logs. Analyzes daily logs for symptoms and moods, categorizing them by menstrual phases.
- **Patterns:** Returns a structured `CyclePattern` object containing key metrics.

**When/Why to Use:**
Use this method when you need to provide personalized insights into a user's menstrual cycle patterns. It is essential for health monitoring applications where detailed analysis of historical data can inform users about their cycles and related symptoms.

**Patterns/Gotchas:**
- **Asynchronous Handling:** The function uses `async` and awaits repository calls, making it suitable for I/O-bound tasks.
- **Type Hints:** Extensive use of type hints ensures robustness and clarity in the code. 
- **Defaultdict Usage:** Efficiently handles dynamic dictionary updates with default values.
- **Phase Calculation:** Custom phase calculation logic based on cycle length can lead to unexpected results if not correctly implemented.

This method is a prime example of handling complex data processing asynchronously while maintaining readability through clear structure and type annotations.

---

*Generated by CodeWorm on 2026-01-29 14:15*
