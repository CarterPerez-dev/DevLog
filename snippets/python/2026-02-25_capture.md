# capture

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/network-traffic-analyzer/python/src/netanal/main.py
**Language:** python
**Lines:** 111-212
**Complexity:** 7.0

---

## Source Code

```python
def capture(
    interface: Annotated[
        str | None,
        typer.Option(
            "--interface",
            "-i",
            help="Network interface to capture on",
        ),
    ] = None,
    filter_expr: Annotated[
        str | None,
        typer.Option(
            "--filter",
            "-f",
            help="BPF filter expression",
        ),
    ] = None,
    count: Annotated[
        int | None,
        typer.Option(
            "--count",
            "-c",
            help="Number of packets to capture",
        ),
    ] = None,
    timeout: Annotated[
        float | None,
        typer.Option(
            "--timeout",
            "-t",
            help="Capture timeout in seconds",
        ),
    ] = None,
    output: Annotated[
        Path | None,
        typer.Option(
            "--output",
            "-o",
            help="Output file for results (JSON)",
        ),
    ] = None,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            help="Show individual packets",
        ),
    ] = False,
) -> None:
    """
    [bold green]Capture[/bold green] live network packets

    Examples:
        netanal capture -i eth0 --count 100
        netanal capture --filter "tcp port 80" --timeout 30
        netanal capture -i lo -c 50 --verbose
    """
    can_capture, msg = check_capture_permissions()
    if not can_capture:
        print_error(f"Cannot capture packets: {msg}")
        raise typer.Exit(1)

    if filter_expr and not validate_bpf_filter(filter_expr):
        print_error(f"Invalid BPF filter: {filter_expr}")
        raise typer.Exit(1)

    config = CaptureConfig(
        interface=interface,
        bpf_filter=filter_expr,
        packet_count=count,
        timeout_seconds=timeout,
    )

    packets_captured: list[PacketInfo] = []

    def on_packet(packet: PacketInfo) -> None:
        if verbose:
            print_packet(packet)
        if output:
            packets_captured.append(packet)

    console.print(
        f"[cyan]Starting capture on {interface or 'all interfaces'}...[/cyan]"
    )
    console.print("[dim]Press Ctrl+C to stop[/dim]\n")

    engine = CaptureEngine(
        config=config,
        on_packet=on_packet if verbose or output else None
    )

    with GracefulCapture(engine) as cap:
        stats = cap.wait()

    console.print()
    print_capture_summary(stats)
    print_protocol_table(stats)
    print_top_talkers(stats)

    if output:
        export_to_json(stats, output, packets_captured)
        print_success(f"Results saved to {output}")
```

---

## Documentation

### Documentation for `capture` Function

**Purpose and Behavior:**
The `capture` function is a command-line interface (CLI) entry point for capturing live network packets using the `typer` library. It supports various options like specifying an interface, applying BPF filters, setting packet counts, timeouts, and output files.

**Key Implementation Details:**
- **Options Handling:** Utilizes `typer.Option` to define command-line arguments.
- **Configuration Validation:** Checks for capture permissions and validates BPF filter expressions.
- **Capture Engine:** Uses a custom `CaptureEngine` to manage packet capture with optional callbacks for verbose output or file saving.
- **Graceful Capture:** Wraps the capture process in a context manager (`GracefulCapture`) to handle interruptions gracefully.

**When/Why to Use:**
This function is ideal for network traffic analysis, debugging, and security monitoring. It allows users to specify detailed filtering criteria and output options, making it flexible for various use cases.

**Patterns and Gotchas:**
- **Error Handling:** Proper error handling ensures that invalid inputs or permission issues are gracefully managed.
- **Performance Considerations:** Setting a timeout can prevent infinite captures, but ensure the timeout is appropriate for your needs.
- **Output Management:** The `output` parameter requires careful validation to avoid overwriting files.

---

*Generated by CodeWorm on 2026-02-25 21:21*
