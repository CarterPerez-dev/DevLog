# create_room

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/encrypted-p2p-chat/backend/app/api/rooms.py
**Language:** python
**Lines:** 39-132
**Complexity:** 4.0

---

## Source Code

```python
async def create_room(
    request: CreateRoomRequest,
    session: AsyncSession = Depends(get_session),
) -> RoomAPIResponse:
    """
    Create a new chat room
    """
    creator = await auth_service.get_user_by_id(
        session,
        UUID(request.creator_id),
    )

    if not creator:
        raise HTTPException(
            status_code = status.HTTP_404_NOT_FOUND,
            detail = "Creator not found",
        )

    participant = await auth_service.get_user_by_id(
        session,
        UUID(request.participant_id),
    )

    if not participant:
        raise HTTPException(
            status_code = status.HTTP_404_NOT_FOUND,
            detail = "Participant not found",
        )

    now = datetime.now(UTC)

    room_data = {
        "name": None,
        "room_type": request.room_type.value,
        "created_by": request.creator_id,
        "created_at": now.isoformat(),
        "updated_at": now.isoformat(),
        "is_ephemeral": request.room_type == RoomType.EPHEMERAL,
    }

    room = await surreal_db.create_room(room_data)

    await surreal_db.add_room_participant(room.id, request.creator_id, "owner")
    await surreal_db.add_room_participant(room.id, request.participant_id, "member")

    logger.info(
        "Created room %s with creator %s and participant %s",
        room.id,
        request.creator_id,
        request.participant_id,
    )

    participants_list = [
        ParticipantResponse(
            user_id = str(creator.id),
            username = creator.username,
            display_name = creator.display_name,
            role = "owner",
            joined_at = now.isoformat(),
        ),
        ParticipantResponse(
            user_id = str(participant.id),
            username = participant.username,
            display_name = participant.display_name,
            role = "member",
            joined_at = now.isoformat(),
        )
    ]

    room_ws_notification = RoomCreatedWS(
        room_id = room.id,
        room_type = room.room_type.value,
        name = creator.display_name,
        participants = [p.model_dump() for p in participants_list],
        is_encrypted = True,
        created_at = room.created_at.isoformat(),
        updated_at = room.updated_at.isoformat(),
    )

    await connection_manager.send_message(
        UUID(request.participant_id),
        room_ws_notification.model_dump(mode = "json"),
    )

    return RoomAPIResponse(
        id = room.id,
        type = RoomType(room.room_type),
        name = participant.display_name,
        participants = participants_list,
        unread_count = 0,
        is_encrypted = True,
        created_at = room.created_at.isoformat(),
        updated_at = room.updated_at.isoformat(),
    )
```

---

## Documentation

### Documentation for `create_room` Function

**Purpose and Behavior**
The `create_room` function is an asynchronous API endpoint responsible for creating a new chat room. It validates the creator and participant users, creates the room in the database, adds participants with roles, logs the creation, and notifies the participant via WebSocket.

**Key Implementation Details**
- **Dependencies**: Uses `Depends(get_session)` to manage database sessions.
- **Validation**: Checks if the creator and participant exist before proceeding. Raises HTTP 404 errors if any user is not found.
- **Room Data**: Sets up room attributes like type, creation time, and whether it's ephemeral.
- **Database Operations**: Uses `surreal_db` to create the room and add participants with roles.
- **Logging and Notification**: Logs the room creation and sends a WebSocket notification to the participant.

**When/Why to Use This Code**
Use this function when setting up an encrypted peer-to-peer chat application that requires creating rooms for specific users. It ensures secure user authentication, proper room setup, and real-time notifications.

**Patterns and Gotchas**
- **Asynchronous Handling**: The function is fully asynchronous, leveraging `async` and `await`. Ensure all database operations are marked as `async`.
- **Dependency Injection**: Utilizes dependency injection via `Depends(get_session)` for session management.
- **Error Handling**: Robust error handling with HTTP exceptions ensures proper client feedback.

---

*Generated by CodeWorm on 2026-01-17 18:22*
