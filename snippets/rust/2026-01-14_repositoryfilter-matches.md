# RepositoryFilter.matches

**Repository:** kill-pr0cess.inc
**File:** backend/src/models/github.rs
**Language:** rust
**Lines:** 347-444
**Complexity:** 29.0

---

## Source Code

```rust
fn matches(&self, repo: &Repository) -> bool {
        if let Some(ref lang) = self.language {
            if repo.language.as_ref() != Some(lang) {
                return false;
            }
        }

        if let Some(min_stars) = self.min_stars {
            if repo.stargazers_count < min_stars {
                return false;
            }
        }

        if let Some(max_stars) = self.max_stars {
            if repo.stargazers_count > max_stars {
                return false;
            }
        }

        if let Some(min_size) = self.min_size_kb {
            if repo.size_kb < min_size {
                return false;
            }
        }

        if let Some(max_size) = self.max_size_kb {
            if repo.size_kb > max_size {
                return false;
            }
        }

        if let Some(is_fork) = self.is_fork {
            if repo.is_fork != is_fork {
                return false;
            }
        }

        if let Some(is_archived) = self.is_archived {
            if repo.is_archived != is_archived {
                return false;
            }
        }

        if let Some(has_topics) = self.has_topics {
            let empty = repo.topics.as_ref().map(|t| t.is_empty()).unwrap_or(true);
            if empty == has_topics {
                return false;
            }
        }

        if let Some(has_license) = self.has_license {
            if repo.license_name.is_some() != has_license {
                return false;
            }
        }

        if let Some(created_after) = self.created_after {
            if repo.created_at < created_after {
                return false;
            }
        }

        if let Some(created_before) = self.created_before {
            if repo.created_at > created_before {
                return false;
            }
        }

        if let Some(updated_after) = self.updated_after {
            if repo.updated_at < updated_after {
                return false;
            }
        }

        if let Some(updated_before) = self.updated_before {
            if repo.updated_at > updated_before {
                return false;
            }
        }

        if let Some(ref query) = self.search_query {
            let search_text = format!(
                "{} {} {}",
                repo.name,
                repo.description.as_deref().unwrap_or(""),
                                      repo.topics
                                          .as_ref()
                                          .map(|v| v.join(" "))
                                          .unwrap_or_default()
            ).to_lowercase();

            if !search_text.contains(&query.to_lowercase()) {
                return false;
            }
        }

        true
    }
```

---

## Documentation

### Documentation for `matches` Function in `RepositoryFilter`

**Purpose and Behavior:**
The `matches` function checks if a given repository meets the criteria specified by a filter object. It evaluates various attributes such as language, stargazers count, size, fork status, archived state, topics, license presence, creation and update timestamps, and search queries.

**Key Implementation Details:**
- The function uses pattern matching (`if let`) to check optional fields in both the `self` (filter) and `repo` (repository) objects.
- It compares repository attributes against filter criteria using logical conditions. If any condition fails, it returns `false`.
- For search queries, it concatenates relevant parts of the repository's name, description, and topics into a single string for case-insensitive comparison.

**When/Why to Use:**
This function is used in filtering repositories based on user-defined criteria. It can be employed in scenarios like searching or sorting repositories in a GitHub API client application where users need to apply multiple filters simultaneously.

**Patterns and Gotchas:**
- The use of `Option` and pattern matching allows for flexible handling of optional fields.
- The function returns early if any filter condition fails, improving performance by avoiding unnecessary checks.
- Be cautious with the search query implementation as it concatenates strings from potentially untrusted sources. Ensure proper sanitization to prevent injection attacks.

This function is a good example of Rust's strong type system and pattern matching capabilities for handling optional data in a clean and efficient manner.

---

*Generated by CodeWorm on 2026-01-14 14:18*
