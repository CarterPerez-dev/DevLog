# CacheService.mset

**Repository:** kill-pr0cess.inc
**File:** backend/src/services/cache_service.rs
**Language:** rust
**Lines:** 432-481
**Complexity:** 9.0

---

## Source Code

```rust
pub async fn mset<T>(&self, entries: &[(&str, &T)], ttl_seconds: Option<u64>) -> Result<()>
    where
    T: Serialize + Send + Sync,
    {
        if entries.is_empty() {
            return Ok(());
        }

        let ttl = ttl_seconds.unwrap_or(self.default_ttl);
        let now = self.current_timestamp();
        let mut conn = self.get_connection().await?;

        debug!("Cache MSET: {} entries (TTL: {}s)", entries.len(), ttl);

        // Prepare entries as (key, value) tuples for mset_multiple
        let mut kv_pairs_for_redis: Vec<(String, String)> = Vec::with_capacity(entries.len());

        for (key, value) in entries {
            let full_key = self.build_key(key);
            let entry = CacheEntry {
                data: value,
                created_at: now,
                expires_at: now + ttl,
                access_count: 0,
                last_accessed: now,
                version: 1,
            };

            let serialized = serde_json::to_string(&entry)
            .map_err(|e| AppError::SerializationError(format!("Failed to serialize cache entry: {}", e)))?;

            kv_pairs_for_redis.push((full_key, serialized));
        }

        // Set all entries
        conn.mset::<_, _, ()>(&kv_pairs_for_redis).await
        .map_err(|e| AppError::CacheError(format!("Failed to set multiple cache entries: {}", e)))?;

        // Set expiration for all keys in a pipeline for efficiency
        let mut pipe = redis::pipe();
        for (key, _) in entries { // Iterate original keys to avoid issues with kv_pairs_for_redis potentially being moved
            let full_key_for_expire = self.build_key(key);
            pipe.expire(full_key_for_expire, ttl as i64);
        }
        pipe.query_async::<_, ()>(&mut conn).await
            .map_err(|e| AppError::CacheError(format!("Failed to set expiration for multiple keys: {}", e)))?;


        Ok(())
    }
```

---

## Documentation

### Documentation for `CacheService::mset`

**Purpose and Behavior:**
The `mset` function in the `CacheService` class is responsible for setting multiple cache entries with optional time-to-live (TTL) values asynchronously. It serializes each entry, sets them using Redis's `MSET`, and then applies TTLs to all keys efficiently.

**Key Implementation Details:**
- **Input:** Takes a slice of key-value pairs (`&[(&str, &T)]`) and an optional TTL in seconds.
- **Serialization:** Each value is serialized into JSON format before being stored.
- **Efficiency:** Uses Redis pipelines for setting both values and TTLs to optimize performance.

**When/Why to Use This Code:**
Use this function when you need to set multiple cache entries at once, with the option to specify a TTL. It's efficient for bulk operations and ensures that all keys are handled atomically in Redis.

**Patterns and Gotchas:**
- **Borrowing:** The function borrows values from `entries`, so ensure these references remain valid until after the call.
- **Error Handling:** Uses `Result` to handle potential serialization or cache errors, providing detailed error messages.
- **Lifetimes:** The `ttl_seconds` parameter can be `None`, defaulting to a configured value. Ensure that `T: Serialize + Send + Sync` is implemented for your data types.

This function is particularly useful in scenarios where you need to update multiple cache entries simultaneously and manage their lifespans efficiently.

---

*Generated by CodeWorm on 2026-01-24 23:27*
