# get_language_distribution

**Repository:** kill-pr0cess.inc
**File:** backend/src/routes/github.rs
**Language:** rust
**Lines:** 259-327
**Complexity:** 10.0

---

## Source Code

```rust
pub async fn get_language_distribution(
    State(app_state): State<AppState>,
) -> Result<JsonResponse<serde_json::Value>> {
    info!("Calculating language distribution across repositories");

    let username = &app_state.config.github_username;

    // Get all repositories
    let repositories = match app_state.github_service.get_user_repositories(username).await {
        Ok(repos) => repos,
        Err(_) => get_repositories_from_db(&app_state, username).await?,
    };

    // Calculate language statistics
    let mut language_stats: HashMap<String, LanguageStat> = HashMap::new();
    let mut total_size: i64 = 0;

    for repo in &repositories {
        if repo.is_archived || repo.is_fork {
            continue; // Skip archived and forked repositories for cleaner stats
        }

        total_size += repo.size_kb as i64;

        if let Some(ref language) = repo.language {
            let stat = language_stats.entry(language.clone()).or_insert(LanguageStat {
                name: language.clone(),
                repository_count: 0,
                total_size_kb: 0,
                total_stars: 0,
                average_stars: 0.0,
                percentage: 0.0,
            });

            stat.repository_count += 1;
            stat.total_size_kb += repo.size_kb as i64;
            stat.total_stars += repo.stargazers_count;
        }
    }

    // Calculate percentages and averages
    for stat in language_stats.values_mut() {
        stat.percentage = if total_size > 0 {
            (stat.total_size_kb as f64 / total_size as f64) * 100.0
        } else { 0.0 };
        stat.average_stars = if stat.repository_count > 0 {
            stat.total_stars as f64 / stat.repository_count as f64
        } else { 0.0 };
    }

    // Sort by usage (repository count)
    let mut sorted_languages: Vec<_> = language_stats.into_values().collect();
    sorted_languages.sort_by(|a, b| b.repository_count.cmp(&a.repository_count));

    let response = serde_json::json!({
        "languages": sorted_languages,
        "summary": {
            "total_languages": sorted_languages.len(),
            "total_repositories_analyzed": repositories.len(),
            "total_size_kb": total_size,
            "most_used_language": sorted_languages.first().map(|l| &l.name),
            "language_diversity_score": calculate_diversity_score(&sorted_languages)
        },
        "analysis_timestamp": chrono::Utc::now()
    });

    info!("Language distribution calculated for {} languages", sorted_languages.len());
    Ok(Json(response))
}
```

---

## Documentation

### Documentation for `get_language_distribution`

**Purpose and Behavior:**
The function `get_language_distribution` calculates the distribution of programming languages used across a GitHub user's repositories. It retrieves repository data from both the GitHub API and a local database, processes this data to compute language statistics, and returns a JSON response summarizing the findings.

**Key Implementation Details:**
1. **State Dependency:** The function takes `AppState` as a state parameter, which contains configuration and service references.
2. **Error Handling:** It handles potential errors by falling back to a database query if the GitHub API request fails.
3. **Data Processing:** Repositories are filtered to exclude archived or forked ones. Language statistics are aggregated based on repository size, star count, and language type.
4. **Sorting and Calculation:** The function sorts languages by usage (repository count) and calculates percentages and averages.

**When/Why to Use:**
This code is useful for analyzing the programming language diversity of a GitHub user's repositories. It can be employed in scenarios where detailed insights into repository statistics are required, such as project management tools or developer analytics platforms.

**Patterns and Gotchas:**
- **Ownership and Borrowing:** The function uses `&` to borrow data from `AppState`, ensuring efficient memory usage.
- **Error Handling with `?`:** The `?` operator is used for error propagation, making the code cleaner but requiring careful handling of potential errors.
- **Lifetimes:** Ensure that references to `AppState` and other resources are valid throughout the function's execution.

---

*Generated by CodeWorm on 2026-01-24 15:05*
