# GitHubService.get_user_repositories

**Repository:** kill-pr0cess.inc
**File:** backend/src/services/github_service.rs
**Language:** rust
**Lines:** 125-200
**Complexity:** 10.0

---

## Source Code

```rust
pub async fn get_user_repositories(&self, username: &str) -> Result<Vec<Repository>> {
        let cache_key = format!("github:repos:{}", username);

        // Check cache first - I'm implementing intelligent cache with TTL
        if let Ok(Some(cached_repos)) = self.cache_service.get::<Vec<Repository>>(&cache_key).await {
            debug!("Returning cached repositories for user: {}", username);
            return Ok(cached_repos);
        }

        info!("Fetching fresh repository data for user: {}", username);

        let mut all_repos = Vec::new();
        let mut page = 1;
        let per_page = 100; // Maximum allowed by GitHub API

        loop {
            // I'm checking rate limits before making requests
            self.check_rate_limit().await?;

            let url = format!(
                "{}/users/{}/repos?page={}&per_page={}&sort=updated&direction=desc",
                self.base_url, username, page, per_page
            );

            debug!("Fetching repositories page {} for user: {}", page, username);

            let response = self.client
            .get(&url)
            .send()
            .await
            .map_err(|e| AppError::ExternalApiError(format!("GitHub API request failed: {}", e)))?;

            // Update rate limit information from headers
            self.update_rate_limit_from_headers(&response).await;

            if !response.status().is_success() {
                let status = response.status();
                let error_text = response.text().await.unwrap_or_default();
                return Err(AppError::ExternalApiError(
                    format!("GitHub API error {}: {}", status, error_text)
                ));
            }

            let repos: Vec<GitHubApiRepository> = response
            .json()
            .await
            .map_err(|e| AppError::SerializationError(format!("Failed to parse GitHub response: {}", e)))?;

            if repos.is_empty() {
                break; // No more pages
            }

            // Transform GitHub API response to our internal format
            for api_repo in repos {
                let repo = self.transform_api_repository(api_repo);
                all_repos.push(repo);
            }

            page += 1;

            // Prevent infinite loops and respect API limits
            if page > 50 {
                warn!("Stopping repository fetch at page 50 to prevent excessive API usage");
                break;
            }
        }

        info!("Fetched {} repositories for user: {}", all_repos.len(), username);

        // Cache the results with 1-hour TTL
          if let Err(e) = self.cache_service.set(&cache_key, &all_repos, Some(3600)).await {
            warn!("Failed to cache repository data: {}", e);
        }

        Ok(all_repos)
    }
```

---

## Documentation

### Documentation for `get_user_repositories`

**Purpose and Behavior:**
This function retrieves a user's GitHub repositories from the API, caching results with a 1-hour TTL to minimize redundant requests. It first checks the cache, fetches fresh data if necessary, processes pages of repositories, and transforms them into an internal format.

**Key Implementation Details:**
- **Caching:** Uses intelligent caching with Time-To-Live (TTL) to store fetched repositories.
- **Rate Limiting:** Checks and updates rate limits before each API call.
- **Error Handling:** Handles API errors and deserialization issues, returning appropriate `AppError` variants.
- **Pagination:** Fetches up to 50 pages of repositories, with a maximum of 100 per page.

**When/Why to Use:**
Use this function when you need to fetch and cache GitHub user repositories. It ensures efficient API usage by leveraging caching and rate limiting, making it suitable for applications requiring frequent repository data access.

**Patterns and Gotchas:**
- **Borrowing:** The `&self` parameter allows the service to manage its own state without ownership transfer.
- **Lifetime Management:** Properly handles lifetimes in asynchronous operations, ensuring safe memory management.
- **Rate Limiting:** Implementing rate limiting prevents API abuse and ensures compliance with GitHub's usage policies.

This function is ideal for scenarios where repository data needs to be frequently accessed but should only be fetched from the API when necessary.

---

*Generated by CodeWorm on 2026-01-13 02:51*
