# decryptMessage

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/crypto/double-ratchet.ts
**Language:** typescript
**Lines:** 225-289
**Complexity:** 9.0

---

## Source Code

```typescript
async function decryptMessage(
  state: DoubleRatchetState,
  message: EncryptedMessage,
  associatedData?: Uint8Array
): Promise<Uint8Array> {
  const peerPublicKey = base64ToBytes(message.header.dh_public_key)

  const skippedKeyId = createSkippedKeyId(
    peerPublicKey,
    message.header.message_number
  )
  const skippedKey = state.skipped_message_keys.get(skippedKeyId)

  if (skippedKey !== undefined) {
    state.skipped_message_keys.delete(skippedKeyId)

    const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
    const aad =
      associatedData !== undefined
        ? concatBytes(associatedData, headerBytes)
        : headerBytes

    return await aesGcmDecrypt(skippedKey, message.ciphertext, message.nonce, aad)
  }

  const isDifferentRatchetKey =
    state.dh_peer_public_key === null ||
    bytesToBase64(state.dh_peer_public_key) !== message.header.dh_public_key

  if (isDifferentRatchetKey) {
    if (state.receiving_chain_key !== null && state.dh_peer_public_key !== null) {
      await skipMessageKeys(state, message.header.previous_chain_length)
    }

    await performDHRatchet(state, peerPublicKey)
  }

  await skipMessageKeys(state, message.header.message_number)

  if (state.receiving_chain_key === null) {
    throw new Error('Receiving chain key not initialized after ratchet')
  }

  const { messageKey, nextChainKey } = await deriveMessageKey(
    state.receiving_chain_key
  )

  const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
  const aad =
    associatedData !== undefined
      ? concatBytes(associatedData, headerBytes)
      : headerBytes

  const plaintext = await aesGcmDecrypt(
    messageKey,
    message.ciphertext,
    message.nonce,
    aad
  )

  state.receiving_chain_key = nextChainKey
  state.receiving_message_number++

  return plaintext
}
```

---

## Documentation

### Documentation for `decryptMessage` Function

**Purpose and Behavior:**
The `decryptMessage` function decrypts an encrypted message using the Double Ratchet algorithm, a cryptographic protocol used in secure messaging applications. It handles both skipped and non-skipped messages by managing state and performing key derivations.

**Key Implementation Details:**
- **State Management:** The function updates the `state` object to manage keys and message numbers.
- **Message Handling:** It checks if the message is skipped or requires a new ratchet, updating the chain key accordingly.
- **Decryption Logic:** Uses AES-GCM for decryption with associated data (AAD) derived from message headers.

**When/Why to Use This Code:**
This function should be used in applications requiring secure, end-to-end encrypted messaging. It is essential for decrypting messages received over a secure channel where the Double Ratchet protocol is implemented.

**Patterns and Gotchas:**
- **State Dependency:** The function heavily relies on the `state` object, which must be properly initialized.
- **Error Handling:** Ensure that the `receiving_chain_key` is not null after ratcheting; otherwise, an error will be thrown.
- **Key Management:** Properly managing skipped keys and chain keys to avoid decryption failures.

---

*Generated by CodeWorm on 2026-02-18 19:06*
