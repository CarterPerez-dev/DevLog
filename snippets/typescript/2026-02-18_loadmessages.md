# loadMessages

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/advanced/encrypted-p2p-chat/frontend/src/services/room.service.ts
**Language:** typescript
**Lines:** 50-141
**Complexity:** 11.0

---

## Source Code

```typescript
async function loadMessages(
  roomId: string,
  limit: number = 50,
  offset: number = 0
): Promise<Message[]> {
  try {
    const localMessages = await getDecryptedMessages(roomId, limit)
    const localMessageIds = new Set(localMessages.map((m) => m.id))

    if (localMessages.length > 0) {
      setRoomMessages(roomId, localMessages)
    }

    const response = await api.rooms.getMessages(roomId, limit, offset)
    const serverMessages = response.messages.reverse()

    const newMessages: Message[] = []

    const currentUserId = $userId.get()

    for (const msg of serverMessages) {
      if (localMessageIds.has(msg.id)) {
        continue
      }

      let content = '[Encrypted - from another session]'
      const isOwnMessage = msg.sender_id === currentUserId

      if (isOwnMessage) {
        const localCopy = await getDecryptedMessage(msg.id)
        if (localCopy) {
          content = localCopy.content
        } else {
          content = '[Your message - not stored locally]'
        }
      } else {
        try {
          content = await cryptoService.decrypt(
            msg.sender_id,
            msg.ciphertext,
            msg.nonce,
            msg.header
          )
        } catch {
          content = '[Encrypted - from another session]'
        }
      }

      const decryptedMessage: Message = {
        id: msg.id,
        room_id: msg.room_id,
        sender_id: msg.sender_id,
        sender_username: msg.sender_username,
        content,
        status: 'delivered' as const,
        is_encrypted: true,
        encrypted_content: msg.ciphertext,
        nonce: msg.nonce,
        header: msg.header,
        created_at: msg.created_at,
        updated_at: msg.created_at,
      }

      if (
        !content.startsWith('[Encrypted') &&
        !content.startsWith('[Your message')
      ) {
        void saveDecryptedMessage(decryptedMessage)
      }

      newMessages.push(decryptedMessage)
    }

    const allMessages = [...localMessages, ...newMessages]
    const uniqueMessages = Array.from(
      new Map(allMessages.map((m) => [m.id, m])).values()
    ).sort(
      (a, b) =>
        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    )

    setRoomMessages(roomId, uniqueMessages)
    setHasMore(roomId, response.has_more)
    return uniqueMessages
  } catch (_err) {
    const localMessages = await getDecryptedMessages(roomId, limit)
    if (localMessages.length > 0) {
      setRoomMessages(roomId, localMessages)
    }
    return localMessages
  }
}
```

---

## Documentation

### Documentation for `loadMessages` Function

**Purpose and Behavior:**
The `loadMessages` function fetches messages from a specified room, decrypts them if necessary, and updates the local message cache. It handles both encrypted and decrypted messages, ensuring that only new messages are processed.

**Key Implementation Details:**
- **Parameters:** Accepts `roomId`, `limit`, and `offset` with default values.
- **Async Operations:** Uses asynchronous functions to fetch and decrypt messages from an API and a local store.
- **Message Handling:** Checks if messages are already decrypted locally before processing. Decrypts messages using the `cryptoService`.
- **Local Storage Management:** Updates the room's message cache based on new and existing messages.

**When/Why to Use:**
Use this function whenever you need to load and update a list of encrypted or decrypted messages in real-time for a chat application. It ensures that only new, relevant messages are processed, optimizing performance by minimizing redundant decryption operations.

**Patterns and Gotchas:**
- **Error Handling:** The catch block ensures local messages are used if the API request fails.
- **Decryption Logic:** Messages from other users require decryption; own messages may be stored locally or need to be decrypted on-the-fly.
- **Performance Considerations:** Efficiently handles large message sets by sorting and deduplicating messages.

---

*Generated by CodeWorm on 2026-02-18 18:23*
