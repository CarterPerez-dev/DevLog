# loadMessages

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/encrypted-p2p-chat/frontend/src/services/room.service.ts
**Language:** typescript
**Lines:** 51-137
**Complexity:** 11.0

---

## Source Code

```typescript
async function loadMessages(
  roomId: string,
  limit: number = 50,
  offset: number = 0
): Promise<Message[]> {
  try {
    const localMessages = await getDecryptedMessages(roomId, limit)
    const localMessageIds = new Set(localMessages.map((m) => m.id))

    if (localMessages.length > 0) {
      setRoomMessages(roomId, localMessages)
    }

    const response = await api.rooms.getMessages(roomId, limit, offset)
    const serverMessages = response.messages.reverse()

    const newMessages: Message[] = []

    const currentUserId = $userId.get()

    for (const msg of serverMessages) {
      if (localMessageIds.has(msg.id)) {
        continue
      }

      let content = "[Encrypted - from another session]"
      const isOwnMessage = msg.sender_id === currentUserId

      if (isOwnMessage) {
        const localCopy = await getDecryptedMessage(msg.id)
        if (localCopy) {
          content = localCopy.content
        } else {
          content = "[Your message - not stored locally]"
        }
      } else {
        try {
          content = await cryptoService.decrypt(
            msg.sender_id,
            msg.ciphertext,
            msg.nonce,
            msg.header
          )
        } catch {
          content = "[Encrypted - from another session]"
        }
      }

      const decryptedMessage: Message = {
        id: msg.id,
        room_id: msg.room_id,
        sender_id: msg.sender_id,
        sender_username: msg.sender_username,
        content,
        status: "delivered" as const,
        is_encrypted: true,
        encrypted_content: msg.ciphertext,
        nonce: msg.nonce,
        header: msg.header,
        created_at: msg.created_at,
        updated_at: msg.created_at,
      }

      if (!content.startsWith("[Encrypted") && !content.startsWith("[Your message")) {
        void saveDecryptedMessage(decryptedMessage)
      }

      newMessages.push(decryptedMessage)
    }

    const allMessages = [...localMessages, ...newMessages]
    const uniqueMessages = Array.from(
      new Map(allMessages.map((m) => [m.id, m])).values()
    ).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime())

    setRoomMessages(roomId, uniqueMessages)
    setHasMore(roomId, response.has_more)
    return uniqueMessages
  } catch (err) {
    console.error("[RoomService] Failed to load messages:", err)
    const localMessages = await getDecryptedMessages(roomId, limit)
    if (localMessages.length > 0) {
      setRoomMessages(roomId, localMessages)
    }
    return localMessages
  }
}
```

---

## Documentation

### Documentation for `loadMessages` Function

**Purpose and Behavior:**
The `loadMessages` function fetches messages from a specified room, decrypts them if necessary, and updates the local message cache. It handles both encrypted and locally decrypted messages, ensuring that only new or updated messages are processed.

**Key Implementation Details:**
1. **Parameters:** Accepts `roomId`, `limit`, and `offset` with default values.
2. **Asynchronous Operations:** Uses `async/await` for API calls and decryption processes.
3. **Message Handling:** Checks if a message is new or locally stored, decrypts messages as needed, and updates the room's message cache.

**When/Why to Use:**
Use this function when initializing a chat session or refreshing messages in real-time. It ensures that all messages are decrypted and up-to-date without duplicating existing local data.

**Patterns/Gotchas:**
- **Error Handling:** Catches errors during decryption, ensuring fallbacks to encrypted content.
- **Performance Considerations:** Frequent calls may impact performance due to repeated API requests; consider caching strategies for optimization.

---

*Generated by CodeWorm on 2026-01-16 01:53*
