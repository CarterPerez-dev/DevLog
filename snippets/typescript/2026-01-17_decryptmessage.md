# decryptMessage

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/encrypted-p2p-chat/frontend/src/crypto/double-ratchet.ts
**Language:** typescript
**Lines:** 190-238
**Complexity:** 9.0

---

## Source Code

```typescript
async function decryptMessage(
  state: DoubleRatchetState,
  message: EncryptedMessage,
  associatedData?: Uint8Array
): Promise<Uint8Array> {
  const peerPublicKey = base64ToBytes(message.header.dh_public_key)

  const skippedKeyId = createSkippedKeyId(peerPublicKey, message.header.message_number)
  const skippedKey = state.skipped_message_keys.get(skippedKeyId)

  if (skippedKey !== undefined) {
    state.skipped_message_keys.delete(skippedKeyId)

    const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
    const aad = associatedData !== undefined ? concatBytes(associatedData, headerBytes) : headerBytes

    return await aesGcmDecrypt(skippedKey, message.ciphertext, message.nonce, aad)
  }

  const isDifferentRatchetKey =
    state.dh_peer_public_key === null ||
    bytesToBase64(state.dh_peer_public_key) !== message.header.dh_public_key

  if (isDifferentRatchetKey) {
    if (state.receiving_chain_key !== null && state.dh_peer_public_key !== null) {
      await skipMessageKeys(state, message.header.previous_chain_length)
    }

    await performDHRatchet(state, peerPublicKey)
  }

  await skipMessageKeys(state, message.header.message_number)

  if (state.receiving_chain_key === null) {
    throw new Error("Receiving chain key not initialized after ratchet")
  }

  const { messageKey, nextChainKey } = await deriveMessageKey(state.receiving_chain_key)

  const headerBytes = new TextEncoder().encode(JSON.stringify(message.header))
  const aad = associatedData !== undefined ? concatBytes(associatedData, headerBytes) : headerBytes

  const plaintext = await aesGcmDecrypt(messageKey, message.ciphertext, message.nonce, aad)

  state.receiving_chain_key = nextChainKey
  state.receiving_message_number++

  return plaintext
}
```

---

## Documentation

### Purpose and Behavior
The `decryptMessage` function decrypts a received encrypted message using the Double Ratchet algorithm, ensuring secure communication in a P2P chat application. It handles key management by ratcheting keys when necessary and uses AES-GCM for decryption.

### Key Implementation Details
- **Input**: Takes `state`, an object containing cryptographic state; `message`, an encrypted message; and optionally `associatedData` for authentication.
- **Process**:
  - Extracts peer public key from the message header.
  - Determines if a skipped key should be used, updating state accordingly.
  - Ratchets keys if necessary to handle new or different peer public keys.
  - Derives current message key and decrypts the message.
  - Updates state with the next chain key and increments the receiving message number.

### When/Why to Use This Code
Use this function in scenarios where you need secure, end-to-end encrypted messaging. It ensures that messages are decrypted correctly even if keys change due to new peer public keys or skipped messages. The function handles key ratcheting and state management automatically, making it suitable for complex P2P chat applications.

### Patterns and Gotchas
- **Key Management**: Properly handles key skipping and ratcheting to maintain security.
- **State Dependency**: The function heavily relies on the `state` object being correctly initialized. Ensure that all necessary keys are present before calling this function.
- **Error Handling**: Throws an error if the receiving chain key is not initialized after a ratchet, indicating potential issues with state initialization or key derivation.

---

*Generated by CodeWorm on 2026-01-17 00:47*
