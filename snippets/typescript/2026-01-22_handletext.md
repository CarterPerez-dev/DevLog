# handleText

**Repository:** angelamos-operations
**File:** CarterBot-Telegram/src/handlers/text.ts
**Language:** typescript
**Lines:** 13-93
**Complexity:** 16.0

---

## Source Code

```typescript
async function handleText(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username || "unknown";
  const chatId = ctx.chat?.id;
  let message = ctx.message?.text;

  if (!userId || !message || !chatId) {
    return;
  }

  if (!isAuthorized(userId, ALLOWED_USERS)) {
    await ctx.reply("Unauthorized. Contact the bot owner for access.");
    return;
  }

  message = await checkInterrupt(message);
  if (!message.trim()) {
    return;
  }

  session.lastMessage = message;

  const stopProcessing = session.startProcessing();
  const typing = startTypingIndicator(ctx);

  let state = new StreamingState();
  let statusCallback = createStatusCallback(ctx, state);

  const MAX_RETRIES = 1;

  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    try {
      await session.sendMessageStreaming(
        message,
        username,
        userId,
        statusCallback,
        chatId,
        ctx
      );
      break;
    } catch (error) {
      const errorStr = String(error);
      const isClaudeCodeCrash = errorStr.includes("exited with code");

      for (const toolMsg of state.toolMessages) {
        try {
          await ctx.api.deleteMessage(toolMsg.chat.id, toolMsg.message_id);
        } catch {
          // Ignore cleanup errors
        }
      }

      if (isClaudeCodeCrash && attempt < MAX_RETRIES) {
        console.log(
          `Claude Code crashed, retrying (attempt ${attempt + 2}/${MAX_RETRIES + 1})...`
        );
        await session.kill();
        await ctx.reply("Claude crashed, retrying...");
        state = new StreamingState();
        statusCallback = createStatusCallback(ctx, state);
        continue;
      }

      console.error("Error processing message:", error);

      if (errorStr.includes("abort") || errorStr.includes("cancel")) {
        const wasInterrupt = session.consumeInterruptFlag();
        if (!wasInterrupt) {
          await ctx.reply("Query stopped.");
        }
      } else {
        await ctx.reply(`Error: ${errorStr.slice(0, 200)}`);
      }
      break;
    }
  }

  stopProcessing();
  typing.stop();
}
```

---

## Documentation

### Documentation for `handleText` Function

**Purpose and Behavior:**
The `handleText` function processes incoming text messages in a Telegram bot context. It checks user authorization, handles interruptions, retries failed operations up to one time, and manages message streaming.

**Key Implementation Details:**
- **Authorization Check:** Ensures the user is authorized before processing.
- **Message Handling:** Cleans and streams the message if necessary.
- **Error Handling:** Retries on specific errors (e.g., Claude Code crash) and handles aborts/cancels by stopping streaming.
- **Session Management:** Uses session states for tracking messages and interruptions.

**When/Why to Use:**
Use this function in Telegram bot handlers where you need robust text processing with retries, authorization checks, and error handling. It's particularly useful for complex interactions that require multiple attempts or state management.

**Patterns/Gotchas:**
- **Session State:** The `StreamingState` object is crucial for managing the session across retries.
- **Error Handling:** Specific error messages like "exited with code" trigger a retry, while abort/cancel errors stop streaming without further attempts.
- **Cleanup:** Properly handles cleanup of tool messages during retries to avoid clutter.

This function ensures reliable and robust message processing in dynamic environments.

---

*Generated by CodeWorm on 2026-01-22 16:16*
