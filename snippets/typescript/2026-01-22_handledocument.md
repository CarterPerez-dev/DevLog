# handleDocument

**Repository:** angelamos-operations
**File:** CarterBot-Telegram/src/handlers/document.ts
**Language:** typescript
**Lines:** 143-214
**Complexity:** 17.0

---

## Source Code

```typescript
async function handleDocument(ctx: Context): Promise<void> {
  const userId = ctx.from?.id;
  const username = ctx.from?.username || "unknown";
  const chatId = ctx.chat?.id;
  const doc = ctx.message?.document;
  const mediaGroupId = ctx.message?.media_group_id;

  if (!userId || !chatId || !doc) {
    return;
  }

  if (!isAuthorized(userId, ALLOWED_USERS)) {
    await ctx.reply("Unauthorized. Contact the bot owner for access.");
    return;
  }

  if (doc.file_size && doc.file_size > MAX_FILE_SIZE) {
    await ctx.reply("File too large. Maximum size is 10MB.");
    return;
  }

  const fileName = doc.file_name || "";
  const extension = "." + (fileName.split(".").pop() || "").toLowerCase();
  const isPdf = doc.mime_type === "application/pdf" || extension === ".pdf";
  const isText = TEXT_EXTENSIONS.includes(extension) || doc.mime_type?.startsWith("text/");

  if (!isPdf && !isText) {
    await ctx.reply(
      `Unsupported file type: ${extension || doc.mime_type}\n\n` +
        `Supported: PDF, ${TEXT_EXTENSIONS.join(", ")}`
    );
    return;
  }

  let docPath: string;
  try {
    docPath = await downloadDocument(ctx);
  } catch (error) {
    console.error("Failed to download document:", error);
    await ctx.reply("Failed to download document.");
    return;
  }

  if (!mediaGroupId) {
    console.log(`Received document: ${fileName} from @${username}`);

    try {
      const content = await extractText(docPath, doc.mime_type);
      await processDocuments(
        ctx,
        [{ path: docPath, name: fileName, content }],
        ctx.message?.caption,
        userId,
        username,
        chatId
      );
    } catch (error) {
      console.error("Failed to extract document:", error);
      await ctx.reply(`Failed to process document: ${String(error).slice(0, 100)}`);
    }
    return;
  }

  await documentBuffer.addToGroup(
    mediaGroupId,
    docPath,
    ctx,
    userId,
    username,
    processDocumentPaths
  );
}
```

---

## Documentation

### Documentation for `handleDocument` Function

**Purpose and Behavior:**
The `handleDocument` function processes incoming documents in a Telegram bot, ensuring they meet certain criteria before processing them further. It checks the user's authorization, file size, and type, then either extracts text or adds the document to an existing media group.

**Key Implementation Details:**
- **Authorization Check:** The function verifies if the user is authorized using `isAuthorized(userId, ALLOWED_USERS)`.
- **File Size Validation:** Files larger than 10MB are rejected.
- **Supported File Types:** Only PDFs and text documents are processed; other types are flagged as unsupported.
- **Document Downloading:** Uses `downloadDocument(ctx)` to save the document locally.
- **Text Extraction:** Utilizes `extractText(docPath, doc.mime_type)` to extract text from the document.

**When/Why to Use:**
This function is essential for handling and processing documents in a Telegram bot. It ensures that only authorized users can upload files within specified constraints, enhancing security and usability.

**Patterns/Gotchas:**
- **Error Handling:** The function uses try-catch blocks to handle potential errors during document download and text extraction.
- **Return Early Pattern:** Returns early from the function if any validation fails, improving readability and reducing nested logic.

---

*Generated by CodeWorm on 2026-01-22 13:54*
