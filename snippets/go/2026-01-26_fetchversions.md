# FetchVersions

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/simple-vulnerability-scanner/internal/pypi/client.go
**Language:** go
**Lines:** 76-137
**Complexity:** 12.0

---

## Source Code

```go
func (c *Client) FetchVersions(
	ctx context.Context,
	name string,
) ([]string, error) {
	normalized := NormalizeName(name)

	entry, hit := c.cache.Get(normalized)
	if hit && c.cache.IsFresh(entry) {
		return entry.Versions, nil
	}

	url := simpleAPIBase + normalized + "/"
	req, err := http.NewRequestWithContext(
		ctx, http.MethodGet, url, nil,
	)
	if err != nil {
		return nil, fmt.Errorf("build request for %s: %w", name, err)
	}
	req.Header.Set("Accept", simpleAPIAccept)
	req.Header.Set("User-Agent", c.userAgent)

	if entry != nil && entry.ETag != "" {
		req.Header.Set("If-None-Match", entry.ETag)
	}

	resp, err := c.doWithRetry(ctx, req)
	if err != nil {
		if entry != nil {
			return entry.Versions, nil
		}
		return nil, fmt.Errorf("fetch %s: %w", name, err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusNotModified:
		c.cache.Touch(normalized)
		return entry.Versions, nil

	case http.StatusNotFound:
		return nil, fmt.Errorf(
			"package %q not found on PyPI", name,
		)

	case http.StatusOK:
		var result simpleAPIResponse
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, fmt.Errorf("decode %s: %w", name, err)
		}
		_ = c.cache.Set(normalized, &CacheEntry{
			ETag:     resp.Header.Get("ETag"),
			Versions: result.Versions,
			CachedAt: time.Now(),
		})
		return result.Versions, nil

	default:
		return nil, fmt.Errorf(
			"PyPI returned %d for %s", resp.StatusCode, name,
		)
	}
}
```

---

## Documentation

### Documentation for `FetchVersions` Function

**Purpose and Behavior:**
The `FetchVersions` function in the Go code retrieves package versions from PyPI (Python Package Index) given a package name. It first checks if the version data is cached and fresh, returning it if so. Otherwise, it constructs an HTTP GET request to fetch the latest version information, handling retries and caching responses.

**Key Implementation Details:**
- **Context Handling:** Uses `context.Context` for cancellation and timeout management.
- **Caching:** Utilizes a cache mechanism (`c.cache`) to store and retrieve versions, checking freshness with `IsFresh`.
- **HTTP Request Construction:** Sets headers like `Accept`, `User-Agent`, and `If-None-Match` if an ETag is available.
- **Response Handling:** Decodes the JSON response into a structured object and updates the cache. Handles various HTTP status codes to determine appropriate actions.

**When/Why to Use:**
This function should be used in scenarios where you need to fetch package versions from PyPI, especially when implementing vulnerability scanners or dependency management tools that require up-to-date version information.

**Patterns/Gotchas:**
- **Error Handling:** Comprehensive error handling ensures all potential issues are caught and reported.
- **Caching Logic:** The function efficiently checks cache freshness and updates it as needed, optimizing repeated requests for the same package.
- **HTTP Client Customization:** The use of `http.NewRequestWithContext` and custom retry logic (`c.doWithRetry`) highlights Go's flexibility in handling network operations.

---

*Generated by CodeWorm on 2026-01-26 13:42*
