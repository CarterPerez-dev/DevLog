# FetchDockerData

**Type:** Documentation
**Repository:** Yoshi-Audit
**File:** internal/ui/dockertab/dockertab.go
**Language:** go
**Lines:** 84-182
**Complexity:** 17.0

---

## Source Code

```go
func FetchDockerData(cfg config.Config) tea.Msg {
	cli, err := docker.NewClient()
	if err != nil {
		return DockerDataMsg{Err: err}
	}
	defer cli.Close()

	images, containers, volumes, cache, err := cli.GetDiskUsage()
	if err != nil {
		return DockerDataMsg{Err: err}
	}

	pe := docker.NewProtectionEngine(cfg.ProtectionPatterns)

	var imgItems []DockerItem
	for _, img := range images {
		cat := docker.CategorizeImage(img, cfg.ProtectionPatterns)
		name := img.Repository
		if img.Tag != "<none>" {
			name = img.Repository + ":" + img.Tag
		}
		extra := ""
		if img.Dangling {
			extra = "dangling"
		}
		if img.Containers > 0 {
			extra = fmt.Sprintf("%d containers", img.Containers)
		}
		state := Unselected
		fullName := img.Repository
		if img.Tag != "<none>" {
			fullName = img.Repository + ":" + img.Tag
		}
		if pe.IsProtected(fullName) || pe.IsProtected(img.Repository) {
			state = Protected
		}
		imgItems = append(imgItems, DockerItem{
			ID:       img.ID,
			Name:     name,
			Size:     img.Size,
			Age:      formatAge(img.Created),
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	var ctrItems []DockerItem
	for _, ctr := range containers {
		cat := docker.CategorizeContainer(ctr, cfg.ProtectionPatterns)
		state := Unselected
		if pe.IsProtected(ctr.Name) || pe.IsProtected(ctr.Image) {
			state = Protected
		}
		extra := ctr.State
		if ctr.Running {
			extra = "running"
		}
		ctrItems = append(ctrItems, DockerItem{
			ID:       ctr.ID,
			Name:     ctr.Name,
			Size:     ctr.Size,
			Age:      formatAge(ctr.Created),
			Status:   ctr.Status,
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	var volItems []DockerItem
	for _, vol := range volumes {
		cat := docker.CategorizeVolume(vol, cfg.ProtectionPatterns)
		state := Unselected
		if pe.IsProtected(vol.Name) {
			state = Protected
		}
		extra := ""
		if vol.Links > 0 {
			extra = fmt.Sprintf("%d links", vol.Links)
		}
		volItems = append(volItems, DockerItem{
			ID:       vol.Name,
			Name:     vol.Name,
			Size:     vol.Size,
			Age:      formatAge(vol.Created),
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	return DockerDataMsg{
		Images:     imgItems,
		Containers: ctrItems,
		Volumes:    volItems,
		BuildCache: cache.TotalSize,
	}
}
```

---

## Documentation

### Purpose and Behavior

The `FetchDockerData` function in the provided Go code retrieves disk usage statistics for Docker images, containers, and volumes from a Docker client. It then categorizes these resources based on predefined protection patterns and returns them as structured data.

### Key Implementation Details

- **Error Handling**: The function checks for errors when creating and closing the Docker client, ensuring proper resource management.
- **Resource Categorization**: Images, containers, and volumes are categorized using `docker.CategorizeImage`, `docker.CategorizeContainer`, and `docker.CategorizeVolume` functions respectively.
- **Protection Engine**: A `DockerProtectionEngine` instance is used to determine if a resource should be considered "protected" based on the provided configuration.

### When/Why to Use This Code

This function is crucial for generating detailed reports or visualizations of Docker resources, especially in environments where security and compliance are paramount. It can be used in audit tools, monitoring systems, or any application that needs to understand the state of a Docker environment.

### Patterns and Gotchas

- **Resource Management**: The use of `defer cli.Close()` ensures that the Docker client is properly closed after usage.
- **Categorization Logic**: The categorization logic for images, containers, and volumes is encapsulated in separate functions, promoting code reusability and maintainability.
- **Potential Performance Issues**: Iterating over large numbers of Docker resources can be resource-intensive. Ensure proper performance tuning if dealing with a vast number of resources.

This function exemplifies Go's emphasis on clear, modular design and robust error handling.

---

*Generated by CodeWorm on 2026-02-28 22:20*
