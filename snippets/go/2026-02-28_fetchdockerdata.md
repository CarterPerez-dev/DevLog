# FetchDockerData

**Type:** Documentation
**Repository:** Yoshi-Audit
**File:** internal/ui/dockertab/dockertab.go
**Language:** go
**Lines:** 84-182
**Complexity:** 17.0

---

## Source Code

```go
func FetchDockerData(cfg config.Config) tea.Msg {
	cli, err := docker.NewClient()
	if err != nil {
		return DockerDataMsg{Err: err}
	}
	defer cli.Close()

	images, containers, volumes, cache, err := cli.GetDiskUsage()
	if err != nil {
		return DockerDataMsg{Err: err}
	}

	pe := docker.NewProtectionEngine(cfg.ProtectionPatterns)

	var imgItems []DockerItem
	for _, img := range images {
		cat := docker.CategorizeImage(img, cfg.ProtectionPatterns)
		name := img.Repository
		if img.Tag != "<none>" {
			name = img.Repository + ":" + img.Tag
		}
		extra := ""
		if img.Dangling {
			extra = "dangling"
		}
		if img.Containers > 0 {
			extra = fmt.Sprintf("%d containers", img.Containers)
		}
		state := Unselected
		fullName := img.Repository
		if img.Tag != "<none>" {
			fullName = img.Repository + ":" + img.Tag
		}
		if pe.IsProtected(fullName) || pe.IsProtected(img.Repository) {
			state = Protected
		}
		imgItems = append(imgItems, DockerItem{
			ID:       img.ID,
			Name:     name,
			Size:     img.Size,
			Age:      formatAge(img.Created),
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	var ctrItems []DockerItem
	for _, ctr := range containers {
		cat := docker.CategorizeContainer(ctr, cfg.ProtectionPatterns)
		state := Unselected
		if pe.IsProtected(ctr.Name) || pe.IsProtected(ctr.Image) {
			state = Protected
		}
		extra := ctr.State
		if ctr.Running {
			extra = "running"
		}
		ctrItems = append(ctrItems, DockerItem{
			ID:       ctr.ID,
			Name:     ctr.Name,
			Size:     ctr.Size,
			Age:      formatAge(ctr.Created),
			Status:   ctr.Status,
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	var volItems []DockerItem
	for _, vol := range volumes {
		cat := docker.CategorizeVolume(vol, cfg.ProtectionPatterns)
		state := Unselected
		if pe.IsProtected(vol.Name) {
			state = Protected
		}
		extra := ""
		if vol.Links > 0 {
			extra = fmt.Sprintf("%d links", vol.Links)
		}
		volItems = append(volItems, DockerItem{
			ID:       vol.Name,
			Name:     vol.Name,
			Size:     vol.Size,
			Age:      formatAge(vol.Created),
			Category: cat,
			State:    state,
			Extra:    extra,
		})
	}

	return DockerDataMsg{
		Images:     imgItems,
		Containers: ctrItems,
		Volumes:    volItems,
		BuildCache: cache.TotalSize,
	}
}
```

---

## Documentation

### Documentation for `FetchDockerData`

**Purpose and Behavior:**
`FetchDockerData` is a function that retrieves disk usage data from Docker, categorizes it based on protection patterns, and returns structured data representing images, containers, volumes, and build cache. The function handles errors gracefully by returning appropriate error messages.

**Key Implementation Details:**
- **Error Handling:** Uses `docker.NewClient()` to establish a connection and `cli.GetDiskUsage()` to fetch disk usage details.
- **Categorization:** Utilizes `docker.CategorizeImage`, `docker.CategorizeContainer`, and `docker.CategorizeVolume` for categorizing Docker objects based on protection patterns.
- **State Determination:** Determines the state of each object (protected or not) using `pe.IsProtected`.
- **Data Structures:** Returns a structured message containing categorized items for images, containers, volumes, and build cache.

**When/Why to Use:**
Use this function when you need to gather detailed disk usage information from Docker in a structured format. It is particularly useful for audit or monitoring purposes where categorization based on protection patterns is required.

**Patterns/Gotchas:**
- **Error Propagation:** Ensure proper error handling, as the function returns an `err` value if any step fails.
- **Resource Management:** The `cli.Close()` call ensures that resources are properly released after use.
- **Categorization Logic:** Custom categorization logic is embedded within the function, which may need to be updated based on changing requirements.

---

*Generated by CodeWorm on 2026-02-28 22:20*
