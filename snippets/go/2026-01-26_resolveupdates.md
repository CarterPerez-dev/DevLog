# resolveUpdates

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/simple-vulnerability-scanner/internal/cli/update.go
**Language:** go
**Lines:** 258-343
**Complexity:** 10.0

---

## Source Code

```go
func resolveUpdates(
	deps []types.Dependency,
	versionMap map[string][]string,
	safe bool,
	includePrerelease bool,
) ([]types.UpdateResult, map[string]string) {
	var results []types.UpdateResult
	specs := make(map[string]string)

	for _, dep := range deps {
		versions, ok := versionMap[dep.Name]
		if !ok {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "not found on PyPI",
			})
			continue
		}

		currentStr := pyproject.ExtractMinVersion(dep.Spec)
		if currentStr == "" {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "no version specifier",
			})
			continue
		}

		current, err := pypi.ParseVersion(currentStr)
		if err != nil {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "unparseable version",
			})
			continue
		}

		var latest pypi.Version
		if includePrerelease {
			latest, err = latestAny(versions)
		} else {
			latest, err = pypi.LatestStable(versions)
		}
		if err != nil {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  err.Error(),
			})
			continue
		}

		if latest.Compare(current) <= 0 {
			continue
		}

		change := pypi.ClassifyChange(current, latest)
		if safe && change == pypi.Major {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				OldVer:  current.String(),
				NewVer:  latest.String(),
				Change:  change.String(),
				Skipped: true,
				Reason:  "major bump (use --all to include)",
			})
			continue
		}

		newSpec := ">=" + latest.String()
		results = append(results, types.UpdateResult{
			Name:    dep.Name,
			OldVer:  current.String(),
			NewVer:  latest.String(),
			OldSpec: dep.Spec,
			NewSpec: newSpec,
			Change:  change.String(),
		})
		specs[dep.Name] = newSpec
	}

	return results, specs
}
```

---

## Documentation

### Documentation for `resolveUpdates` Function

**Purpose and Behavior:**
The `resolveUpdates` function in the `PROJECTS/simple-vulnerability-scanner/internal/cli/update.go` file is designed to determine whether updates are available for a list of dependencies. It checks each dependency against its latest version on PyPI (Python Package Index) and returns a list of update results, along with any new version specifications.

**Key Implementation Details:**
- The function takes in a slice of `Dependency`, a map mapping package names to their versions, a boolean flag for safety, and another for including prereleases.
- It iterates over each dependency, checks if the current version is available, parses it, and compares it with the latest version.
- If an update is found, it classifies the change (e.g., minor, major) and updates the specification accordingly.

**When/Why to Use:**
Use this function when you need to automate the process of identifying and documenting potential updates for dependencies in a Go project. It's particularly useful during pre-release or continuous integration pipelines where automated dependency management is crucial.

**Patterns and Gotchas:**
- The function handles errors gracefully by skipping problematic dependencies.
- It uses PyPIâ€™s `latestStable` and `latestAny` functions to determine the latest version, which can be a gotcha if these functions are not properly implemented or return unexpected results.
- The safety flag ensures that major updates are skipped unless explicitly allowed, which is a common requirement in production environments.

---

*Generated by CodeWorm on 2026-01-26 12:28*
