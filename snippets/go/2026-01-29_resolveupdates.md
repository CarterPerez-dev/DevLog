# resolveUpdates

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/simple-vulnerability-scanner/internal/cli/update.go
**Language:** go
**Lines:** 404-504
**Complexity:** 12.0

---

## Source Code

```go
func resolveUpdates(
	deps []types.Dependency,
	versionMap map[string][]string,
	safe bool,
	includePrerelease bool,
	ignoreDeps []string,
) ([]types.UpdateResult, map[string]string) {
	var results []types.UpdateResult
	specs := make(map[string]string)

	ignoreSet := make(map[string]bool, len(ignoreDeps))
	for _, name := range ignoreDeps {
		ignoreSet[pypi.NormalizeName(name)] = true
	}

	for _, dep := range deps {
		if ignoreSet[pypi.NormalizeName(dep.Name)] {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "ignored in config",
			})
			continue
		}

		versions, ok := versionMap[dep.Name]
		if !ok {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "not found on PyPI",
			})
			continue
		}

		currentStr := pyproject.ExtractMinVersion(dep.Spec)
		if currentStr == "" {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "no version specifier",
			})
			continue
		}

		current, err := pypi.ParseVersion(currentStr)
		if err != nil {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  "unparseable version",
			})
			continue
		}

		var latest pypi.Version
		if includePrerelease {
			latest, err = latestAny(versions)
		} else {
			latest, err = pypi.LatestStable(versions)
		}
		if err != nil {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				Skipped: true,
				Reason:  err.Error(),
			})
			continue
		}

		if latest.Compare(current) <= 0 {
			continue
		}

		change := pypi.ClassifyChange(current, latest)
		if safe && change == pypi.Major {
			results = append(results, types.UpdateResult{
				Name:    dep.Name,
				OldVer:  current.String(),
				NewVer:  latest.String(),
				Change:  change.String(),
				Skipped: true,
				Reason:  "major bump (use --all to include)",
			})
			continue
		}

		newSpec := ">=" + latest.String()
		results = append(results, types.UpdateResult{
			Name:    dep.Name,
			OldVer:  current.String(),
			NewVer:  latest.String(),
			OldSpec: dep.Spec,
			NewSpec: newSpec,
			Change:  change.String(),
		})
		specs[dep.Name] = newSpec
	}

	return results, specs
}
```

---

## Documentation

### Documentation for `resolveUpdates` Function

**Purpose and Behavior:**
The `resolveUpdates` function in the Go code iterates through a list of dependencies, checks their versions against available updates on PyPI (Python Package Index), and generates update results. It handles version parsing, comparison, and classification to determine if an update is necessary.

**Key Implementation Details:**
- **Input Parameters:** The function takes `deps` (dependencies), `versionMap` (mapping of package names to their versions), `safe` (boolean for safe updates), `includePrerelease` (boolean for including prereleases), and `ignoreDeps` (list of dependencies to ignore).
- **Output:** It returns a list of `UpdateResult` objects indicating whether an update is available, along with the old and new version specifications.
- **Error Handling:** The function gracefully handles errors during version parsing and comparison.

**When/Why to Use:**
Use this function in scenarios where you need to check for updates on dependencies specified in your project. It's particularly useful when integrating a dependency management tool or performing automated vulnerability scans, ensuring that only safe updates are considered unless explicitly allowed.

**Patterns/Gotchas:**
- **Safe Mode:** The `safe` parameter ensures that major version changes are skipped unless the `--all` flag is provided.
- **Version Parsing and Comparison:** Ensure that all versions are correctly parsed and compared using Go's `pypi.ParseVersion` and `Compare` methods to avoid unexpected behavior.

This function embodies best practices in error handling, dependency management, and safe updates, making it a robust component for any Go-based project.

---

*Generated by CodeWorm on 2026-01-29 07:12*
