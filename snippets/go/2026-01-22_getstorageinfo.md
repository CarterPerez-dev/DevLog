# GetStorageInfo

**Repository:** angelamos-operations
**File:** Docker-Kentros/internal/docker/system.go
**Language:** go
**Lines:** 53-146
**Complexity:** 13.0

---

## Source Code

```go
func (c *Client) GetStorageInfo(
	ctx context.Context,
) (*model.StorageInfo, error) {
	c.mu.RLock()
	defer c.mu.RUnlock()

	usage, err := c.cli.DiskUsage(ctx, types.DiskUsageOptions{})
	if err != nil {
		return nil, fmt.Errorf("getting disk usage: %w", err)
	}

	info := &model.StorageInfo{
		Details: model.StorageDetails{
			Images:     make([]model.ImageInfo, 0),
			Volumes:    make([]model.VolumeInfo, 0),
			BuildCache: make([]model.CacheInfo, 0),
		},
	}

	for _, img := range usage.Images {
		info.ImagesSize += uint64(img.Size)
		repoTag := "<none>:<none>"
		repo := "<none>"
		tag := "<none>"
		if len(img.RepoTags) > 0 {
			repoTag = img.RepoTags[0]
			parts := strings.Split(repoTag, ":")
			if len(parts) >= 1 {
				repo = parts[0]
			}
			if len(parts) >= 2 {
				tag = parts[1]
			}
		}

		info.Details.Images = append(info.Details.Images, model.ImageInfo{
			ID:         img.ID,
			Repository: repo,
			Tag:        tag,
			Size:       uint64(img.Size),
			InUse:      img.Containers > 0,
		})
	}

	for _, ctr := range usage.Containers {
		info.ContainersSize += uint64(ctr.SizeRw)
	}

	for _, vol := range usage.Volumes {
		size := int64(0)
		if vol.UsageData != nil {
			size = vol.UsageData.Size
		}
		info.VolumesSize += uint64(size)

		inUse := false
		if vol.UsageData != nil {
			inUse = vol.UsageData.RefCount > 0
		}

		info.Details.Volumes = append(info.Details.Volumes, model.VolumeInfo{
			Name:   vol.Name,
			Driver: vol.Driver,
			Size:   uint64(size),
			InUse:  inUse,
		})
	}

	for _, cache := range usage.BuildCache {
		info.BuildCacheSize += uint64(cache.Size)

		info.Details.BuildCache = append(
			info.Details.BuildCache,
			model.CacheInfo{
				ID:    cache.ID,
				Type:  cache.Type,
				Size:  uint64(cache.Size),
				InUse: cache.InUse,
			},
		)
	}

	info.TotalSize = info.ImagesSize + info.ContainersSize + info.VolumesSize + info.BuildCacheSize

	unusedImages := uint64(0)
	for _, img := range usage.Images {
		if img.Containers == 0 {
			unusedImages += uint64(img.Size)
		}
	}
	info.Reclaimable = unusedImages + info.BuildCacheSize

	return info, nil
}
```

---

## Documentation

### Documentation for `GetStorageInfo` Function

**Purpose and Behavior:**
The `GetStorageInfo` function retrieves detailed storage information from a Docker client, including disk usage statistics for images, containers, volumes, and build cache. It returns a structured `model.StorageInfo` object containing this data.

**Key Implementation Details:**
1. **Context Management:** The function uses a read lock on the client's mutex to ensure thread safety.
2. **Disk Usage Retrieval:** It calls `c.cli.DiskUsage()` with options to fetch detailed usage information.
3. **Data Aggregation:** The function iterates over images, containers, volumes, and build cache entries, aggregating size data into structured formats.
4. **Error Handling:** Any errors during disk usage retrieval are wrapped in a user-friendly error message.

**When/Why to Use:**
This function is essential for monitoring storage utilization within Docker environments. It can be used by system administrators or monitoring tools to track and manage storage resources efficiently.

**Patterns and Gotchas:**
- **Error Propagation:** Always check the returned error, as it may contain useful diagnostic information.
- **Concurrency Safety:** The use of a mutex ensures safe concurrent access but could impact performance in highly concurrent environments.
- **Resource Management:** Ensure that `ctx` is properly managed to avoid unnecessary resource consumption.

This function provides a comprehensive view of storage usage and can help in making informed decisions about storage management.

---

*Generated by CodeWorm on 2026-01-22 18:03*
