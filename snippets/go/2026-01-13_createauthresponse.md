# createAuthResponse

**Repository:** fullstack-template
**File:** backends/go-backend/internal/auth/service.go
**Language:** go
**Lines:** 352-411
**Complexity:** 5.0

---

## Source Code

```go
func (s *Service) createAuthResponse(
	ctx context.Context,
	user *UserInfo,
	userAgent, ipAddress, familyID string,
	oldTokenID *string,
) (*AuthResponse, error) {
	accessToken, err := s.jwt.CreateAccessToken(AccessTokenClaims{
		UserID:       user.ID,
		Role:         user.Role,
		Tier:         user.Tier,
		TokenVersion: user.TokenVersion,
	})
	if err != nil {
		return nil, fmt.Errorf("create access token: %w", err)
	}

	refreshData, err := s.jwt.CreateRefreshToken(user.ID, familyID)
	if err != nil {
		return nil, fmt.Errorf("create refresh token: %w", err)
	}

	newTokenID := uuid.New().String()

	refreshTokenEntity := &RefreshToken{
		ID:        newTokenID,
		UserID:    user.ID,
		TokenHash: refreshData.Hash,
		FamilyID:  refreshData.FamilyID,
		ExpiresAt: refreshData.ExpiresAt,
		UserAgent: userAgent,
		IPAddress: ipAddress,
	}

	if err := s.repo.Create(ctx, refreshTokenEntity); err != nil {
		return nil, fmt.Errorf("store refresh token: %w", err)
	}

	if oldTokenID != nil {
		//nolint:errcheck // best-effort token chain tracking
		_ = s.repo.MarkAsUsed(ctx, *oldTokenID, newTokenID)
	}

	return &AuthResponse{
		User: UserResponse{
			ID:        user.ID,
			Email:     user.Email,
			Name:      user.Name,
			Role:      user.Role,
			Tier:      user.Tier,
			CreatedAt: time.Now(),
		},
		Tokens: TokenResponse{
			AccessToken:  accessToken,
			RefreshToken: refreshData.Token,
			TokenType:    "Bearer",
			ExpiresIn:    int(15 * time.Minute / time.Second),
			ExpiresAt:    time.Now().Add(15 * time.Minute),
		},
	}, nil
}
```

---

## Documentation

### Documentation for `createAuthResponse` Function

**Purpose and Behavior:**
The `createAuthResponse` function in the Go backend handles the creation of an authentication response, including generating access and refresh tokens for a user. It returns an `AuthResponse` struct containing the generated tokens along with user information.

**Key Implementation Details:**
1. **Context Parameter:** The function takes a context parameter to handle cancellation and timeouts.
2. **Token Generation:** It uses JWT (JSON Web Token) to create both access and refresh tokens, storing relevant claims in the token claims structure.
3. **Repository Interaction:** The generated refresh token is stored in the database using the repository's `Create` method. If an old token ID is provided, it attempts to mark the old token as used by the new one.
4. **Error Handling:** Errors during token creation or storage are returned directly.

**When/Why to Use:**
This function should be called whenever a user needs to authenticate and receive tokens for accessing protected resources. It ensures secure token management by generating both access and refresh tokens, which can be used to maintain session integrity.

**Patterns and Gotchas:**
- **JWT Claims:** The `AccessTokenClaims` struct is used to include necessary claims in the JWT.
- **Error Handling:** Best-effort tracking of old tokens using a comment and `_ = s.repo.MarkAsUsed(ctx, *oldTokenID, newTokenID)` suggests this operation should not block the main flow but is important for logging or auditing purposes.
- **UUID Generation:** The `uuid.New().String()` method generates a unique token ID for each refresh token.

This function exemplifies Go's idiomatic use of error handling and context management in concurrent operations.

---

*Generated by CodeWorm on 2026-01-13 02:12*
