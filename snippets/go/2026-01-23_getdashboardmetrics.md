# GetDashboardMetrics

**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/metrics/service.go
**Language:** go
**Lines:** 107-198
**Complexity:** 7.0

---

## Source Code

```go
func (s *Service) GetDashboardMetrics(ctx context.Context) (*DashboardMetrics, error) {
	serverStatus, err := s.repo.GetServerStatus(ctx)
	if err != nil {
		return nil, fmt.Errorf("get server status: %w", err)
	}

	dbStats, err := s.repo.GetDatabaseStats(ctx, s.database)
	if err != nil {
		return nil, fmt.Errorf("get database stats: %w", err)
	}

	databases, err := s.repo.ListDatabases(ctx)
	if err != nil {
		return nil, fmt.Errorf("list databases: %w", err)
	}

	activeOps, err := s.repo.GetCurrentOps(ctx)
	if err != nil {
		return nil, fmt.Errorf("get current ops: %w", err)
	}

	paidSubs, err := s.repo.GetTruePaidSubscribers(ctx, s.database)
	if err != nil {
		return nil, fmt.Errorf("get paid subscribers: %w", err)
	}

	totalOps := serverStatus.Opcounters.Insert +
		serverStatus.Opcounters.Query +
		serverStatus.Opcounters.Update +
		serverStatus.Opcounters.Delete +
		serverStatus.Opcounters.Getmore +
		serverStatus.Opcounters.Command

	currentOps := make([]CurrentOperation, 0, len(activeOps))
	for _, op := range activeOps {
		collection := extractCollection(op.Namespace)
		currentOps = append(currentOps, CurrentOperation{
			OpID:             op.OpID,
			Type:             op.Op,
			Namespace:        op.Namespace,
			Collection:       collection,
			MicrosecsRunning: op.MicrosecsRunning,
			MillisRunning:    float64(op.MicrosecsRunning) / 1000.0,
			Client:           op.Client,
		})
	}

	return &DashboardMetrics{
		Timestamp: time.Now(),
		Server: ServerMetrics{
			Host:      serverStatus.Host,
			Version:   serverStatus.Version,
			UptimeSec: serverStatus.Uptime,
		},
		Database: DatabaseMetrics{
			Name:           s.database,
			Collections:    dbStats.Collections,
			Documents:      dbStats.Objects,
			DataSizeMB:     bytesToMB(dbStats.DataSize),
			StorageSizeMB:  bytesToMB(dbStats.StorageSize),
			Indexes:        dbStats.Indexes,
			IndexSizeMB:    bytesToMB(dbStats.IndexSize),
			TotalDatabases: len(databases),
		},
		Connections: ConnectionStats{
			Current:      serverStatus.Connections.Current,
			Available:    serverStatus.Connections.Available,
			TotalCreated: serverStatus.Connections.TotalCreated,
		},
		Operations: OpCounters{
			Insert:  serverStatus.Opcounters.Insert,
			Query:   serverStatus.Opcounters.Query,
			Update:  serverStatus.Opcounters.Update,
			Delete:  serverStatus.Opcounters.Delete,
			Getmore: serverStatus.Opcounters.Getmore,
			Command: serverStatus.Opcounters.Command,
			Total:   totalOps,
		},
		Memory: MemoryStats{
			ResidentMB: serverStatus.Mem.Resident,
			VirtualMB:  serverStatus.Mem.Virtual,
		},
		Network: NetworkStats{
			BytesInMB:   bytesToMB(float64(serverStatus.Network.BytesIn)),
			BytesOutMB:  bytesToMB(float64(serverStatus.Network.BytesOut)),
			NumRequests: serverStatus.Network.NumRequests,
		},
		ActiveOps:       len(activeOps),
		CurrentOps:      currentOps,
		PaidSubscribers: paidSubs,
	}, nil
}
```

---

## Documentation

### Documentation for `GetDashboardMetrics` Function

**Purpose and Behavior:**
The `GetDashboardMetrics` function in the `Service` struct retrieves various metrics related to server status, database operations, and active operations. It constructs a comprehensive `DashboardMetrics` object containing detailed information such as server uptime, database statistics, operation counts, memory usage, network activity, and current active operations.

**Key Implementation Details:**
- The function uses error handling with `fmt.Errorf` to propagate errors.
- It sequentially fetches data from the repository using context-aware calls.
- Metrics are calculated based on server status and active operations.
- The function returns a well-structured `DashboardMetrics` object along with any potential errors.

**When/Why to Use This Code:**
This code is essential for generating real-time dashboard metrics, providing insights into system performance and database health. It should be used in monitoring systems or dashboards where up-to-date operational data is critical.

**Patterns and Gotchas:**
- The function adheres to Go's error handling best practices by using `fmt.Errorf` with the `%w` verb.
- It employs goroutines implicitly through context management, ensuring that operations are asynchronous and non-blocking.
- Be cautious of potential race conditions when accessing shared resources like databases or server status. Ensure proper synchronization if multiple services access these resources concurrently.

This function is a prime example of how to structure complex data retrieval in Go while maintaining readability and robust error handling.

---

*Generated by CodeWorm on 2026-01-23 18:31*
