# Update

**Type:** Documentation
**Repository:** Yoshi-Audit
**File:** internal/ui/app.go
**Language:** go
**Lines:** 79-165
**Complexity:** 27.0

---

## Source Code

```go
func (a App) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	if a.showSplash {
		if wsm, ok := msg.(tea.WindowSizeMsg); ok {
			a.width = wsm.Width
			a.height = wsm.Height
		}
		var cmd tea.Cmd
		a.splash, cmd = a.splash.Update(msg)
		if a.splash.Done() {
			a.showSplash = false
			return a, a.initDataFetches()
		}
		return a, cmd
	}

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		a.width = msg.Width
		a.height = msg.Height
	case dashboard.StatsMsg:
		a.dashboard, _ = a.dashboard.Update(msg)
	case dockertab.DockerDataMsg:
		a.dockerTab, _ = a.dockerTab.Update(msg)
	case audittab.AuditDataMsg:
		a.auditTab, _ = a.auditTab.Update(msg)
	case dockertab.DeleteResultMsg:
		var cmd tea.Cmd
		a.dockerTab, cmd = a.dockerTab.Update(msg)
		return a, cmd
	case tea.KeyMsg:
		if a.activeTab == TabDocker {
			switch msg.String() {
			case "q", "ctrl+c":
				return a, tea.Quit
			case "tab":
				a.activeTab = (a.activeTab + 1) % 3
			case "r":
				cfg := a.cfg
				return a, func() tea.Msg { return dockertab.FetchDockerData(cfg) }
			default:
				var cmd tea.Cmd
				a.dockerTab, cmd = a.dockerTab.Update(msg)
				return a, cmd
			}
			return a, nil
		}

		if a.activeTab == TabAudit {
			switch msg.String() {
			case "q", "ctrl+c":
				return a, tea.Quit
			case "tab":
				a.activeTab = (a.activeTab + 1) % 3
			default:
				var cmd tea.Cmd
				a.auditTab, cmd = a.auditTab.Update(msg)
				return a, cmd
			}
			return a, nil
		}

		switch msg.String() {
		case "q", "ctrl+c":
			return a, tea.Quit
		case "1":
			a.activeTab = TabDashboard
		case "2":
			a.activeTab = TabDocker
		case "3":
			a.activeTab = TabAudit
		case "tab":
			a.activeTab = (a.activeTab + 1) % 3
		case "p":
			a.paused = !a.paused
		case "m", "c", "g", "n":
			if a.activeTab == TabDashboard {
				a.dashboard, _ = a.dashboard.Update(msg)
			}
		}
	case TickMsg:
		if !a.paused {
			return a, tea.Batch(doTick(), dashboard.FetchStats)
		}
		return a, doTick()
	}
	return a, nil
}
```

---

## Documentation

### Documentation for `Update` Function in Go

**Purpose and Behavior:**
The `Update` function handles the state updates and command generation in response to user input or other messages within a terminal UI application. It processes various message types, updating models like splash screens, dashboards, dockertabs, and audittabs accordingly.

**Key Implementation Details:**
- **Splash Handling:** Updates the splash screen model if it is active.
- **Tab Navigation:** Manages switching between different tabs (Dashboard, Docker, Audit) based on user input.
- **Tick Message:** Handles periodic updates when not paused, executing batch commands for tick and dashboard stats fetch.

**When/Why to Use:**
This function is crucial for maintaining the state of a complex UI application. It ensures that all components are updated correctly in response to user actions or system events. Use it whenever you need to manage state transitions and command generation in a Go-based terminal UI application.

**Patterns/Gotchas:**
- **Error Handling:** The use of `_` when unpacking model updates hides potential errors, which should be addressed.
- **Tick Message Batch Command:** Combining multiple commands with `tea.Batch` is an efficient way to handle periodic tasks without blocking the main loop.
- **Active Tab Management:** Switching between tabs requires careful handling to ensure correct state transitions and input processing.

---

*Generated by CodeWorm on 2026-02-28 20:56*
