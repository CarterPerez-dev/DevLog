# Update

**Type:** Documentation
**Repository:** Yoshi-Audit
**File:** internal/ui/dockertab/dockertab.go
**Language:** go
**Lines:** 184-284
**Complexity:** 33.0

---

## Source Code

```go
func (dt DockerTab) Update(msg tea.Msg) (DockerTab, tea.Cmd) {
	switch msg := msg.(type) {
	case DockerDataMsg:
		if msg.Err != nil {
			dt.err = msg.Err
			return dt, nil
		}
		dt.images = msg.Images
		dt.containers = msg.Containers
		dt.volumes = msg.Volumes
		dt.buildCache = msg.BuildCache
		dt.err = nil
	case DeleteResultMsg:
		if msg.Err != nil {
			dt.err = msg.Err
		}
		dt.confirming = false
		dt.confirmMsg = ""
		return dt, func() tea.Msg { return FetchDockerData(dt.config) }
	case tea.KeyMsg:
		if dt.confirming {
			switch msg.String() {
			case "y":
				return dt, dt.executeDelete()
			case "escape", "n":
				dt.confirming = false
				dt.confirmMsg = ""
			}
			return dt, nil
		}

		switch msg.String() {
		case "i":
			dt.subTab = SubTabImages
			dt.cursor = 0
		case "c":
			dt.subTab = SubTabContainers
			dt.cursor = 0
		case "v":
			dt.subTab = SubTabVolumes
			dt.cursor = 0
		case "n":
			dt.subTab = SubTabNetworks
			dt.cursor = 0
		case "up", "k":
			if dt.cursor > 0 {
				dt.cursor--
			}
		case "down", "j":
			items := dt.currentItems()
			if dt.cursor < len(items)-1 {
				dt.cursor++
			}
		case " ":
			items := dt.currentItems()
			if dt.cursor < len(items) && items[dt.cursor].State != Protected {
				if items[dt.cursor].State == Selected {
					items[dt.cursor].State = Unselected
				} else {
					items[dt.cursor].State = Selected
				}
				dt.setCurrentItems(items)
			}
		case "a":
			items := dt.currentItems()
			for idx := range items {
				if items[idx].State != Protected {
					items[idx].State = Selected
				}
			}
			dt.setCurrentItems(items)
		case "p":
			items := dt.currentItems()
			if dt.cursor < len(items) {
				if items[dt.cursor].State == Protected {
					items[dt.cursor].State = Unselected
					dt.protection.Unprotect(items[dt.cursor].Name)
				} else {
					items[dt.cursor].State = Protected
					dt.protection.Protect(items[dt.cursor].Name)
				}
				dt.setCurrentItems(items)
			}
		case "d":
			selected := dt.selectedItems()
			if len(selected) > 0 {
				dt.confirming = true
				dt.confirmMsg = dt.buildConfirmMsg(selected)
			}
		case "1":
			dt.applyPreset(0)
		case "2":
			dt.applyPreset(1)
		case "3":
			dt.applyPreset(2)
		case "4":
			dt.applyPreset(3)
		}
	}
	return dt, nil
}
```

---

## Documentation

### Documentation for `Update` Function in DockerTab

**Purpose and Behavior:**
The `Update` function handles state updates and commands based on user input or messages in the DockerTab UI component. It processes different message types, such as `DockerDataMsg`, `DeleteResultMsg`, and key presses to update tab content, cursor position, selected items, and confirmation states.

**Key Implementation Details:**
- **Error Handling:** Updates error state (`dt.err`) based on message type.
- **State Management:** Manages sub-tabs (images, containers, volumes, networks) and cursor positions.
- **Selection Logic:** Handles item selection and protection states using key presses.
- **Confirmation Mechanism:** Implements a confirmation dialog for deletion actions.

**When/Why to Use:**
Use this function when you need to update the UI state of DockerTab based on user input or external messages. It is essential for maintaining the correct display and behavior of the tab, especially during data fetching and user interaction.

**Patterns/Gotchas:**
- **Error Handling:** Always check for non-nil errors in `DockerDataMsg`.
- **State Updates:** Ensure that state transitions (e.g., confirming deletion) are handled correctly to avoid unexpected UI behaviors.
- **Selection Logic:** The function uses a cursor-based selection mechanism, which can be complex if not implemented carefully.

---

*Generated by CodeWorm on 2026-02-28 21:11*
