# Update

**Type:** Documentation
**Repository:** Yoshi-Audit
**File:** internal/ui/audittab/audittab.go
**Language:** go
**Lines:** 118-187
**Complexity:** 23.0

---

## Source Code

```go
func (at AuditTab) Update(msg tea.Msg) (AuditTab, tea.Cmd) {
	switch msg := msg.(type) {
	case AuditDataMsg:
		if msg.Err != nil {
			at.err = msg.Err
			at.scanning = false
			return at, nil
		}
		at.findings = msg.Findings
		at.summary = msg.Summary
		at.lastScan = time.Now()
		at.scanning = false
		at.err = nil
	case tea.KeyMsg:
		filtered := at.filteredFindings()
		switch msg.String() {
		case "r":
			at.scanning = true
			scanner := at.scanner
			rssHistory := at.rssHistory
			return at, func() tea.Msg {
				return FetchAuditData(scanner, rssHistory)
			}
		case "up", "k":
			if at.cursor > 0 {
				at.cursor--
			}
		case "down", "j":
			if at.cursor < len(filtered)-1 {
				at.cursor++
			}
		case "a":
			if at.cursor < len(filtered) && at.baseline != nil {
				f := filtered[at.cursor]
				at.baseline.Add(f.Name)
				at.baseline.Save(config.DefaultBaselinePath())
				at.scanning = true
				scanner := at.scanner
				rssHistory := at.rssHistory
				return at, func() tea.Msg {
					return FetchAuditData(scanner, rssHistory)
				}
			}
		case "i":
			if at.cursor < len(filtered) {
				target := filtered[at.cursor]
				var newFindings []audit.Finding
				removed := false
				for _, f := range at.findings {
					if !removed && f.PID == target.PID && f.Type == target.Type && f.Name == target.Name {
						removed = true
						continue
					}
					newFindings = append(newFindings, f)
				}
				at.findings = newFindings
				if at.cursor >= len(at.filteredFindings()) && at.cursor > 0 {
					at.cursor--
				}
			}
		case "enter":
			if at.showDetail == at.cursor {
				at.showDetail = -1
			} else {
				at.showDetail = at.cursor
			}
		}
	}
	return at, nil
}
```

---

## Documentation

### Documentation for `Update` Function in Go

**Purpose and Behavior:**
The `Update` function processes incoming messages (`msg`) to update the state of an `AuditTab`. It handles different message types, such as `AuditDataMsg` for updating findings and summary data, and `tea.KeyMsg` for key-based interactions like filtering, adding baseline entries, and toggling detail views.

**Key Implementation Details:**
- **Error Handling:** If `msg.Err` is non-nil in `AuditDataMsg`, it updates the error state and stops scanning.
- **State Management:** It manages cursor positions, findings, and summaries. Key presses trigger actions like fetching new data, navigating through findings, adding baseline entries, or toggling detail views.
- **Concurrency:** The function returns a command to fetch audit data using `tea.Cmd`, enabling asynchronous operations.

**When/Why to Use:**
This function is crucial for the user interface logic of an audit tool. It ensures that state updates are handled correctly and efficiently, providing a responsive and interactive experience. Use it whenever you need to update the UI based on user input or external data.

**Patterns/Gotchas:**
- **Error Handling:** Always check if `msg.Err` is non-nil before proceeding.
- **Concurrency:** The function returns commands for asynchronous operations, which must be handled appropriately in the main loop.
- **State Management:** Properly manage state transitions to avoid unexpected behavior.

---

*Generated by CodeWorm on 2026-02-28 22:06*
