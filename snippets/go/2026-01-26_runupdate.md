# runUpdate

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/simple-vulnerability-scanner/internal/cli/update.go
**Language:** go
**Lines:** 158-229
**Complexity:** 13.0

---

## Source Code

```go
func runUpdate(
	ctx context.Context,
	f *updateFlags,
	dryRun bool,
) error {
	start := time.Now()

	deps, err := pyproject.ParseFile(f.file)
	if err != nil {
		return err
	}

	PrintScanning(len(deps))

	client, err := pypi.NewClient(defaultCacheDir())
	if err != nil {
		return err
	}

	names := make([]string, len(deps))
	for i, d := range deps {
		names[i] = d.Name
	}
	fetched := client.FetchAllVersions(ctx, names)

	versionMap := make(map[string][]string, len(fetched))
	for _, r := range fetched {
		if r.Err == nil {
			versionMap[r.Name] = r.Versions
		}
	}

	updates, updateSpecs := resolveUpdates(
		deps, versionMap, f.safe, f.includePrerelease,
	)

	sortUpdates(updates)

	var vulns map[string][]types.Vulnerability
	if f.scanVulns {
		vulns = scanForVulns(ctx, deps)
	}

	if !dryRun && len(updateSpecs) > 0 {
		if err := pyproject.UpdateFile(f.file, updateSpecs); err != nil {
			return fmt.Errorf("write updates: %w", err)
		}
	}

	PrintUpdates(updates)
	PrintSkipped(updates)

	if vulns != nil {
		PrintVulnerabilities(vulns)
	}

	totalVulns := 0
	for _, vl := range vulns {
		totalVulns += len(vl)
	}

	PrintSummary(types.ScanResult{
		Updates:         updates,
		Vulnerabilities: vulns,
		TotalPackages:   len(deps),
		TotalUpdated:    len(updateSpecs),
		TotalVulns:      totalVulns,
		Duration:        time.Since(start),
	}, !dryRun && len(updateSpecs) > 0)

	return nil
}
```

---

## Documentation

### Documentation for `runUpdate` Function

**Purpose and Behavior:**
The `runUpdate` function in the Go code is designed to process package updates, fetch version information from PyPI, resolve necessary updates, and optionally perform a vulnerability scan. It takes a context (`ctx`), update flags (`f`), and a dry-run flag (`dryRun`) as inputs.

**Key Implementation Details:**
1. **Parsing Dependencies:** The function starts by parsing the `pyproject.toml` file to extract dependencies.
2. **Client Initialization:** A PyPI client is initialized to fetch version information for each dependency name.
3. **Fetching Versions:** It retrieves all available versions for each package and stores them in a map.
4. **Resolving Updates:** The function resolves which updates are necessary based on the provided flags.
5. **Sorting Updates:** The resolved updates are sorted before applying any changes.
6. **Vulnerability Scan (Optional):** If enabled, it scans for vulnerabilities associated with each package.
7. **Applying Changes (Dry-Run Optional):** If not in dry-run mode and there are updates to apply, the function writes the updated `pyproject.toml` file.

**When/Why to Use:**
Use this code when you need to automate the process of checking for and applying package updates while optionally scanning for vulnerabilities. It is particularly useful in CI/CD pipelines or automated maintenance scripts.

**Patterns/Gotchas:**
- **Error Handling:** The function returns an error on any failure, ensuring robustness.
- **Dry-Run Mode:** Allows testing without making actual changes, which is crucial for safety and debugging.
- **Performance Considerations:** Fetching all versions of each package can be resource-intensive; consider optimizing the number of concurrent requests or caching strategies.

---

*Generated by CodeWorm on 2026-01-26 11:15*
