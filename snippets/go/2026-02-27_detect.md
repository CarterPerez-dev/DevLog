# Detect

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/engine/detector.go
**Language:** go
**Lines:** 21-93
**Complexity:** 11.0

---

## Source Code

```go
func (d *Detector) Detect(chunk types.Chunk) []types.Finding { //nolint:gocognit
	lines := strings.Split(chunk.Content, "\n")
	var findings []types.Finding

	matched := d.registry.MatchKeywords(chunk.Content)
	for _, rule := range matched {
		for i, line := range lines {
			matches := rule.Pattern.FindAllStringSubmatchIndex(
				line, -1,
			)
			if len(matches) == 0 {
				continue
			}

			for _, loc := range matches {
				secret := extractSecret(line, loc, rule.SecretGroup)
				if secret == "" {
					continue
				}

				match := line[loc[0]:loc[1]]

				finding := types.Finding{
					RuleID:      rule.ID,
					Description: rule.Description,
					Severity:    rule.Severity,
					Match:       match,
					Secret:      secret,
					FilePath:    chunk.FilePath,
					LineNumber:  chunk.LineStart + i,
					LineContent: line,
					CommitSHA:   chunk.CommitSHA,
					Author:      chunk.Author,
					CommitDate:  chunk.CommitDate,
				}

				if rule.Entropy != nil {
					charset := rules.DetectCharset(secret)
					var charsetStr string
					switch charset {
					case "hex":
						charsetStr = rules.HexCharset
					case "base64":
						charsetStr = rules.Base64Charset
					default:
						charsetStr = rules.AlphanumericCharset
					}
					entropy := rules.ShannonEntropy(
						secret, charsetStr,
					)
					finding.Entropy = entropy

					if entropy < *rule.Entropy {
						continue
					}
				}

				if !FilterFinding(&finding, rule) {
					continue
				}

				findings = append(findings, finding)
			}
		}
	}

	findings = append(
		findings,
		d.detectHighEntropy(chunk, lines, findings)...,
	)

	return findings
}
```

---

## Documentation

### Documentation for `Detect` Function

**Purpose and Behavior:**
The `Detect` function in the `Detector` struct is responsible for identifying potential secrets within a chunk of text based on predefined rules. It splits the content into lines, applies matching keywords, and then checks each line against defined patterns to extract possible secrets.

**Key Implementation Details:**
1. **Keyword Matching:** Uses a registry to match keywords from the chunk's content.
2. **Pattern Matching:** Iterates over matched rules and their associated patterns to find secret matches in each line.
3. **Entropy Calculation:** Optionally calculates Shannon entropy for detected secrets, filtering out low-entropy findings.
4. **Finding Construction:** Constructs `types.Finding` objects with relevant details like rule ID, description, severity, and metadata.

**When/Why to Use:**
This function is used when you need to scan large text chunks (e.g., source code or configuration files) for potential secrets. It is particularly useful in static analysis tools where security vulnerabilities must be proactively identified.

**Patterns and Gotchas:**
- **Error Handling:** The function relies on the `MatchKeywords` method's error handling, which should be robust.
- **Performance Considerations:** High entropy calculations can be computationally expensive; ensure this is optimized for large files.
- **Rule Customization:** Rules are flexible but must be carefully defined to avoid false positives or negatives.

---

*Generated by CodeWorm on 2026-02-27 17:40*
