# FetchAuditData

**Type:** Documentation
**Repository:** Yoshi-Audit
**File:** internal/ui/audittab/audittab.go
**Language:** go
**Lines:** 71-116
**Complexity:** 8.0

---

## Source Code

```go
func FetchAuditData(scanner *audit.Scanner, rssHistory map[int][]uint64) tea.Msg {
	procs, err := system.GetProcesses()
	if err != nil {
		return AuditDataMsg{Err: err}
	}

	gpuProcs, _ := system.GetGPUProcesses()

	for _, p := range procs {
		rssHistory[p.PID] = append(rssHistory[p.PID], p.RSS)
	}

	findings := scanner.ScanAll(procs, gpuProcs)
	findings = append(findings, scanner.ScanMemoryLeaks(procs, rssHistory)...)

	summary := make(map[audit.FindingType]SummaryCount)
	allTypes := []audit.FindingType{
		audit.FindingZombie,
		audit.FindingOrphan,
		audit.FindingDaemon,
		audit.FindingKernelThread,
		audit.FindingGPUShadow,
		audit.FindingMemoryLeak,
		audit.FindingUnknownSvc,
	}
	for _, ft := range allTypes {
		summary[ft] = SummaryCount{}
	}
	for _, f := range findings {
		sc := summary[f.Type]
		switch f.Severity {
		case audit.SeverityOK:
			sc.OK++
		case audit.SeverityWarn:
			sc.Warn++
		case audit.SeverityCrit:
			sc.Crit++
		}
		summary[f.Type] = sc
	}

	return AuditDataMsg{
		Findings: findings,
		Summary:  summary,
	}
}
```

---

## Documentation

### Documentation for `FetchAuditData` Function

**Purpose and Behavior:**
The `FetchAuditData` function in the `audittab.go` file retrieves system process information, scans for various audit findings, and compiles a summary of these findings. It returns an `AuditDataMsg` containing detailed findings and their severity counts.

**Key Implementation Details:**
- **Process Information Retrieval:** The function fetches processes using `system.GetProcesses()` and GPU processes with `system.GetGPUProcesses()`.
- **Memory Usage Tracking:** It updates the `rssHistory` map to track Real Memory Size (RSS) for each process.
- **Finding Scanning:** Uses an `audit.Scanner` instance to scan for specific types of findings, including memory leaks.
- **Summary Compilation:** Aggregates findings by type and severity into a summary map.

**When/Why to Use:**
This function is crucial for generating comprehensive audit reports. It should be used in scenarios where detailed system process analysis and memory usage tracking are required to identify potential issues such as memory leaks, orphan processes, or GPU shadowing.

**Patterns and Gotchas:**
- **Error Handling:** The function returns an `AuditDataMsg` with an error if any step fails, ensuring robustness.
- **Map Updates:** Modifying the `rssHistory` map in place can lead to race conditions if not synchronized properly. Use mutexes or channels for safe concurrent access.
- **Summary Aggregation:** The use of a switch statement within a loop for aggregating findings by severity is efficient but ensure it remains clear and maintainable as the number of finding types grows.

---

*Generated by CodeWorm on 2026-02-28 23:30*
