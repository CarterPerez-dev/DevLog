# runUpdate

**Repository:** Cybersecurity-Projects
**File:** PROJECTS/beginner/simple-vulnerability-scanner/internal/cli/update.go
**Language:** go
**Lines:** 269-359
**Complexity:** 14.0

---

## Source Code

```go
func runUpdate(
	ctx context.Context,
	f *updateFlags,
	dryRun bool,
) error {
	start := time.Now()
	cfg := config.Load(f.file)

	deps, err := parseDeps(f.file)
	if err != nil {
		return err
	}

	spin := ui.NewSpinner(fmt.Sprintf(
		"Scanning %d dependencies...", len(deps),
	))
	spin.Start()

	client, err := pypi.NewClient(defaultCacheDir())
	if err != nil {
		spin.Stop()
		return err
	}

	names := make([]string, len(deps))
	for i, d := range deps {
		names[i] = d.Name
	}
	fetched := client.FetchAllVersions(ctx, names)

	versionMap := make(map[string][]string, len(fetched))
	for _, r := range fetched {
		if r.Err == nil {
			versionMap[r.Name] = r.Versions
		}
	}

	updates, updateSpecs := resolveUpdates(
		deps, versionMap, f.safe,
		f.includePrerelease, cfg.Ignore,
	)

	sortUpdates(updates)

	var vulns map[string][]types.Vulnerability
	var scanErr error
	if f.vulns {
		vulns, scanErr = scanForVulns(ctx, deps)
	}

	spin.Stop()

	if scanErr != nil {
		PrintError(scanErr.Error())
	}

	if !dryRun && len(updateSpecs) > 0 {
		if err := updateDepsFile(
			f.file, updateSpecs,
		); err != nil {
			return fmt.Errorf("write updates: %w", err)
		}
	}

	minSev := resolveMinSeverity(cfg.MinSeverity)
	if vulns != nil {
		vulns = filterIgnoredVulns(vulns, cfg.IgnoreVulns)
		vulns = filterVulnsBySeverity(vulns, minSev)
		PrintVulnerabilities(vulns)
	}

	PrintUpdates(updates)
	PrintSkipped(updates)

	totalVulns := 0
	for _, vl := range vulns {
		totalVulns += len(vl)
	}

	PrintSummary(types.ScanResult{
		Updates:         updates,
		Vulnerabilities: vulns,
		TotalPackages:   len(deps),
		TotalUpdated:    len(updateSpecs),
		TotalVulns:      totalVulns,
		VulnsScanned:    f.vulns,
		Duration:        time.Since(start),
	}, !dryRun && len(updateSpecs) > 0)

	return nil
}
```

---

## Documentation

### Documentation for `runUpdate` Function

**Purpose and Behavior:**
The `runUpdate` function in Go is designed to scan dependencies, fetch their versions from PyPI, resolve updates based on specified flags, and optionally check for vulnerabilities. It logs the results, including updates and vulnerabilities, and handles dry runs.

**Key Implementation Details:**
- **Context Management:** Uses a context for asynchronous operations.
- **Dependency Parsing:** Loads configuration and parses dependency files.
- **Client Initialization:** Initializes a PyPI client to fetch version data.
- **Update Resolution:** Compares current versions with latest available versions to determine updates.
- **Vulnerability Scanning:** Optionally scans dependencies for known vulnerabilities.
- **Error Handling:** Properly handles errors during each step, ensuring the function returns an error if any part fails.

**When/Why to Use:**
This function is ideal for automated dependency management and security checks in Go projects. It can be used in CI pipelines or as a standalone tool to ensure dependencies are up-to-date and secure.

**Patterns and Gotchas:**
- **Error Handling:** The function returns an error if any part of the process fails, ensuring robustness.
- **Dry Run Mode:** Allows testing without applying actual updates, useful for previewing changes.
- **Performance Considerations:** The use of goroutines or concurrent operations should be carefully managed to avoid overwhelming system resources.

---

*Generated by CodeWorm on 2026-01-29 07:28*
