# parseComposeFile

**Repository:** angelamos-operations
**File:** docker-api/internal/scanner/finder.go
**Language:** go
**Lines:** 140-235
**Complexity:** 14.0

---

## Source Code

```go
func (s *Scanner) parseComposeFile(
	ctx context.Context,
	path string,
) (*model.Project, error) {
	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	checksum, err := fileChecksum(path)
	if err != nil {
		return nil, err
	}

	s.mu.RLock()
	cached, exists := s.cache[path]
	s.mu.RUnlock()

	if exists && cached.ModTime.Equal(info.ModTime()) &&
		cached.CheckSum == checksum {
		return cached.Project, nil
	}

	projectName := deriveProjectName(path)

	oldStderr := os.Stderr
	devNull, devNullErr := os.OpenFile(os.DevNull, os.O_WRONLY, 0)
	if devNullErr == nil {
		os.Stderr = devNull
	}

	opts, err := cli.NewProjectOptions(
		[]string{path},
		cli.WithName(projectName),
		cli.WithResolvedPaths(true),
		cli.WithInterpolation(true),
		cli.WithProfiles([]string{}),
	)

	os.Stderr = oldStderr
	if devNull != nil {
		devNull.Close()
	}

	if err != nil {
		return nil, err
	}

	os.Stderr = devNull
	if devNullErr == nil {
		devNull, _ = os.OpenFile(os.DevNull, os.O_WRONLY, 0)
	}

	composeProject, err := opts.LoadProject(ctx)

	os.Stderr = oldStderr
	if devNull != nil {
		devNull.Close()
	}
	if err != nil {
		return nil, err
	}

	if len(composeProject.Services) == 0 {
		return nil, nil
	}

	services := make([]string, 0, len(composeProject.Services))
	for _, svc := range composeProject.Services {
		services = append(services, svc.Name)
	}

	proj := &model.Project{
		ID:              generateProjectID(path),
		Name:            projectName,
		Path:            filepath.Dir(path),
		ComposeFile:     filepath.Base(path),
		ComposeFilePath: path,
		Environment:     detectEnvironment(path),
		Status:          model.StatusUnknown,
		Services:        services,
		Containers:      make([]model.Container, 0),
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	s.mu.Lock()
	s.cache[path] = &CachedProject{
		Project:  proj,
		ModTime:  info.ModTime(),
		CheckSum: checksum,
	}
	s.mu.Unlock()

	return proj, nil
}
```

---

## Documentation

### Documentation for `parseComposeFile` Function

**Purpose and Behavior:**
The `parseComposeFile` function in the Go package `docker-api/internal/scanner/finder.go` reads, validates, and parses a Docker Compose file to extract project details. It checks if the file has been modified or its checksum changed before re-parsing, optimizing performance.

**Key Implementation Details:**
- **Context Handling:** Uses a context for asynchronous operations.
- **File Checksum:** Computes a checksum of the file content to detect changes without reading the entire file.
- **Error Handling:** Returns detailed errors at each step.
- **Logging:** Temporarily redirects stderr to `/dev/null` to suppress output during project loading.

**When/Why to Use:**
Use this function when you need to parse Docker Compose files efficiently, especially in scenarios where the same file is frequently accessed. It minimizes redundant parsing by caching results and only re-parsing if necessary.

**Patterns/Gotchas:**
- **Resource Management:** Ensure `os.Stderr` is restored after use.
- **Error Propagation:** The function returns detailed errors at each step, making debugging easier but requiring careful error handling in the caller.
- **Concurrency Safety:** Uses a mutex to safely access and update the cache.

This function embodies Go's emphasis on robust error handling and efficient resource management.

---

*Generated by CodeWorm on 2026-01-13 01:15*
