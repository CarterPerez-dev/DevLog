# run

**Repository:** angelamos-operations
**File:** Docker-Kentros/cmd/server/main.go
**Language:** go
**Lines:** 80-189
**Complexity:** 10.0

---

## Source Code

```go
func run(ctx context.Context, cfg *config.Config, logger *slog.Logger) error {
	logger.Info("starting holophyly",
		"version", version,
		"address", cfg.Address(),
	)

	dockerClient, err := docker.NewClient()
	if err != nil {
		return fmt.Errorf("creating docker client: %w", err)
	}
	defer func() { _ = dockerClient.Close() }()

	if err := dockerClient.Ping(ctx); err != nil {
		return fmt.Errorf("docker daemon not available: %w", err)
	}
	logger.Info("connected to docker daemon")

	if !docker.IsComposeInstalled(ctx) {
		logger.Warn("docker compose not found - compose operations will fail")
	}

	dataDir := cfg.DataDir
	if dataDir == "" {
		home, _ := os.UserHomeDir()
		dataDir = filepath.Join(home, ".config", "holophyly")
	}

	prefStore, err := store.New(dataDir)
	if err != nil {
		logger.Warn("failed to initialize preferences store", "error", err)
	} else {
		defer func() { _ = prefStore.Close() }()
		logger.Info("preferences store initialized", "path", dataDir)
	}

	fileScanner := scanner.NewScanner(cfg.Scanner.Paths, cfg.Scanner.Exclude)

	protection := project.NewProtectionConfig(
		cfg.Protection.Patterns,
		cfg.Protection.Projects,
	)

	manager := project.NewManager(dockerClient, fileScanner, protection, prefStore)

	if err := manager.Refresh(ctx); err != nil {
		logger.Warn("initial project scan failed", "error", err)
	} else {
		projects := manager.ListProjects()
		logger.Info("initial scan complete", "projects_found", len(projects))
	}

	hub := websocket.NewHub(logger)
	go hub.Run(ctx)

	router := api.NewRouter(api.RouterConfig{
		Manager:        manager,
		Hub:            hub,
		Logger:         logger,
		AllowedOrigins: cfg.Server.AllowedOrigins,
	})

	api.MountStatic(router, web.FS())

	server := &http.Server{
		Addr:         cfg.Address(),
		Handler:      router,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 10 * time.Minute,
		IdleTimeout:  60 * time.Second,
	}

	go runPeriodicScanner(ctx, manager, cfg.Scanner.ScanInterval, logger)

	go hub.StartStatsStreamer(ctx, createStatsGetter(manager))

	serverErr := make(chan error, 1)
	go func() {
		logger.Info("server listening",
			"host", cfg.Server.Host,
			"port", cfg.Server.Port,
			"url", fmt.Sprintf("http://%s", cfg.Address()),
		)
		if err := server.ListenAndServe(); err != http.ErrServerClosed {
			serverErr <- err
		}
		close(serverErr)
	}()

	select {
	case err := <-serverErr:
		return fmt.Errorf("server error: %w", err)
	case <-ctx.Done():
		logger.Info("shutdown signal received")
	}

	shutdownCtx, cancel := context.WithTimeout(
		context.Background(),
		30*time.Second,
	)
	defer cancel()

	logger.Info("shutting down server")
	if err := server.Shutdown(shutdownCtx); err != nil {
		logger.Error("server shutdown error", "error", err)
		return fmt.Errorf("shutdown error: %w", err)
	}

	logger.Info("server stopped gracefully")
	return nil
}
```

---

## Documentation

### Documentation for `run` Function

**Purpose and Behavior:**
The `run` function initializes and starts the Holophyly server, handling setup tasks such as connecting to Docker, initializing preferences storage, scanning projects, setting up websockets, and starting an HTTP server. It logs important events and handles graceful shutdowns.

**Key Implementation Details:**
- **Context Handling:** Uses a context for lifecycle management and graceful shutdown.
- **Error Propagation:** Errors are logged and returned, ensuring issues are tracked.
- **Resource Management:** Properly closes resources like Docker clients and preference stores using deferred functions.
- **Concurrency:** Utilizes goroutines to run background tasks such as periodic scanning and stats streaming.

**When/Why to Use:**
This function is crucial for starting the Holophyly server. It ensures that all necessary components are initialized correctly before the server begins operation, making it ideal for production environments where reliability and logging are critical.

**Patterns and Gotchas:**
- **Error Handling:** The use of `fmt.Errorf` for error propagation and logging is consistent throughout.
- **Graceful Shutdown:** The function handles shutdown signals with a timeout to ensure all background tasks complete before stopping the server.
- **Resource Management:** Proper use of deferred functions ensures resources are cleaned up even if an error occurs.

---

*Generated by CodeWorm on 2026-01-22 23:17*
