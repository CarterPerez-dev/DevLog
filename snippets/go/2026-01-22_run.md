# run

**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/cmd/api/main.go
**Language:** go
**Lines:** 46-192
**Complexity:** 11.0

---

## Source Code

```go
func run(configPath string) error {
	ctx, stop := signal.NotifyContext(
		context.Background(),
		syscall.SIGINT,
		syscall.SIGTERM,
	)
	defer stop()

	_ = godotenv.Load()

	cfg, err := config.Load(configPath)
	if err != nil {
		return err
	}

	logger := setupLogger(cfg.Log)
	slog.SetDefault(logger)

	logger.Info("starting application",
		"name", cfg.App.Name,
		"version", cfg.App.Version,
		"environment", cfg.App.Environment,
	)

	mongoClient, err := mongodb.NewClient(ctx, cfg.Mongo)
	if err != nil {
		return err
	}
	logger.Info("mongodb connected",
		"database", cfg.Mongo.Database,
		"max_pool_size", cfg.Mongo.MaxPoolSize,
	)

	sqliteClient, err := sqlite.NewClient(cfg.SQLite)
	if err != nil {
		return err
	}
	logger.Info("sqlite connected",
		"path", cfg.SQLite.Path,
	)

	healthHandler := health.NewHandler(mongoClient, sqliteClient)

	metricsRepo := mongodb.NewMetricsRepository(mongoClient)
	metricsSvc := metrics.NewService(metricsRepo, cfg.Mongo.Database)
	metricsHandler := handler.NewMetricsHandler(metricsSvc)

	backupRepo := sqlite.NewBackupRepository(sqliteClient)
	backupExecutor := backup.NewExecutor(cfg.Backup, cfg.Mongo.URI)
	backupScheduler := backup.NewScheduler(logger)
	backupSvc := backup.NewService(backupExecutor, backupScheduler, backupRepo, cfg.Backup.RetentionDays, logger)
	backupsHandler := handler.NewBackupsHandler(backupSvc, cfg.Mongo.Database)

	collectionsRepo := mongodb.NewCollectionsRepository(mongoClient)
	collectionsHandler := handler.NewCollectionsHandler(collectionsRepo, cfg.Mongo.Database)

	cleanupSvc := cleanup.NewService(mongoClient.Client(), cfg.Mongo.Database, 30, logger)

	wsHub := websocket.NewHub(logger)
	go wsHub.Run(ctx)

	wsHandler := websocket.NewHandler(wsHub, logger)

	metricsGetter := func(ctx context.Context) (any, error) {
		return metricsSvc.GetDashboardMetrics(ctx)
	}
	broadcaster := websocket.NewMetricsBroadcaster(wsHub, metricsGetter, 2000, logger)
	broadcaster.Start(ctx)
	logger.Info("websocket broadcaster started", "interval_ms", 2000)

	srv := server.New(server.Config{
		ServerConfig:  cfg.Server,
		HealthHandler: healthHandler,
		Logger:        logger,
	})

	router := srv.Router()

	router.Use(middleware.RequestID)
	router.Use(middleware.Logger(logger))
	router.Use(middleware.SecurityHeaders(cfg.App.Environment == "production"))
	router.Use(middleware.CORS(cfg.CORS))

	healthHandler.RegisterRoutes(router)
	metricsHandler.RegisterRoutes(router)
	backupsHandler.RegisterRoutes(router)
	collectionsHandler.RegisterRoutes(router)
	router.Handle("/ws", wsHandler)

	backupSvc.StartScheduler()
	if err := backupSvc.SetupDailyBackup(cfg.Mongo.Database); err != nil {
		logger.Warn("failed to setup daily backup", "error", err)
	}

	_, err = backupScheduler.Cron().AddFunc("0 20 21 * * *", func() {
		cleanupCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
		defer cancel()

		logger.Info("starting scheduled cleanup task")
		_, cleanupErr := cleanupSvc.CleanOldDocuments(cleanupCtx)
		if cleanupErr != nil {
			logger.Error("scheduled cleanup failed", "error", cleanupErr)
		}
	})
	if err != nil {
		logger.Warn("failed to setup daily cleanup", "error", err)
	} else {
		logger.Info("daily cleanup scheduled", "time", "3:05 PM")
	}

	errChan := make(chan error, 1)
	go func() {
		errChan <- srv.Start()
	}()

	select {
	case err := <-errChan:
		return err
	case <-ctx.Done():
		logger.Info("shutdown signal received")
	}

	shutdownCtx, cancel := context.WithTimeout(
		context.Background(),
		cfg.Server.ShutdownTimeout+drainDelay+5*time.Second,
	)
	defer cancel()

	if err := srv.Shutdown(shutdownCtx, drainDelay); err != nil {
		logger.Error("server shutdown error", "error", err)
	}

	schedulerCtx := backupSvc.StopScheduler()
	<-schedulerCtx.Done()
	logger.Info("backup scheduler stopped")

	if err := mongoClient.Close(shutdownCtx); err != nil {
		logger.Error("mongodb close error", "error", err)
	}

	if err := sqliteClient.Close(); err != nil {
		logger.Error("sqlite close error", "error", err)
	}

	logger.Info("application stopped")
	return nil
}
```

---

## Documentation

### Documentation for `run` Function

**Purpose and Behavior:**
The `run` function initializes a Go application by setting up various components such as logging, configuration loading, database connections, health checks, metrics handling, backup scheduling, WebSocket server, and HTTP server. It handles signals to gracefully shut down the application.

**Key Implementation Details:**
- **Context Management:** Uses `context.Context` for managing lifecycle and timeouts.
- **Signal Handling:** Listens for SIGINT and SIGTERM to handle graceful shutdowns.
- **Dependency Injection:** Utilizes interfaces like `Logger`, `MongoClient`, `SQLiteClient`, etc., for modular design.
- **Error Handling:** Returns errors from critical operations and logs them.

**When/Why to Use This Code:**
This function is the entry point of a Go backend application. It should be used when initializing an application that requires configuration loading, database connections, health checks, and WebSocket communication. The structured error handling ensures robustness during runtime.

**Patterns and Gotchas:**
- **Error Handling:** Always check for errors and log them appropriately.
- **Graceful Shutdown:** Properly handles shutdown signals to ensure all resources are closed gracefully.
- **Concurrency:** Uses goroutines for background tasks like WebSocket broadcaster, backup scheduler, and cleanup service. Ensure proper context management in these goroutines.

This function encapsulates the core logic of starting an application, making it a crucial part of any Go backend project.

---

*Generated by CodeWorm on 2026-01-22 20:09*
