# AnalyzeSlowQueries

**Repository:** angelamos-operations
**File:** CertGamesDB-Argos/go-backend/internal/metrics/service.go
**Language:** go
**Lines:** 304-404
**Complexity:** 15.0

---

## Source Code

```go
func (s *Service) AnalyzeSlowQueries(ctx context.Context, minMillis, limit int) (*SlowQueryAnalysis, error) {
	queries, err := s.repo.GetSlowQueries(ctx, s.database, minMillis, limit)
	if err != nil {
		return nil, fmt.Errorf("get slow queries: %w", err)
	}

	collectionMap := make(map[string]*collectionAggregator)
	operationMap := make(map[string]*operationAggregator)
	suggestionMap := make(map[string]*IndexSuggestion)

	for _, q := range queries {
		if agg, ok := collectionMap[q.Namespace]; ok {
			agg.count++
			agg.totalMillis += q.MillisRuntime
			if q.MillisRuntime > agg.maxMillis {
				agg.maxMillis = q.MillisRuntime
			}
		} else {
			collectionMap[q.Namespace] = &collectionAggregator{
				namespace:   q.Namespace,
				count:       1,
				totalMillis: q.MillisRuntime,
				maxMillis:   q.MillisRuntime,
			}
		}

		if agg, ok := operationMap[q.Op]; ok {
			agg.count++
			agg.totalMillis += q.MillisRuntime
		} else {
			operationMap[q.Op] = &operationAggregator{
				operation:   q.Op,
				count:       1,
				totalMillis: q.MillisRuntime,
			}
		}

		if q.PlanSummary == "COLLSCAN" && q.DocsExamined > 100 {
			key := q.Namespace + ":COLLSCAN"
			if sug, ok := suggestionMap[key]; ok {
				sug.Occurrences++
			} else {
				suggestionMap[key] = &IndexSuggestion{
					Collection:     q.Namespace,
					SuggestedIndex: []string{"_id"},
					Reason:         "Collection scan detected with high document examination",
					QueryPattern:   "COLLSCAN",
					Occurrences:    1,
				}
			}
		}

		if q.KeysExamined > 0 && q.DocsExamined > q.KeysExamined*10 {
			key := q.Namespace + ":INEFFICIENT_INDEX"
			if sug, ok := suggestionMap[key]; ok {
				sug.Occurrences++
			} else {
				suggestionMap[key] = &IndexSuggestion{
					Collection:     q.Namespace,
					SuggestedIndex: []string{"examine query filter fields"},
					Reason:         fmt.Sprintf("Inefficient index usage: %d docs examined vs %d keys", q.DocsExamined, q.KeysExamined),
					QueryPattern:   q.PlanSummary,
					Occurrences:    1,
				}
			}
		}
	}

	var topCollections []CollectionStats
	for _, agg := range collectionMap {
		topCollections = append(topCollections, CollectionStats{
			Namespace: agg.namespace,
			Count:     agg.count,
			AvgMillis: float64(agg.totalMillis) / float64(agg.count),
			MaxMillis: agg.maxMillis,
		})
	}

	var topOperations []OperationStats
	for _, agg := range operationMap {
		topOperations = append(topOperations, OperationStats{
			Operation: agg.operation,
			Count:     agg.count,
			AvgMillis: float64(agg.totalMillis) / float64(agg.count),
		})
	}

	var suggestions []IndexSuggestion
	for _, sug := range suggestionMap {
		suggestions = append(suggestions, *sug)
	}

	return &SlowQueryAnalysis{
		Database:        s.database,
		TotalQueries:    len(queries),
		AnalyzedQueries: len(queries),
		Suggestions:     suggestions,
		TopCollections:  topCollections,
		TopOperations:   topOperations,
	}, nil
}
```

---

## Documentation

### Documentation for `AnalyzeSlowQueries` Function

**Purpose and Behavior:**
The `AnalyzeSlowQueries` function in the `Service` struct analyzes slow database queries by categorizing them based on their namespace, operation, and query pattern. It then generates suggestions to optimize inefficient queries.

**Key Implementation Details:**
1. **Error Handling:** The function returns a detailed error message if there's an issue fetching slow queries.
2. **Aggregation Logic:** Queries are grouped into collections and operations using maps (`collectionMap`, `operationMap`), and suggestions for index optimizations are generated based on specific conditions (e.g., high document examination, inefficient indexes).
3. **Result Construction:** Aggregated data is transformed into structured outputs like `CollectionStats`, `OperationStats`, and `IndexSuggestion`.

**When/Why to Use:**
This function should be used in monitoring and optimizing database performance by identifying slow queries and suggesting improvements. It's particularly useful during regular maintenance or when troubleshooting performance issues.

**Patterns/Gotchas:**
- **Efficient Aggregation:** The use of maps for aggregation ensures that the function scales well with a large number of queries.
- **Suggestion Generation:** The logic for generating index suggestions is based on specific conditions, which may need to be adjusted depending on the database schema and usage patterns.

This function embodies Go's idiomatic practices in error handling and data structuring.

---

*Generated by CodeWorm on 2026-01-22 16:53*
