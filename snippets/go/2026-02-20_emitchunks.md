# emitChunks

**Type:** Documentation
**Repository:** Cybersecurity-Projects
**File:** PROJECTS/intermediate/secrets-scanner/internal/source/directory.go
**Language:** go
**Lines:** 89-150
**Complexity:** 11.0

---

## Source Code

```go
func (d *Directory) emitChunks(
	ctx context.Context,
	absPath, relPath string,
	out chan<- types.Chunk,
) error {
	f, err := os.Open(absPath)
	if err != nil {
		return nil
	}
	defer f.Close()

	var buf strings.Builder
	scanner := bufio.NewScanner(f)
	scanner.Buffer(make([]byte, 0, 512*1024), 512*1024)

	lineNum := 0
	chunkStart := 1
	linesInChunk := 0

	for scanner.Scan() {
		if ctx.Err() != nil {
			return ctx.Err()
		}

		lineNum++
		linesInChunk++

		if buf.Len() > 0 {
			buf.WriteByte('\n')
		}
		buf.WriteString(scanner.Text())

		if linesInChunk >= 50 {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case out <- types.Chunk{
				Content:   buf.String(),
				FilePath:  relPath,
				LineStart: chunkStart,
			}:
			}
			buf.Reset()
			chunkStart = lineNum + 1
			linesInChunk = 0
		}
	}

	if buf.Len() > 0 {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case out <- types.Chunk{
			Content:   buf.String(),
			FilePath:  relPath,
			LineStart: chunkStart,
		}:
		}
	}

	return nil
}
```

---

## Documentation

### Documentation for `emitChunks` Function

**Purpose and Behavior:**
The `emitChunks` function reads a file line by line, buffering up to 50 lines at a time into chunks of text. Each chunk is emitted via the provided channel `out`. The function handles context cancellation gracefully, stopping emission when the context is done.

**Key Implementation Details:**
- **Context Handling:** Uses `ctx.Err()` to check for context cancellation.
- **Buffering:** Utilizes `strings.Builder` and a buffered scanner to efficiently read large files in chunks.
- **Chunk Emission:** Chunks are emitted only after 50 lines have been accumulated, or when the context is cancelled.

**When/Why to Use:**
Use this function for processing large text files where you need to emit content in manageable chunks. It's particularly useful in scenarios requiring real-time analysis or when dealing with potentially very large files that should not block indefinitely.

**Patterns and Gotchas:**
- **Error Handling:** The function returns `nil` on error, which might mask issues; consider logging errors for better debugging.
- **Concurrency Safety:** Ensure the channel `out` is properly managed to avoid blocking or race conditions.

---

*Generated by CodeWorm on 2026-02-20 07:26*
